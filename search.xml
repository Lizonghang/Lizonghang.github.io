<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Hadoop安装与伪分布式部署]]></title>
      <url>http://lizonghang.github.io/2018/01/09/Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<p>注意: 本文中<code>~</code>建议换成完整路径。</p>
<p>注意: 由于对内存要求较高，建议直接在本机，而不是在虚拟机进行实验。</p>
<h1 id="Java环境要求"><a href="#Java环境要求" class="headerlink" title="Java环境要求"></a>Java环境要求</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜ java -version</div><div class="line">java version &quot;1.8.0_91&quot;</div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_91-b14)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)</div><div class="line">➜ javac -version</div><div class="line">javac 1.8.0_111</div><div class="line">➜ jps</div><div class="line">28460 Jps</div></pre></td></tr></table></figure>
<p>若Java版本较低，建议升级到Java1.8，在官网下载对应系统的<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">jdk-8u151或jdk-8u152</a>覆盖当前版本。</p>
<h1 id="ZooKeeper安装与配置"><a href="#ZooKeeper安装与配置" class="headerlink" title="ZooKeeper安装与配置"></a>ZooKeeper安装与配置</h1><h2 id="ZooKeeper安装"><a href="#ZooKeeper安装" class="headerlink" title="ZooKeeper安装"></a>ZooKeeper安装</h2><p>在<a href="https://www.apache.org/dyn/closer.cgi/zookeeper/" target="_blank" rel="external">ZooKeeper</a>官网下载较新版本的ZooKeeper。作者使用的ZooKeeper 3.4.11。假设解压到目录<code>~/zookeeper/zookeeper-3.4.11-0</code>。</p>
<h2 id="ZooKeeper配置"><a href="#ZooKeeper配置" class="headerlink" title="ZooKeeper配置"></a>ZooKeeper配置</h2><p>进入ZooKeeper根目录，添加配置文件<code>zoo.cfg</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ cp conf/zoo_sample.cfg conf/zoo.cfg</div><div class="line">➜ vim conf/zoo.cfg</div></pre></td></tr></table></figure>
<p><code>zoo.cfg</code>配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">tickTime=2000</div><div class="line">initLimit=10</div><div class="line">syncLimit=5</div><div class="line">dataDir=~/zookeeper/zookeeper-3.4.11-0/data</div><div class="line">clientPort=2181</div><div class="line"></div><div class="line">server.0=127.0.0.1:8880:7770</div><div class="line">server.1=127.0.0.1:8881:7771</div><div class="line">server.2=127.0.0.1:8882:7772</div></pre></td></tr></table></figure>
<p>在ZooKeeper根目录下新建<code>./data/myid</code>，其记录值为<code>server.X</code>的<code>X</code>值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ mkdir data</div><div class="line">➜ echo 0 &gt; data/myid</div></pre></td></tr></table></figure>
<p>复制ZooKeeper两次，得到三个ZooKeeper文件夹:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜ cd ~/zookeeper</div><div class="line">➜ cp zookeeper-3.4.11-0 zookeeper-3.4.11-1</div><div class="line">➜ cp zookeeper-3.4.11-0 zookeeper-3.4.11-2</div></pre></td></tr></table></figure>
<p>分别修改<code>zookeeper-3.4.11-1/conf/zoo.cfg</code>和<code>zookeeper-3.4.11-2/conf/zoo.cfg</code>，将<code>dataDir</code>中的路径修改为对应文件夹名称的路径，并修改对应的<code>data/myid</code>记录值。</p>
<h2 id="ZooKeeper启动、停止与状态查询"><a href="#ZooKeeper启动、停止与状态查询" class="headerlink" title="ZooKeeper启动、停止与状态查询"></a>ZooKeeper启动、停止与状态查询</h2><h3 id="ZooKeeper启动"><a href="#ZooKeeper启动" class="headerlink" title="ZooKeeper启动"></a>ZooKeeper启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/zookeeper/zookeeper-3.4.11-0</div><div class="line">bin/zkServer.sh start conf/zoo.cfg</div></pre></td></tr></table></figure>
<h3 id="ZooKeeper停止"><a href="#ZooKeeper停止" class="headerlink" title="ZooKeeper停止"></a>ZooKeeper停止</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/zkServer.sh stop</div></pre></td></tr></table></figure>
<h3 id="ZooKeeper状态查询"><a href="#ZooKeeper状态查询" class="headerlink" title="ZooKeeper状态查询"></a>ZooKeeper状态查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/zkServer.sh status</div></pre></td></tr></table></figure>
<h2 id="ZooKeeper批量操作脚本"><a href="#ZooKeeper批量操作脚本" class="headerlink" title="ZooKeeper批量操作脚本"></a>ZooKeeper批量操作脚本</h2><p>在<code>~/zookeeper</code>新建一个文件夹<code>scripts</code>以存放脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ ls</div><div class="line">zoo-start-all.sh  zoo-status-all.sh  zoo-stop-all.sh</div></pre></td></tr></table></figure>
<p><code>zoo-start-all.sh</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">ZK_HOME_0=/home/lizh/zookeeper/zookeeper-3.4.11-0</div><div class="line">ZK_HOME_1=/home/lizh/zookeeper/zookeeper-3.4.11-1</div><div class="line">ZK_HOME_2=/home/lizh/zookeeper/zookeeper-3.4.11-2</div><div class="line"></div><div class="line">$ZK_HOME_0/bin/zkServer.sh start $ZK_HOME_0/conf/zoo.cfg</div><div class="line">$ZK_HOME_1/bin/zkServer.sh start $ZK_HOME_1/conf/zoo.cfg</div><div class="line">$ZK_HOME_2/bin/zkServer.sh start $ZK_HOME_2/conf/zoo.cfg</div><div class="line"></div><div class="line">jps</div></pre></td></tr></table></figure>
<p><code>zoo-stop-all.sh</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">ZK_HOME_0=/home/lizh/zookeeper/zookeeper-3.4.11-0</div><div class="line">ZK_HOME_1=/home/lizh/zookeeper/zookeeper-3.4.11-1</div><div class="line">ZK_HOME_2=/home/lizh/zookeeper/zookeeper-3.4.11-2</div><div class="line"></div><div class="line">$ZK_HOME_0/bin/zkServer.sh stop</div><div class="line">$ZK_HOME_1/bin/zkServer.sh stop</div><div class="line">$ZK_HOME_2/bin/zkServer.sh stop</div><div class="line"></div><div class="line">jps</div></pre></td></tr></table></figure></p>
<p><code>zoo-status-all.sh</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">ZK_HOME_0=/home/lizh/zookeeper/zookeeper-3.4.11-0</div><div class="line">ZK_HOME_1=/home/lizh/zookeeper/zookeeper-3.4.11-1</div><div class="line">ZK_HOME_2=/home/lizh/zookeeper/zookeeper-3.4.11-2</div><div class="line"></div><div class="line">$ZK_HOME_0/bin/zkServer.sh status</div><div class="line">$ZK_HOME_1/bin/zkServer.sh status</div><div class="line">$ZK_HOME_2/bin/zkServer.sh status</div><div class="line"></div><div class="line">jps</div></pre></td></tr></table></figure></p>
<p>并将路径<code>~/zookeeper/scripts</code>添加到<code>PATH</code>中，便可方便地批量启动、停止、查看ZooKeeper的状态。</p>
<h2 id="ZooKeeper启动与状态"><a href="#ZooKeeper启动与状态" class="headerlink" title="ZooKeeper启动与状态"></a>ZooKeeper启动与状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜ zoo-start-all.sh</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-0/conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-1/conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-2/conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div><div class="line">27895 QuorumPeerMain</div><div class="line">27752 QuorumPeerMain</div><div class="line">27821 QuorumPeerMain</div></pre></td></tr></table></figure>
<p>可以看到ZooKeeper启动了三个<code>QuorumPeerMain</code>进程。因为ZooKeeper采用投票机制选举Leader，因此至少需要启动三个进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜ zoo-status-all.sh</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-0/bin/../conf/zoo.cfg</div><div class="line">Mode: follower</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-1/bin/../conf/zoo.cfg</div><div class="line">Mode: leader</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-2/bin/../conf/zoo.cfg</div><div class="line">Mode: follower</div><div class="line">27895 QuorumPeerMain</div><div class="line">27752 QuorumPeerMain</div><div class="line">27821 QuorumPeerMain</div></pre></td></tr></table></figure>
<p>一个ZooKeeper集群中有且仅能有一个投票选出的Leader，其它都是Learner(包括ObServer和Follower)。此时Client可以通过端口2181~2183连接任意一个ZooKeeper:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">➜ ~/zookeeper/zookeeper-3.4.11-0/bin/zkCli.sh -server 127.0.0.1:2181</div><div class="line">...</div><div class="line">[zk: 127.0.0.1:2181(CONNECTED) 0] help</div><div class="line">ZooKeeper -server host:port cmd args</div><div class="line">        stat path [watch]</div><div class="line">        set path data [version]</div><div class="line">        ls path [watch]</div><div class="line">        delquota [-n|-b] path</div><div class="line">        ls2 path [watch]</div><div class="line">        setAcl path acl</div><div class="line">        setquota -n|-b val path</div><div class="line">        history</div><div class="line">        redo cmdno</div><div class="line">        printwatches on|off</div><div class="line">        delete path [version]</div><div class="line">        sync path</div><div class="line">        listquota path</div><div class="line">        rmr path</div><div class="line">        get path [watch]</div><div class="line">        create [-s] [-e] path data acl</div><div class="line">        addauth scheme auth</div><div class="line">        quit</div><div class="line">        getAcl path</div><div class="line">        close</div><div class="line">        connect host:port</div><div class="line">[zk: 127.0.0.1:2181(CONNECTED) 1]</div></pre></td></tr></table></figure>
<h1 id="安装Hadoop"><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h1><p>在<a href="http://hadoop.apache.org/releases.html" target="_blank" rel="external">Hadoop官网</a>下载较新版本的Hadoop binary版本。作者使用的Hadoop 3.0.0。假设解压到用户目录<code>~/hadoop-3.0.0</code>。</p>
<p>进入Hadoop根目录后，首先需要配置JAVA_HOME:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ vim etc/hadoop/hadoop-env.sh</div><div class="line">...</div><div class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_111</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>查看Hadoop是否能正常运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜ hadoop version</div><div class="line">Hadoop 3.0.0</div><div class="line">Source code repository https://git-wip-us.apache.org/repos/asf/hadoop.git -r c25427ceca461ee979d30edd7a4b0f50718e6533</div><div class="line">Compiled by andrew on 2017-12-08T19:16Z</div><div class="line">Compiled with protoc 2.5.0</div><div class="line">From source with checksum 397832cb5529187dc8cd74ad54ff22</div><div class="line">This command was run using /home/lizh/hadoop-3.0.0/share/hadoop/common/hadoop-common-3.0.0.jar</div></pre></td></tr></table></figure></p>
<h2 id="添加Hadoop可执行文件路径到PATH"><a href="#添加Hadoop可执行文件路径到PATH" class="headerlink" title="添加Hadoop可执行文件路径到PATH"></a>添加Hadoop可执行文件路径到PATH</h2><p>在<code>~/.bashrc</code>中添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Hadoop</div><div class="line">export HADOOP_HOME=~/hadoop-3.0.0</div><div class="line">export HADOOP_MAPRED_HOME=$HADOOP_HOME</div><div class="line">export PATH=$PATH:$HADOOP_HOME/bin</div><div class="line">export PATH=$PATH:$HADOOP_HOME/sbin</div></pre></td></tr></table></figure></p>
<p>以便快捷使用Hadoop可执行程序<code>bin/*</code>与脚本<code>sbin/*</code>。</p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><h3 id="log4j-properties"><a href="#log4j-properties" class="headerlink" title="log4j.properties"></a>log4j.properties</h3><p>修改<code>etc/hadoop/log4j.properties</code>文件中的<code>hadoop.root.logger</code>可控制输出日志级别。</p>
<h3 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h3><p><code>etc/hadoop/core-site.xml</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;fs.defaultFS&lt;/name&gt;</div><div class="line">&lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;</div><div class="line">&lt;value&gt;localhost:2181,localhost:2182,localhost:2183&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<p><code>etc/hadoop/mapred-site.xml</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;mapreduce.framework.name&lt;/name&gt;</div><div class="line">&lt;value&gt;yarn&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt;</div><div class="line">&lt;value&gt;HADOOP_MAPRED_HOME=$HADOOP_MAPRED_HOME&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;mapreduce.map.env&lt;/name&gt;</div><div class="line">&lt;value&gt;HADOOP_MAPRED_HOME=$HADOOP_MAPRED_HOME&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;mapreduce.reduce.env&lt;/name&gt;</div><div class="line">&lt;value&gt;HADOOP_MAPRED_HOME=$HADOOP_MAPRED_HOME&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<p><code>etc/hadoop/hdfs-site.xml</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;dfs.replication&lt;/name&gt;</div><div class="line">&lt;value&gt;1&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;dfs.http.address&lt;/name&gt;</div><div class="line">&lt;value&gt;localhost:50070&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;dfs.namenode.datanode.registration.ip-hostname-check&lt;/name&gt;</div><div class="line">&lt;value&gt;true&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<p><code>etc/hadoop/yarn-site.xml</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.resourcemanager.zk-address&lt;/name&gt;</div><div class="line">&lt;value&gt;master:2181,slave1:2181,slave2:2181&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</div><div class="line">&lt;value&gt;mapreduce_shuffle&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<p><code>etc/hadoop/workers</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">localhost</div></pre></td></tr></table></figure></p>
<p>注意: 若workers中直接指定服务器IP，则需要将<code>hdfs-site.xml</code>中的<code>dfs.namenode.datanode.registration.ip-hostname-check</code>指定为<code>false</code>。</p>
<p>注意: 在全分布模式下，若需要在workers中使用主机名，参考之前的文章<a href="https://lizonghang.github.io/2018/01/09/Ubuntu设置静态IP与主机名/">Ubuntu设置静态IP与主机名</a>。</p>
<h2 id="开启SSH免密登录"><a href="#开启SSH免密登录" class="headerlink" title="开启SSH免密登录"></a>开启SSH免密登录</h2><p>注意: 若为全分布模式，每两对主机之间都需要配置SSH免密；若为伪分布模式，能够<code>ssh localhost</code>即可。</p>
<h3 id="OSX系统"><a href="#OSX系统" class="headerlink" title="OSX系统"></a>OSX系统</h3><p>默认安装有sshd，需要在”系统偏好设置—&gt;共享”中打开远程登录，并将本机<code>~/.ssh/id_rsa.pub</code>添加到<code>~/.ssh/authorized_keys</code>，确认<code>ssh localhost</code>能够免密登录。</p>
<h3 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h3><p>确认系统是否按照有sshd服务，若没有，需要安装openssh-server，开启sshd服务，并将本机<code>~/.ssh/id_rsa.pub</code>添加到<code>~/.ssh/authorized_keys</code>，确认<code>ssh localhost</code>能够免密登录。</p>
<h2 id="启动Hadoop伪分布集群"><a href="#启动Hadoop伪分布集群" class="headerlink" title="启动Hadoop伪分布集群"></a>启动Hadoop伪分布集群</h2><h3 id="格式化NameNode"><a href="#格式化NameNode" class="headerlink" title="格式化NameNode"></a>格式化NameNode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ hdfs namenode -format</div></pre></td></tr></table></figure>
<p>注意: 若曾多次格式化，可能出现版本冲突导致DataNode无法启动(版本遗留问题)，删除<code>/tmp/hadoop-lizh/dfs/name/current</code>后重新格式化并启动即可。</p>
<h3 id="启动DFS与YARN"><a href="#启动DFS与YARN" class="headerlink" title="启动DFS与YARN"></a>启动DFS与YARN</h3><h4 id="一次性启动"><a href="#一次性启动" class="headerlink" title="一次性启动"></a>一次性启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">➜ start-all.sh</div><div class="line">WARNING: Attempting to start all Apache Hadoop daemons as lizh in 10 seconds.</div><div class="line">WARNING: This is not a recommended production deployment configuration.</div><div class="line">WARNING: Use CTRL-C to abort.</div><div class="line">Starting namenodes on [localhost]</div><div class="line">Starting datanodes</div><div class="line">Starting secondary namenodes [Slave8]</div><div class="line">Starting resourcemanager</div><div class="line">Starting nodemanagers</div><div class="line">➜ jps</div><div class="line">30450 NameNode</div><div class="line">31381 ResourceManager</div><div class="line">27895 QuorumPeerMain</div><div class="line">31000 SecondaryNameNode</div><div class="line">27752 QuorumPeerMain</div><div class="line">30649 DataNode</div><div class="line">31757 NodeManager</div><div class="line">27821 QuorumPeerMain</div><div class="line">32109 Jps</div></pre></td></tr></table></figure>
<h4 id="分别启动"><a href="#分别启动" class="headerlink" title="分别启动"></a>分别启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">➜ start-dfs.sh</div><div class="line">Starting namenodes on [localhost]</div><div class="line">Starting datanodes</div><div class="line">Starting secondary namenodes [Slave8]</div><div class="line">➜ jps</div><div class="line">33760 DataNode</div><div class="line">34353 Jps</div><div class="line">27895 QuorumPeerMain</div><div class="line">33559 NameNode</div><div class="line">27752 QuorumPeerMain</div><div class="line">27821 QuorumPeerMain</div><div class="line">34109 SecondaryNameNode</div><div class="line">➜ start-yarn.sh</div><div class="line">Starting resourcemanager</div><div class="line">Starting nodemanagers</div><div class="line">➜ jps</div><div class="line">33760 DataNode</div><div class="line">35268 Jps</div><div class="line">27895 QuorumPeerMain</div><div class="line">33559 NameNode</div><div class="line">27752 QuorumPeerMain</div><div class="line">34552 ResourceManager</div><div class="line">27821 QuorumPeerMain</div><div class="line">34109 SecondaryNameNode</div><div class="line">34926 NodeManager</div></pre></td></tr></table></figure>
<h3 id="查看Hadoop集群是否正常启动"><a href="#查看Hadoop集群是否正常启动" class="headerlink" title="查看Hadoop集群是否正常启动"></a>查看Hadoop集群是否正常启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">➜ hdfs dfsadmin -report</div><div class="line">Configured Capacity: 226804576256 (211.23 GB)</div><div class="line">Present Capacity: 168025718784 (156.49 GB)</div><div class="line">DFS Remaining: 168025432064 (156.49 GB)</div><div class="line">DFS Used: 286720 (280 KB)</div><div class="line">DFS Used%: 0.00%</div><div class="line">Replicated Blocks:</div><div class="line">Under replicated blocks: 0</div><div class="line">Blocks with corrupt replicas: 0</div><div class="line">Missing blocks: 0</div><div class="line">Missing blocks (with replication factor 1): 0</div><div class="line">Pending deletion blocks: 0</div><div class="line">Erasure Coded Block Groups:</div><div class="line">Low redundancy block groups: 0</div><div class="line">Block groups with corrupt internal blocks: 0</div><div class="line">Missing block groups: 0</div><div class="line">Pending deletion blocks: 0</div><div class="line"></div><div class="line">-------------------------------------------------</div><div class="line">Live datanodes (1):</div><div class="line"></div><div class="line">Name: 127.0.0.1:9866 (localhost)</div><div class="line">Hostname: Slave8</div><div class="line">Decommission Status : Normal</div><div class="line">Configured Capacity: 226804576256 (211.23 GB)</div><div class="line">DFS Used: 286720 (280 KB)</div><div class="line">Non DFS Used: 47234248704 (43.99 GB)</div><div class="line">DFS Remaining: 168025432064 (156.49 GB)</div><div class="line">DFS Used%: 0.00%</div><div class="line">DFS Remaining%: 74.08%</div><div class="line">Configured Cache Capacity: 0 (0 B)</div><div class="line">Cache Used: 0 (0 B)</div><div class="line">Cache Remaining: 0 (0 B)</div><div class="line">Cache Used%: 100.00%</div><div class="line">Cache Remaining%: 0.00%</div><div class="line">Xceivers: 1</div><div class="line">Last contact: Tue Jan 09 19:36:16 CST 2018</div><div class="line">Last Block Report: Tue Jan 09 19:31:49 CST 2018</div></pre></td></tr></table></figure>
<h3 id="查看Web端口是否开启服务"><a href="#查看Web端口是否开启服务" class="headerlink" title="查看Web端口是否开启服务"></a>查看Web端口是否开启服务</h3><ul>
<li>50070端口查看HDFS信息。</li>
<li>8088端口查看ResourceManager信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜ netstat -tpnl | grep 50070</div><div class="line">(Not all processes could be identified, non-owned process info</div><div class="line">will not be shown, you would have to be root to see it all.)</div><div class="line">tcp        0      0 127.0.0.1:50070         0.0.0.0:*               LISTEN      33559/java</div><div class="line">➜ netstat -tpnl | grep 8088</div><div class="line">(Not all processes could be identified, non-owned process info</div><div class="line">will not be shown, you would have to be root to see it all.)</div><div class="line">tcp        0      0 0.0.0.0:8088            0.0.0.0:*               LISTEN      34552/java</div></pre></td></tr></table></figure>
<p>浏览器访问<code><a href="http://localhost:50070" target="_blank" rel="external">http://localhost:50070</a></code>和<code><a href="http://localhost:8088" target="_blank" rel="external">http://localhost:8088</a></code>可进入Web页面。</p>
<p>注意: 全分布模式下50070端口需要由<code><a href="http://master:50070" target="_blank" rel="external">http://master:50070</a></code>访问，8088端口需要在开启了ResourceManager的主机(即DataNode)<code><a href="http://slave:8088" target="_blank" rel="external">http://slave:8088</a></code>访问。</p>
<p>注意: 若使用YARN作为资源管理器，但没有开启ZooKeeper，可能会导致8088端口无法访问。</p>
<h2 id="关闭Hadoop集群"><a href="#关闭Hadoop集群" class="headerlink" title="关闭Hadoop集群"></a>关闭Hadoop集群</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜ stop-all.sh</div><div class="line">WARNING: Stopping all Apache Hadoop daemons as lizh in 10 seconds.</div><div class="line">WARNING: Use CTRL-C to abort.</div><div class="line">Stopping namenodes on [localhost]</div><div class="line">Stopping datanodes</div><div class="line">Stopping secondary namenodes [Slave8]</div><div class="line">Stopping nodemanagers</div><div class="line">Stopping resourcemanager</div><div class="line">➜ jps</div><div class="line">27895 QuorumPeerMain</div><div class="line">27752 QuorumPeerMain</div><div class="line">36745 Jps</div><div class="line">27821 QuorumPeerMain</div></pre></td></tr></table></figure>
<h1 id="HDFS文件操作指令与MapReduce测试"><a href="#HDFS文件操作指令与MapReduce测试" class="headerlink" title="HDFS文件操作指令与MapReduce测试"></a>HDFS文件操作指令与MapReduce测试</h1><h2 id="HDFS文件操作指令"><a href="#HDFS文件操作指令" class="headerlink" title="HDFS文件操作指令"></a>HDFS文件操作指令</h2><p>文件指令格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop fs &lt;args&gt;</div></pre></td></tr></table></figure></p>
<p>详细指令可参考<a href="http://hadoop.apache.org/docs/r3.0.0/hadoop-project-dist/hadoop-common/FileSystemShell.html" target="_blank" rel="external">Hadoop 3.0.0官方文档</a></p>
<p>可通过<code>hadoop fs -help ls</code>查看指令描述:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">➜ hadoop fs -help ls</div><div class="line">-ls [-C] [-d] [-h] [-q] [-R] [-t] [-S] [-r] [-u] [-e] [&lt;path&gt; ...] :</div><div class="line">List the contents that match the specified file pattern. If path is not</div><div class="line">specified, the contents of /user/&lt;currentUser&gt; will be listed. For a directory a</div><div class="line">list of its direct children is returned (unless -d option is specified).</div><div class="line"></div><div class="line">Directory entries are of the form:</div><div class="line">permissions - userId groupId sizeOfDirectory(in bytes)</div><div class="line">modificationDate(yyyy-MM-dd HH:mm) directoryName</div><div class="line"></div><div class="line">and file entries are of the form:</div><div class="line">permissions numberOfReplicas userId groupId sizeOfFile(in bytes)</div><div class="line">modificationDate(yyyy-MM-dd HH:mm) fileName</div><div class="line"></div><div class="line">-C  Display the paths of files and directories only.</div><div class="line">-d  Directories are listed as plain files.</div><div class="line">-h  Formats the sizes of files in a human-readable fashion</div><div class="line">rather than a number of bytes.</div><div class="line">-q  Print ? instead of non-printable characters.</div><div class="line">-R  Recursively list the contents of directories.</div><div class="line">-t  Sort files by modification time (most recent first).</div><div class="line">-S  Sort files by size.</div><div class="line">-r  Reverse the order of the sort.</div><div class="line">-u  Use time of last access instead of modification for</div><div class="line">display and sorting.</div><div class="line">-e  Display the erasure coding policy of files and directories.</div></pre></td></tr></table></figure></p>
<p>例如使用<code>hadoop fs -ls -R /</code>可递归显示根目录下所有文件。</p>
<h2 id="MapReduce测试"><a href="#MapReduce测试" class="headerlink" title="MapReduce测试"></a>MapReduce测试</h2><ol>
<li><p>在Hadoop文件系统中创建用户文件夹，注意user为当前登录用户名，此处作者的用户名为lizh。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ hadoop fs -ls /</div><div class="line">➜ hadoop fs -mkdir -p /user/lizh</div><div class="line">➜ hadoop fs -ls -R /</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-09 20:02 /user</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-09 20:02 /user/lizh</div></pre></td></tr></table></figure>
</li>
<li><p>上传本地文本文件到HDFS(可以将hadoop-3.0.0/NOTICE.txt作为测试文本)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ hadoop fs -put hadoop-3.0.0/NOTICE.txt .</div><div class="line">➜ hadoop fs -ls</div><div class="line">Found 1 items</div><div class="line">-rw-r--r--   1 lizh supergroup      20891 2018-01-09 20:05 NOTICE.txt</div></pre></td></tr></table></figure>
</li>
</ol>
<p><code>-put hadoop-3.0.0/NOTICE.txt .</code>表示将本地NOTICE.txt文件上传到HDFS的用户主目录<code>/user/lizh</code>下，以<code>.</code>表示。当<code>-ls</code>不带路径时，默认为用户主目录。这就是必须创建路径<code>/user/username</code>而不是随意新建的原因。</p>
<ol>
<li>使用Hadoop自带测试程序wordcount来测试集群是否能够正常工作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">➜ hadoop jar hadoop-3.0.0/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.0.0.jar wordcount ./NOTICE.txt ./out/</div><div class="line">...</div><div class="line">➜ hadoop fs -ls</div><div class="line">Found 2 items</div><div class="line">-rw-r--r--   1 lizh supergroup      20891 2018-01-09 20:05 NOTICE.txt</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-09 20:09 out</div><div class="line">➜ hadoop fs -ls out</div><div class="line">Found 2 items</div><div class="line">-rw-r--r--   1 lizh supergroup          0 2018-01-09 20:09 out/_SUCCESS</div><div class="line">-rw-r--r--   1 lizh supergroup      11905 2018-01-09 20:09 out/part-r-00000</div></pre></td></tr></table></figure>
</li>
</ol>
<p>程序将输出结果输出到了<code>/user/lizh/out<code>文件夹，也表明集群是正常工作的。可通过<code>hadoop fs -cat ./out/part-r-00000</code>查看输出结果:</code></code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">➜  ~ hadoop fs -cat ./out/part-r-00000</div><div class="line">&quot;AS    1</div><div class="line">&quot;GCC    1</div><div class="line">&quot;Java    1</div><div class="line">&quot;License&quot;);    1</div><div class="line">#    6</div><div class="line">&amp;    1</div><div class="line">&apos;Aalto    1</div><div class="line">&apos;Apache    4</div><div class="line">&apos;ArrayDeque&apos;,    1</div><div class="line">&apos;Bouncy    1</div><div class="line">...</div></pre></td></tr></table></figure>
<p>注意: 该步骤对于DataNode内存要求较高，虚拟机难以满足其内存需求，因此建议在单机上运行伪分布模式来测试。</p>
<p>至此，一个简易的Hadoop伪分布集群(1个NameNode，1个DataNode)就部署完成了。通过伪分布式仅是用于调试与测试，后续文章中将会讲到全分布模式的部署以及在全分布模式下如何动态增加DataNode到集群等。</p>
]]></content>
      
        <categories>
            
            <category> Hadoop/Spark </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[保持SSH长期连接]]></title>
      <url>http://lizonghang.github.io/2018/01/09/%E4%BF%9D%E6%8C%81SSH%E9%95%BF%E6%9C%9F%E8%BF%9E%E6%8E%A5/</url>
      <content type="html"><![CDATA[<p>为避免长时间无数据传输导致网络中间节点断开SSH连接的问题，在SSH服务端或客户端开启心跳报文。</p>
<ol>
<li>在客户端<code>/etc/ssh/ssh_config</code>添加<code>ServerAliveInterval 60</code>。</li>
<li>在服务端<code>/etc/ssh/sshd_config</code>添加<code>ClientAliveInterval 60</code>后重启SSH服务。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 服务器/后台 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu设置静态IP与主机名]]></title>
      <url>http://lizonghang.github.io/2018/01/09/Ubuntu%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%90%8D/</url>
      <content type="html"><![CDATA[<h1 id="设置静态IP与DNS服务器"><a href="#设置静态IP与DNS服务器" class="headerlink" title="设置静态IP与DNS服务器"></a>设置静态IP与DNS服务器</h1><p>假设子网为10.211.55.0。</p>
<p>编辑<code>/etc/network/interfaces</code>文件，添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">auto eth1</div><div class="line">iface eth1 inet static</div><div class="line">address 10.211.55.3</div><div class="line">netmask 255.255.255.0</div><div class="line">network 10.211.55.0</div><div class="line">broadcast 10.211.55.255</div><div class="line">gateway 10.211.55.1</div></pre></td></tr></table></figure>
<p>为了使主机能够上外网，确认是否指定了DNS服务器，编辑<code>/etc/resolvconf/resolv.conf.d/base</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nameserver 8.8.8.8</div></pre></td></tr></table></figure>
<p>编辑完成后，重新读取配置文件并重启网络：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo resolvconf -u</div><div class="line">sudo /etc/init.d/networking restart</div></pre></td></tr></table></figure>
<h1 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h1><p>使用命令<code>hostname</code>可查看当前主机名，编辑文件<code>/etc/hostname</code>后重启主机可修改主机名。假设有两台主机名为master和slave的主机，在修改域名映射关系后可在master上直接通过主机名访问slave提供的服务，如浏览器直接输入<code><a href="http://slave:8088" target="_blank" rel="external">http://slave:8088</a></code>。</p>
<p>假设IP-A(master)=10.211.55.3，IP-B(slave)=10.211.55.4，在A和B的<code>/etc/hosts</code>文件里都添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">10.211.55.3 master</div><div class="line">10.211.55.4 slave</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 服务器/后台 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[AliCloud-Ubuntu-Server-With-IPv6]]></title>
      <url>http://lizonghang.github.io/2016/12/09/AliCloud-Ubuntu-Server-With-IPv6/</url>
      <content type="html"><![CDATA[<h1 id="Ubuntu支持IPv6"><a href="#Ubuntu支持IPv6" class="headerlink" title="Ubuntu支持IPv6"></a>Ubuntu支持IPv6</h1><p>阿里云服务器默认是不支持IPv6协议的，需要修改<code>/etc/sysctl.conf</code>文件解除对IPv6的禁止:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">net.ipv6.conf.all.disable_ipv6 = 0</div><div class="line">net.ipv6.conf.default.disable_ipv6 = 0</div><div class="line">net.ipv6.conf.lo.disable_ipv6 = 0</div></pre></td></tr></table></figure>
<p>修改完成后，启用新的配置，为服务器分配公网IPv6地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># sysctl -p</div></pre></td></tr></table></figure>
<p>使用命令<code>ifconfig</code>应该可以在公网IPv4对应的网卡中找到对应的IPv6地址，若没有重启服务器。</p>
<h1 id="nginx支持并监听IPv6的80端口"><a href="#nginx支持并监听IPv6的80端口" class="headerlink" title="nginx支持并监听IPv6的80端口"></a>nginx支持并监听IPv6的80端口</h1><p>首先查看当前的nginx是否支持IPv6协议，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nginx -V</div></pre></td></tr></table></figure>
<p>若输出的<code>configure arguments</code>中含有<code>—-with-ipv6</code>，则当前nginx支持IPv6协议，否则需要重新编译安装nginx，编译nginx时需要加上<code>—-with-ipv6</code>。</p>
<p>确认当前nginx支持ipv6后，修改<code>nginx.conf</code>中的server段，除了监听IPv4的80端口外还需要监听IPv6的80端口,若有需要还需要监听HTTPS协议的IPv6的443端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 80; // 监听IPv4的80端口,HTTP协议</div><div class="line">    listen [::]:80; // 监听IPv6的80端口,HTTP协议</div><div class="line">    ……</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen 443; // 监听IPv4的443端口,HTTPS协议</div><div class="line">    listen [::]:443; // 监听IPv6的443端口,HTTPS协议</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="申请IPv6中转隧道"><a href="#申请IPv6中转隧道" class="headerlink" title="申请IPv6中转隧道"></a>申请IPv6中转隧道</h1><p>由于国内阿里云不提供IPv6服务，实现IPv6需要申请中转服务，可以使用<a href="https://tunnelbroker.net" target="_blank" rel="external">tunnelbroker.net</a>提供的中转服务。</p>
<ol>
<li>在tunnelbroker.net注册一个账号</li>
<li>登录后进入左侧导航栏中的<code>Create Regular Tunnel</code>，在<code>IPv4 Endpoint</code>输入你的服务器的外网IPv4地址，选择<code>Hong Kong,HK</code>隧道服务器，创建一个新的ipv6隧道</li>
<li>创建好隧道后跳转到了Tunnel Details页，IPv6 Tunnel页是隧道的基本信息，你需要验证的是<code>Client IPv4 Address</code>是否为你的服务器外网IPv4地址，需要记录<code>Client IPv6 Address</code>对应的中转IPv6地址。</li>
<li>转到Example Configurations页，选择服务器操作系统类型，比如我的服务器使用的是Ubuntu，所以选择<code>Debian/Ubuntu</code>。按要求复制文本框中的内容并粘贴到服务器上对应的文件内。例如：</li>
</ol>
<p>Paste the following into /etc/network/interfaces:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">auto he-ipv6</div><div class="line">iface he-ipv6 inet6 v4tunnel</div><div class="line">        address 2001:470:18:8cb::2</div><div class="line">        netmask 64</div><div class="line">        endpoint 216.218.221.6</div><div class="line">        local 114.215.121.63</div><div class="line">        ttl 255</div><div class="line">        gateway 2001:470:18:8cb::1</div></pre></td></tr></table></figure>
<p>我们就需要将以上he-ipv6的网卡信息写入网卡配置文件<code>/etc/network/interfaces</code>中，保存后使用以下命令启动网卡:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/networking restart</div></pre></td></tr></table></figure>
<p>重启服务器后使用命令<code>ifconfig</code>应当可以看到新增了的he-ipv6网卡。</p>
<h1 id="检查防火墙规则"><a href="#检查防火墙规则" class="headerlink" title="检查防火墙规则"></a>检查防火墙规则</h1><p>要确保防火墙没有丢弃IPv6报文的规则，若服务器没有防火墙的相关需求，可简单的通过下述方式检查防火墙规则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root@iZ28zgwg61iZ:~# iptables -nL</div><div class="line">Chain INPUT (policy ACCEPT)</div><div class="line">target     prot opt source               destination</div><div class="line"></div><div class="line">Chain FORWARD (policy ACCEPT)</div><div class="line">target     prot opt source               destination</div><div class="line"></div><div class="line">Chain OUTPUT (policy ACCEPT)</div><div class="line">target     prot opt source               destination</div></pre></td></tr></table></figure>
<p>这是一个没有设置任何规则的防火墙，对于接收、发出、转发的报文的默认策略都是ACCEPT，在这种环境下IPv6报文不受影响。</p>
<p>若需要设置一些过滤规则最好将INPUT、OUTPUT链的默认策略设置为ACCEPT，保证IPv6报文能正常收发或作一些合理的过滤，参阅相关书籍谨慎设置，不熟悉iptables的话建议先熟悉了再到VPS上设置，或者简单的将所有规则清除并设置默认策略为ACCEPT，否则很可能将自己与服务器之间的连接断开，那就只有联系机房管理员清除了。</p>
<h1 id="添加AAAA域名解析"><a href="#添加AAAA域名解析" class="headerlink" title="添加AAAA域名解析"></a>添加AAAA域名解析</h1><p>进入阿里云的管理控制台，进入云解析DNS，选择相应的域名，添加一条AAAA解析，记录值填写之前记录的<code>Client IPv6 Address</code>中记录的IPv6地址。保存后等待几分钟，等DNS服务器刷新记录。</p>
<p>注意：AAAA解析的记录值填用于中转的IPv6地址，即网卡he-ipv6中的<code>Scope:Global</code>对应的IPv6地址，而不是由第一步生成的服务器本身的外网IPv6地址。</p>
<h1 id="验证IPv6网络是否有效"><a href="#验证IPv6网络是否有效" class="headerlink" title="验证IPv6网络是否有效"></a>验证IPv6网络是否有效</h1><p>在<a href="http://ipv6-test.com/validate.php" target="_blank" rel="external">ipv6-test</a>网站中输入域名验证，若<code>AAAA DNS record</code>和<code>IPv6 web server</code>都验证通过就可以判断IPv6网络是有效的，也可以使用国外的服务器使用命令<code>ping6</code>或命令<code>curl -6</code>查看是否有返回数据。</p>
<p>注意：不建议使用国内网络测试服务器IPv6环境是否有效，因为国内大多数服务器不支持IPv6，测试者所在的网络也不一定支持IPv6网络，因此建议使用国外服务器进行测试。</p>
]]></content>
      
        <categories>
            
            <category> 服务器/后台 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[CORS跨站请求与https服务器配置]]></title>
      <url>http://lizonghang.github.io/2016/09/27/CORS%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%B8%8Ehttps%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="CORS跨站资源共享"><a href="#CORS跨站资源共享" class="headerlink" title="CORS跨站资源共享"></a>CORS跨站资源共享</h1><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>很多习惯了自己做网站的后台开发者在初次与前端或移动端合作开发时，常常遇到这么一个问题: 后台所开发出的 API 都是经过 Postman 或其他接口测试工具测试过，确认提供的这些 API 并没有异常后，将这些 API 整理成文档发给前端，但是前端的小伙伴并不能成功访问到这些接口，而是会报错: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">XMLHttpRequest cannot load http://www.desckie.com/iwantrent/getAllProduct</div><div class="line">/. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested re</div><div class="line">source. Origin &apos;http://www.puahome.com&apos; is therefore not allowed access.</div></pre></td></tr></table></figure>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这是由于浏览器安全的基石是”同源政策”，同源指是协议相同、域名相同、端口相同。同源政策的目的是为了保证用户信息的安全，防止恶意网站窃取数据。因此现在我们用 JS 或 AJAX 进行跨站请求时，由于浏览器的同源原则，使得 <code>XMLHttpRequest</code> 不能跨域通讯。</p>
<p>为了实现跨域有多种做法，其中一种较为优雅的是使用 <code>JSONP</code> 方案，但 <code>JSONP</code> 仅限于 <code>GET</code> 方法，局限性较大。</p>
<p>报错信息中有这么一句话: <code>No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</code>。请求的资源中没有 <code>‘Access-Control-Allow-Origin’</code> 请求头，它指定服务器端允许进行跨域资源访问的来源域，允许任何域的 Javascript 访问资源的方式为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Accesss-Control-Allow-Origin: *</div></pre></td></tr></table></figure>
<p>或指定具体的域可访问，如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://foo.example.com</div></pre></td></tr></table></figure>
<p>如此一来，除了 foo.example.com ，其他站点都不能跨站访问本站的资源。那么如何添加请求头呢？</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="直接处理请求头"><a href="#直接处理请求头" class="headerlink" title="直接处理请求头"></a>直接处理请求头</h3><p>在 Django 后台中我们可以通过简单的方式添加请求头，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">response[&apos;Access-Control-Allow-Origin&apos;] = &apos;*&apos;</div><div class="line">return response</div></pre></td></tr></table></figure>
<p>这也是实现跨站登录最基本的实现，但不推荐这种跨站访问方式。</p>
<h3 id="CORS跨站资源共享-1"><a href="#CORS跨站资源共享-1" class="headerlink" title="CORS跨站资源共享"></a>CORS跨站资源共享</h3><p>在 Django 中有CORS-header开源的中间件，利用这些现成的中间件，我们只需要在 settings.py 中做一些简单的配置即可实现 CORS 跨站资源共享，使得服务器端 API 完全开放，使得前后台能够较为独立的工作。</p>
<p>django-cors-headers开源项目地址为: <a href="https://github.com/ottoyiu/django-cors-headers/" target="_blank" rel="external">https://github.com/ottoyiu/django-cors-headers/</a></p>
<p>使用方法如下:</p>
<ol>
<li>安装django-cors-headers</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install django-cors-headers</div></pre></td></tr></table></figure>
<ol>
<li>将 corsheaders 加入 installed apps:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">INSTALLED_APPS = (</div><div class="line">    ...</div><div class="line">    &apos;corsheaders&apos;,</div><div class="line">    ...</div><div class="line">)</div></pre></td></tr></table></figure>
<ol>
<li>添加中间件类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">MIDDLEWARE_CLASSES = (</div><div class="line">    ...</div><div class="line">    &apos;corsheaders.middleware.CorsMiddleware&apos;,</div><div class="line">    &apos;django.middleware.common.CommonMiddleware&apos;,</div><div class="line">    ...</div><div class="line">)</div></pre></td></tr></table></figure>
<p><strong>Note</strong>: CorsMiddleware needs to come before Django’s CommonMiddleware if you are using Django’s <code>USE_ETAGS = True</code> setting, otherwise the CORS headers will be lost from the 304 not-modified responses, causing errors in some browsers.</p>
<ol>
<li>添加配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CORS_ORIGIN_ALLOW_ALL = True</div><div class="line">CORS_URLS_REGEX = r&apos;^/api/.*$&apos;</div><div class="line">CORS_ALLOW_METHODS = (&apos;GET&apos;, &apos;POST&apos;, &apos;PUT&apos;, &apos;DELETE&apos;, &apos;HEAD&apos;, &apos;PATCH&apos;, &apos;OPTIONS&apos;)</div></pre></td></tr></table></figure>
<p>生产环境中推荐使用白名单，此处为测试才设为全域。按照需要可以设置其他配置，具体设置见 <a href="https://github.com/ottoyiu/django-cors-headers/#configuration。" target="_blank" rel="external">https://github.com/ottoyiu/django-cors-headers/#configuration。</a></p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>重新用 JS 或 AJAX 跨站访问，没有出现 No ‘Access-Control-Allow-Origin’ header 报错。</p>
<h1 id="HTTPS-Nginx服务器部署"><a href="#HTTPS-Nginx服务器部署" class="headerlink" title="HTTPS Nginx服务器部署"></a>HTTPS Nginx服务器部署</h1><h2 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h2><p>跨站访问的问题解决了，再次测试又出现了新的错误，错误信息如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[blocked] The page at https://www.baidu.com/… was not allowed to display insecure content from http://www.desckie.com/iwantrent/getAllProduct/.</div></pre></td></tr></table></figure>
<h2 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h2><p>从报错信息上我们可以判断出，请求的网页被作为不安全的网页给浏览器阻塞了，原因就出在使用的协议为 http 协议。http 协议传输的数据在网络上为明文传输，容易被中间人窃取导致用户信息泄露，因此 http 协议实际上是不安全的。https 协议是 http 的安全版，即 http 下加入 SSL 层。要解决这个问题我们需要将协议更改为 https 协议。以 Nginx 服务器为例。</p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="申请-SSL-证书"><a href="#申请-SSL-证书" class="headerlink" title="申请 SSL 证书"></a>申请 SSL 证书</h3><p>这里我们使用自行颁发的免费 SSL 证书，它虽然能实现加密传输功能，但这类证书是不受浏览器信任的。用户在进入该网站时可能会出现提示: 此网站的安全证书有问题。但向专业机构申请 SSL 证书不仅需要出示相关证件，而且还要付费，所以我们这里就使用自行颁发的 SSL 证书。</p>
<ol>
<li>openssl genrsa -des3 -out api.bz.key 1024</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-96-46-ubuntu:~$ openssl genrsa -des3 -out api.bz.key 1024</div><div class="line">Generating RSA private key, 1024 bit long modulus</div><div class="line">............................++++++</div><div class="line">..............++++++</div><div class="line">e is 65537 (0x10001)</div><div class="line">Enter pass phrase for api.bz.key:</div><div class="line">Verifying - Enter pass phrase for api.bz.key:输入密码</div></pre></td></tr></table></figure>
<ol>
<li>openssl req -new -key api.bz.key -out api.bz.csr</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-96-46-ubuntu:~$ openssl req -new -key api.bz.key -out api.bz.csr</div><div class="line">Enter pass phrase for api.bz.key: 刚刚设置的密码</div><div class="line">You are about to be asked to enter information that will be incorporated</div><div class="line">into your certificate request.</div><div class="line">What you are about to enter is what is called a Distinguished Name or a DN.</div><div class="line">There are quite a few fields but you can leave some blank</div><div class="line">For some fields there will be a default value,</div><div class="line">If you enter &apos;.&apos;, the field will be left blank.</div><div class="line">-----</div><div class="line">Country Name (2 letter code) [AU]:CN</div><div class="line">State or Province Name (full name) [Some-State]:Beijing</div><div class="line">Locality Name (eg, city) []:Beijing</div><div class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:API.BZ</div><div class="line">Organizational Unit Name (eg, section) []:API.BZ</div><div class="line">Common Name (e.g. server FQDN or YOUR name) []:*.api.bz</div><div class="line">Email Address []:admin@api.bz</div><div class="line"></div><div class="line">Please enter the following &apos;extra&apos; attributes</div><div class="line">to be sent with your certificate request</div><div class="line">A challenge password []: 回车</div><div class="line">An optional company name []: 回车</div></pre></td></tr></table></figure>
<ol>
<li>openssl rsa -in api.bz.key -out api.bz_nopass.key</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-96-46-ubuntu:~$ openssl rsa -in api.bz.key -out api.bz_nopass.key</div><div class="line">Enter pass phrase for api.bz.key:</div><div class="line">writing RSA key</div></pre></td></tr></table></figure>
<ol>
<li>openssl req -new -x509 -days 3650 -key api.bz_nopass.key -out api.bz.crt</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-96-46-ubuntu:~$ openssl req -new -x509 -days 3650 -key api.bz_nopass.key -out api.bz.crt</div><div class="line">You are about to be asked to enter information that will be incorporated</div><div class="line">into your certificate request.</div><div class="line">What you are about to enter is what is called a Distinguished Name or a DN.</div><div class="line">There are quite a few fields but you can leave some blank</div><div class="line">For some fields there will be a default value,</div><div class="line">If you enter &apos;.&apos;, the field will be left blank.</div><div class="line">-----</div><div class="line">Country Name (2 letter code) [AU]:CN</div><div class="line">State or Province Name (full name) [Some-State]:Beijing</div><div class="line">Locality Name (eg, city) []:Beijing</div><div class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:API.BZ</div><div class="line">Organizational Unit Name (eg, section) []:API.BZ</div><div class="line">Common Name (e.g. server FQDN or YOUR name) []:*.api.bz</div><div class="line">Email Address []:admin@api.bz</div></pre></td></tr></table></figure>
<p>到这里 SSL 证书就申请好了，此时应该有四个文件，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-96-46-ubuntu:~$ ls</div><div class="line">api.bz.crt  api.bz.csr  api.bz.key  api.bz_nopass.key ...</div></pre></td></tr></table></figure>
<p>我们要用的是 <code>api.bz.crt</code> 和 <code>api.bz_nopass.key</code> 两个文件。</p>
<h3 id="更改-Nginx-配置"><a href="#更改-Nginx-配置" class="headerlink" title="更改 Nginx 配置"></a>更改 Nginx 配置</h3><p>在配置文件 nginx.conf 中的 server 字段中有这么一段被注释的 HTTPS 配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># HTTPS server</div><div class="line">#</div><div class="line"># server &#123;</div><div class="line">#   listen 443;</div><div class="line">#   server_name localhost;</div><div class="line">#</div><div class="line">#   root html;</div><div class="line">#   index index.html index.htm;</div><div class="line">#</div><div class="line">#   ssl on;</div><div class="line">#   ssl_certificate cert.pem;</div><div class="line">#   ssl_certificate_key cert.key;</div><div class="line">#</div><div class="line">#   ssl_session_timeout 5m;</div><div class="line">#</div><div class="line">#   ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">#   ssl_ciphers &quot;HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES&quot;;</div><div class="line">#   ssl_prefer_server_ciphers on;</div><div class="line">#</div><div class="line">#   location / &#123;</div><div class="line">#       try_files $uri $uri/ =404;</div><div class="line">#   &#125;</div><div class="line">#&#125;</div></pre></td></tr></table></figure>
<p>我们不需要使用其中所有的配置，根据 SSL 证书的路径修改相应的配置项(省去了注释项):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">        listen 443;</div><div class="line">        server_name sms.api.bz;</div><div class="line"></div><div class="line">        ssl on;</div><div class="line">        ssl_certificate /root/api.bz.crt;</div><div class="line">        ssl_certificate_key /root/api.bz_nopass.key;</div><div class="line">        </div><div class="line">        location / &#123;</div><div class="line">                include /etc/nginx/uwsgi_params;</div><div class="line">                uwsgi_pass 127.0.0.1:8077;</div><div class="line">                include /etc/nginx/mime.types;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        location ~* \.*(gif|png|jpg|jpeg|css|js|ttf|less)$ &#123;</div><div class="line">                root /root/RentMe;</div><div class="line">                access_log /root/nginx_access.log;</div><div class="line">                error_log /root/nginx_error.log;</div><div class="line">                include /etc/nginx/mime.types;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 location 可以从 HTTP 的配置项中复制过来。修改完成后，验证配置文件有效性并重启 nginx 服务器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@iZ28zgwg61iZ:~# /usr/sbin/nginx -t</div><div class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</div><div class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</div><div class="line">root@iZ28zgwg61iZ:~# /usr/sbin/nginx -s reload</div></pre></td></tr></table></figure>
<p>随后使用 https 方式进入你的网站，会先提示网站的安全证书有问题，无需理会。到这里网站就从 http 协议更换成 https 协议了，之后就可以用 https 方式更安全的访问网站。</p>
<h2 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h2><p>下图是从 leancloud.cn 通过 js 跨站访问的截图，没有出现跨站访问错误和安全警告，如图:</p>
<p><img src="/images/https.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 服务器/后台 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Getting Started With Videos]]></title>
      <url>http://lizonghang.github.io/2016/08/16/Getting-Started-With-Videos/</url>
      <content type="html"><![CDATA[<h1 id="Capture-Video-from-Camera"><a href="#Capture-Video-from-Camera" class="headerlink" title="Capture Video from Camera"></a>Capture Video from Camera</h1><p>To capture a video, you need to create a VideoCapture object. Its argument can be either the device index or the name of a video file. Device index is just the number to specify which camera. Normally one camera will be connected (as in my case). So I simply pass 0 (or -1). You can select the second camera by passing 1 and so on. After that, you can capture frame-by-frame. But at the end, don’t forget to release the capture. You can press ESC to quit.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">cap = cv2.VideoCapture(0)</div><div class="line">while True:</div><div class="line">    ret, frame = cap.read()</div><div class="line">    cv2.imshow(&apos;recording&apos;, frame)</div><div class="line">    if cv2.waitKey(25) == 27:</div><div class="line">        break</div><div class="line">cap.release()</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p><code>cap.read()</code> returns a bool (True/False). If frame is read correctly, it will be True. So you can check end of the video by checking this return value.</p>
<p>Sometimes, <code>cap</code> may not have initialized the capture. In that case, this code shows error. You can check whether it is initialized or not by the method <code>cap.isOpened()</code>. Otherwise open it using <code>cap.open()</code>.</p>
<p>You can also access some of the features of this video using <code>cap.get(propId)</code> method where propId is a number from 0 to 18. Each number denotes a property of the video (if it is applicable to that video) and full details can be seen in  <a href="http://docs.opencv.org/2.4/modules/highgui/doc/reading_and_writing_images_and_video.html#videocapture-get" target="_blank" rel="external">Property Identifier</a>. Some of these values can be modified using <code>cap.set(propId, value)</code>. Value is the new value you want.</p>
<p>For example, I can check the frame width and height by <code>cap.get(3)</code> and <code>cap.get(4)</code>. It gives me 640x480 by default. But I want to modify it to 320x240. Just use <code>ret = cap.set(3,320)</code> and <code>ret = cap.set(4,240)</code>.</p>
<p><strong>Note</strong>：If you are getting error, make sure camera is working fine using any other camera application (like Cheese in Linux).</p>
<h1 id="Playing-Video-from-file"><a href="#Playing-Video-from-file" class="headerlink" title="Playing Video from file"></a>Playing Video from file</h1><p>It is same as capturing from Camera, just change camera index with video file name. Also while displaying the frame, use appropriate time for cv2.waitKey(). If it is too less, video will be very fast and if it is too high, video will be slow (Well, that is how you can display videos in slow motion). 25 milliseconds will be OK in normal cases.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">cap = cv2.VideoCapture(&apos;video.mp4&apos;)</div><div class="line">while cap.isOpened():</div><div class="line">    ret, frame = cap.read()</div><div class="line">    cv2.imshow(&apos;playing&apos;, frame)</div><div class="line">    if cv2.waitKey(25) == 27:</div><div class="line">        break</div><div class="line">cap.release()</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p><strong>Note</strong>：Make sure proper versions of ffmpeg or gstreamer is installed. Sometimes, it is a headache to work with Video Capture mostly due to wrong installation of ffmpeg/gstreamer.</p>
<p><strong>Note</strong>：On Mac, you may get trouble while reading frame from a video file or writing frame to file, With no exception occurred but no data read out or write in. I have installed ffmpeg by homebrew, however not work for me. The OpenCV version on my Mac is 2.4.13. I have no idea about it. However, I tried it on Linux and it works without ffmpeg. The OpenCV version on Linux is 2.4.8. If you get the same trouble, maybe you can try uninstall OpenCV and install OpenCV3.x or OpenCV 2.4.8, it may works.</p>
<h1 id="Saving-a-Video"><a href="#Saving-a-Video" class="headerlink" title="Saving a Video"></a>Saving a Video</h1><p>Create a <code>VideoWriter</code> object and specify the output filename. Then specify the FourCC code. Then number of frames per second (fps) and frame size should be passed. And last one is isColor flag. If it is True, encoder expect color frame, otherwise it works with grayscale frame.</p>
<p>FourCC is a 4-byte code used to specify the video codec. The list of available codes can be found in <a href="http://www.fourcc.org/codecs.php" target="_blank" rel="external">fourcc.org</a>. It is platform dependent. </p>
<p>FourCC code is passed as below：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># for OpenCV 2.4.x version</div><div class="line">cv2.cv.CV_FOURCC(&apos;M&apos;,&apos;J&apos;,&apos;P&apos;,&apos;G&apos;)</div><div class="line">cv2.cv.CV_FOURCC(*&apos;M‌​JPG&apos;)</div><div class="line"># for OpenCV 3.0 version</div><div class="line">cv2.VideoWriter_fourcc(&apos;M&apos;,&apos;J&apos;,&apos;P&apos;,&apos;G&apos;)</div><div class="line">cv2.VideoWriter_fourcc(*&apos;MJPG&apos;)</div></pre></td></tr></table></figure>
<p>Below code capture from video file and saves part of it.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import sys</div><div class="line"></div><div class="line">cap = cv2.VideoCapture(&apos;video.avi&apos;)</div><div class="line">fourcc = cv2.cv.CV_FOURCC(*&apos;XVID&apos;)</div><div class="line">fps = 25</div><div class="line">ret, frame = cap.read()</div><div class="line">height, width = frame.shape[:2]</div><div class="line">out = cv2.VideoWriter(&apos;output.avi&apos;, fourcc, fps, (width, height))</div><div class="line"></div><div class="line">startTime = 60 # start at 60s</div><div class="line">endTime = 70 # end at 70s</div><div class="line"></div><div class="line">totalTime = cap.get(cv2.cv.CV_CAP_PROP_FRAME_COUNT) / fps</div><div class="line">if startTime &gt;= totalTime or endTime &gt; totalTime or startTime &gt; endTime:</div><div class="line">    print &apos;Invalid time settings&apos;</div><div class="line">    sys.exit(0)</div><div class="line"></div><div class="line">startFrame = startTime * fps</div><div class="line">stopFrame = endTime * fps</div><div class="line">cap.set(cv2.cv.CV_CAP_PROP_POS_FRAMES, startFrame) # read from startFrame</div><div class="line">duration = stopFrame - startFrame</div><div class="line"></div><div class="line">while duration and cap.isOpened():</div><div class="line">    ret, frame = cap.read()</div><div class="line">    cv2.imshow(&apos;preview&apos;, frame)</div><div class="line">    out.write(frame)</div><div class="line">    if cv2.waitKey(1000/fps) == 27:</div><div class="line">        break</div><div class="line">    duration -= 1</div><div class="line"></div><div class="line">cap.release()</div><div class="line">out.release()</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[BadApple视频转字符动画]]></title>
      <url>http://lizonghang.github.io/2016/08/06/BadApple%E8%A7%86%E9%A2%91%E8%BD%AC%E5%AD%97%E7%AC%A6%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&emsp;&emsp;实现 badapple.mp4 视频转字符动画，在终端显示字符动画。原理比较简单，使用终端命令 <code>ffmpeg</code> 从视频中抽取帧保存为图片，使用函数 <code>image2txt()</code> 将图片转化为字符画，最后使用终端命令 <code>cat</code> 输出字符动画。<br>&emsp;&emsp;源代码、帧图片、txt文本集可以从<a href="https://github.com/Lizonghang/Python-BadApple" target="_blank" rel="external">Github</a>中获取，badapple.mp4 可以从<a href="http://yun.baidu.com/s/1cLvjHG" target="_blank" rel="external">百度云</a>获取。通常视频是以 1 秒 24 帧图片组成的，为了节省时间与容量，采样的帧图片为 1 秒 10 帧，最终字符动画播放流畅，对质量无明显影响。若依旧要采用 1 秒 24 帧，可以修改 getImage.py 中的参数，修改方法见下文。<br>&emsp;&emsp;需要确保已经安装有第三方库 <code>PIL</code> 与 <code>numpy</code>，以及 <code>ffmpeg</code> 插件(可通过 Homebrew 安装)。</p>
<h1 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h1><p>本项目完整的包内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">badapple</div><div class="line">├── README.md</div><div class="line">├── getImage.py</div><div class="line">├── image2txt.py</div><div class="line">├── play.py</div><div class="line">├── images</div><div class="line">│   └── *.png</div><div class="line">└── txt</div><div class="line">    └── *.txt</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;getImage.py 用于从视频中提取帧图片，提取的帧图片存放于 images/ 文件夹，有 2190 张帧图片，若文件夹中已存在帧图片可不运行该程序。若要调整每帧图片数可调整变量 <code>crop_time</code> 累加的数值，清空已存在的图片集，修改视频路径(<code>videoPath</code>)、帧图片目录路径(<code>imagePath</code>)，再运行 getImage.py。由于调用的 <code>ffmpeg</code> 命令会输出很多信息，若要屏蔽这些信息可以修改 <code>os.system()</code> 中的命令，更换标准输出到文件。只需确保有对应图片生成即可。<br>&emsp;&emsp;image2txt.py 用于将图片转化为一定尺寸的字符画，从 images/ 文件夹中提取图片并转化为 txt 文本存放于 txt/ 文件夹。默认要求的终端尺寸为 300x75 ，若屏幕不能支持该大小，可以将参数 <code>charWidth</code> 修改为自定义的每行显示字符数，调整后若运行 play.py 要求终端大小为 (charWidth)x(charWidth/4) 。<br>&emsp;&emsp;play.py 用于获取 txt 文本集与依次显示 txt 文本集，以达到在终端播放字符动画的效果。运行之前请修改视频目录(<code>videoPath</code>)、txt文件夹目录(<code>txt_dir_path</code>)、images文件夹目录(<code>img_dir_path</code>)。若选择默认的终端大小 300x75 运行该程序，请先注释掉 <code>getTxt(img_dir_path, txt_dir_path)</code>，然后运行 play.py。若选择自定义的终端大小运行该程序，需要自行调整终端大小为 (charWidth)x(charWidth/4)，不注释 <code>getTxt(img_dir_path, txt_dir_path)</code>，然后运行 play.py，这需要稍等 10~60 秒。随后就能在终端显示字符动画。</p>
<p><strong>注意</strong>：自定义的 <code>charWidth</code> 过小则会降低播放质量，过大则会出现终端闪烁现象。需要根据实际情况调整 <code>charWidth</code>。<br><strong>注意</strong>：若修改了每帧播放的图片数目，则需要修改 play.py 中的 <code>time.sleep()</code> 数值，这是一个经验数值，用于和视频播放速度同步，修改该数值可加速或减缓字符动画播放速率。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="getImage-py"><a href="#getImage-py" class="headerlink" title="getImage.py"></a>getImage.py</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line"></div><div class="line">def getImage(videoPath, imagePath):</div><div class="line">    img_count = 1</div><div class="line">    crop_time = 0.0</div><div class="line">    while crop_time &lt;= 219.0:</div><div class="line">        os.system(&apos;ffmpeg -i %s -f image2 -ss %s -vframes 1 %s.png&apos; % (videoPath, str(crop_time), imagePath + str(img_count)))</div><div class="line">        img_count += 1</div><div class="line">        print &apos;Geting Image &apos; + str(img_count) + &apos;.png&apos; + &apos; from time &apos; + str(crop_time)</div><div class="line">        crop_time += 0.1</div><div class="line">    print &apos;Image Collected&apos;</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    videoPath = &apos;/Users/mac/Desktop/badapple.avi&apos;</div><div class="line">    imagePath = &apos;/Users/mac/Desktop/badapple/images/&apos;</div><div class="line">    getImage(videoPath, imagePath)</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;该模块用于从视频文件中抽取帧图片，<code>crop_time</code> 为抽取帧的时间，单位为秒，默认从 0 秒开始抽取，直到截取时间到达视频结束时间(219秒)。抽取帧图片使用了终端命令 <code>ffmpeg</code> 。输入文件为 badapple.mp4，输出格式为 <code>image2</code> 图片格式，截取时间为 0.0 秒，帧数为 1 ，输出图片为 1.png ： <code>ffmpeg -i badapple.mp4 -f image2 -ss 0.0 -vframes 1 1.png</code>。<br>&emsp;&emsp;<code>crop_time += 0.1</code> 中的累加数值表示 1 秒获取 1/0.1 张帧图片，调整该值将改变每秒获取的帧数目。<br>&emsp;&emsp;图片存储从 1.png 开始依次累增，直到 2190.png。<br>&emsp;&emsp;<code>videoPath</code> 为视频文件路径， <code>imagePath</code> 为图片文件夹路径。该模块可直接运行，运行之前先确认路径正确。如果已经有图片集，不需要运行该模块。</p>
<h2 id="image2txt-py"><a href="#image2txt-py" class="headerlink" title="image2txt.py"></a>image2txt.py</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line">import numpy</div><div class="line"></div><div class="line">def image2txt(inputFile, outputFile):</div><div class="line">    im = Image.open(inputFile).convert(&apos;L&apos;)</div><div class="line">    charWidth = 300</div><div class="line">    im = im.resize((charWidth, charWidth / 4))</div><div class="line">    target_width, target_height = im.size</div><div class="line">    data = numpy.array(im)[:target_height, :target_width]</div><div class="line">    f = open(outputFile, &apos;w&apos;)</div><div class="line">    for row in data:</div><div class="line">        for pixel in row:</div><div class="line">            if pixel &gt; 127:</div><div class="line">                f.write(&apos;#&apos;)</div><div class="line">            else:</div><div class="line">                f.write(&apos; &apos;)</div><div class="line">        f.write(&apos;\n&apos;)</div><div class="line">    f.close()</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;该模块用于将图片转化为字符画，转化前先将图片转化为灰度图，并将图片“变扁”以适应输出字符画与原画的比例，经验数据高度应为宽度的 1/4 。随后将大于阈值的像素写入’#’，小于阈值的像素写入’ ‘，默认阈值为 127。输出时，’#’ 表示白色，’ ‘ 表示黑色。写入的 txt 文件名需要与对应图片文件名对应，如 ‘1.png’ 对应 ‘1.txt’。转化后的 txt 文件存放于 txt/ 文件夹中。<br>&emsp;&emsp;<code>charWidth</code> 表示终端每行输出的字符数，数值需要根据实际需求调整，默认适应的终端大小为 300x75。</p>
<h2 id="play-py"><a href="#play-py" class="headerlink" title="play.py"></a>play.py</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import sys, os</div><div class="line">import image2txt</div><div class="line">import time</div><div class="line"></div><div class="line">def getTxt(imagePath, txtPath):</div><div class="line">    img_count = 1</div><div class="line">    while img_count &lt;= len(os.listdir(imagePath)):</div><div class="line">        imageFile = imagePath + str(img_count) + &apos;.png&apos;</div><div class="line">        txtFile = txtPath + str(img_count) + &apos;.txt&apos;</div><div class="line">        image2txt.image2txt(imageFile, txtFile)</div><div class="line">        print &apos;txt &apos; + str(img_count) + &apos; collected.&apos;</div><div class="line">        img_count += 1</div><div class="line"></div><div class="line">def play(txtPath):</div><div class="line">    txt_count = 1</div><div class="line">    while txt_count &lt;= len(os.listdir(txtPath)):</div><div class="line">        os.system(&apos;cat &apos; + txtPath + str(txt_count) + &apos;.txt&apos;)</div><div class="line">        time.sleep(1.0/11.25)</div><div class="line">        txt_count += 1</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    txt_dir_path = &apos;/Users/mac/Desktop/badapple/txt/&apos;</div><div class="line">    img_dir_path = &apos;/Users/mac/Desktop/badapple/images/&apos;</div><div class="line">    getTxt(img_dir_path, txt_dir_path)</div><div class="line">    play(txt_dir_path)</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;该模块是主要模块，用于在终端播放字符动画。播放前先按照 <code>charWidth</code> 的数值将帧图片集转换为字符集(若使用默认的 300x75 则忽略该步骤，注释掉函数 <code>getTxt(…)</code> 即可；若使用自定义比例，需要 10~60 秒等待时间)。然后使用终端命令 <code>cat</code> 依次输出各个 txt 文本中的字符画，输出的时间间隔是经验数值，可根据实际播放速度调整，加速或减缓播放速率以和原视频同步。<br>&emsp;&emsp;运行该模块前需要确保 txt/ 文件夹路径与 images/ 文件夹路径正确。</p>
<h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>&emsp;&emsp;左边是终端窗口，右边是 Quicktime Player，显示屏是电视显示屏。效果展示在<a href="https://pan.baidu.com/s/1geQMXvP" target="_blank" rel="external">百度云</a></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[自动化测试模型]]></title>
      <url>http://lizonghang.github.io/2016/08/04/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;一个自动化测试框架就是一个集成体系，在这一体系中包含测试功能的函数库、测试数据源、测试对象识别标准、以及多种可重用的模块。自动化测试框架在发展的过程中经历了几个阶段：模块驱动测试、数据驱动测试、对象驱动测试。</p>
<h1 id="自动化测试模型"><a href="#自动化测试模型" class="headerlink" title="自动化测试模型"></a>自动化测试模型</h1><p>&emsp;&emsp;自动化测试模型是自动化测试架构的基础，自动化测试的发展也经历了不同的阶段，不断有新的模型（概念）被提出，了解和使用这些自动化模型有利于构建一个灵活可维护的自动化架构。</p>
<h2 id="线性测试"><a href="#线性测试" class="headerlink" title="线性测试"></a>线性测试</h2><p>&emsp;&emsp;通过录制或编写脚本，一个脚本完成一个场景（一组完整功能操作），通过对脚本的回放来进行自动化测试。这是早期进行自动化测试的一种形式。例如在<a href="/2016/08/03/Selenium模拟操作实例/">模拟登陆实例</a>中的脚本就是线性测试形式。它的优势是每个脚本都是独立的，任何一个脚本文件可以单独运行。缺点是用例的开发与维护成本很高：</p>
<ul>
<li>一个用例对应一个脚本。如果登陆发送变化，例如用户名的属性发生改变，就不得不对每个脚本进行修改。测试用例形成规模，大量的工作被用于脚本的维护，从而失去自动化的意义。</li>
<li>这种模式下数据和脚本是混合在一起的，如果数据发生改变就需要修改脚本。这种模式下，脚本没有可重复使用的概念。</li>
</ul>
<h2 id="模块化与类库"><a href="#模块化与类库" class="headerlink" title="模块化与类库"></a>模块化与类库</h2><p>&emsp;&emsp;在脚本中有很多内容是重复的，于是可以将重复的部分写成公共模块，在需要的时候进行调用，这样就提高了编写脚本的效率。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># login.py</div><div class="line">def login():</div><div class="line">    driver.find_element_by_id(&quot;username&quot;).send_keys(&quot;username&quot;)</div><div class="line">    driver.find_element_by_id(&quot;password&quot;).send_keys(&quot;password&quot;)</div><div class="line">    driver.find_element_by_id(&quot;btnLogin&quot;).click()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># quit.py</div><div class="line">def quit():</div><div class="line">    driver.find_element_by_id(&quot;btnQuit&quot;).click()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">import login, quit</div><div class="line">driver = webdriver.Chrome()</div><div class="line">driver.get(&apos;http://www.ooxx.com&apos;)</div><div class="line">login.login()</div><div class="line">quit.quit()</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过上述不完整样例发现，可以将脚本中相同的部分代码独立出来形成模块或库。这样做有两方面优点：</p>
<ul>
<li>提高了开发效率，不用重复编写相同的脚本。之后需要时调用已写好的模块即可。</li>
<li>方便代码的维护。如果某个模块发生变化，只需要修改对应模块的代码即可。</li>
</ul>
<h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h2><p>&emsp;&emsp;数据驱动是自动化的进步，数据的改变驱动自动化的执行，从而引起测试结果的改变。简单的说，通过输入数据的不同引起输出结果的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">import time</div><div class="line">values = [&apos;selenium&apos;, &apos;webdriver&apos;]</div><div class="line">for search in values:</div><div class="line">    driver = webdriver.Chrome()</div><div class="line">    driver.get(http://www.baidu.com)</div><div class="line">    driver.find_element_by_id(&apos;kw&apos;).send_keys(search, Keys.RETURN)</div><div class="line">    time.sleep(3)</div><div class="line">    driver.close()</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取的数据源可能是数组、字典、函数、CSV或TXT文件，上面的例子实现了数据与脚本的分离，实现了参数化。同样的脚本执行不同的数据得到不同的结果，从而增强了脚本的复用性。</p>
<h2 id="关键字驱动"><a href="#关键字驱动" class="headerlink" title="关键字驱动"></a>关键字驱动</h2><p>&emsp;&emsp;关键词驱动就是通过关键字的改变引起测试结果改变。QTP、robot framework 等都是以关键字驱动为主的自动化工具，因为这类工具的易用性，‘填表’式的关键字驱动帮助封装了很多底层的东西，测试人员只需要考虑三个问题：做什么、对谁做、怎么做。可以将 Selenium IDE 看做一种关键字驱动的自动化工具，Selenium IDE 脚本分：命令（command）、对象（target）、值（value），通过这样的格式去描述不同的对象，从而引起结果的改变。</p>
<h1 id="登陆模块化"><a href="#登陆模块化" class="headerlink" title="登陆模块化"></a>登陆模块化</h1><p>&emsp;&emsp;在目前的脚本中有很多代码是可以模块化的，比如登陆模块。几乎每一个用例的执行都需要登陆脚本，那么久可以将登陆脚本独立到单独的文件调用。以<a href="/2016/08/03/Selenium模拟操作实例/#模拟百度登入登出">模拟百度登入登出</a>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># login.py</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.common.exceptions import NoSuchElementException</div><div class="line"></div><div class="line">def login(self):</div><div class="line">    driver = self.driver</div><div class="line">    driver.find_element_by_id(&apos;u1&apos;).find_element_by_name(&apos;tj_login&apos;).click()</div><div class="line">    try:</div><div class="line">        usernameInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__userName&apos;)</div><div class="line">        passwordInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__password&apos;)</div><div class="line">        usernameInput.clear()</div><div class="line">        passwordInput.clear()</div><div class="line">        usernameInput.send_keys(self.username)</div><div class="line">        passwordInput.send_keys(self.password)</div><div class="line">        driver.find_element_by_id(&apos;TANGRAM__PSP_8__submit&apos;).submit()</div><div class="line">    except NoSuchElementException as msg:</div><div class="line">        return False</div><div class="line">    return True</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"># baidu.py</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.action_chains import ActionChains</div><div class="line">from selenium.webdriver.common.by import By</div><div class="line">from selenium.webdriver.support.ui import WebDriverWait</div><div class="line">from selenium.webdriver.support import expected_conditions as EC</div><div class="line">import unittest, time</div><div class="line">import login</div><div class="line"></div><div class="line">class Login(unittest.TestCase):</div><div class="line"></div><div class="line">    def setUp(self):</div><div class="line">        self.driver = webdriver.Chrome()</div><div class="line">        self.driver.implicitly_wait(5)</div><div class="line">        self.username = &apos;username&apos;</div><div class="line">        self.password = &apos;password&apos;</div><div class="line"></div><div class="line">    def test_login(self):</div><div class="line">        driver = self.driver</div><div class="line">        driver.get(&apos;https://www.baidu.com&apos;)</div><div class="line">        if login.login(self):</div><div class="line">            ActionChains(driver).move_to_element(driver.find_element_by_id(&apos;s_username_top&apos;)).perform()</div><div class="line">            ActionChains(driver).move_to_element(driver.find_element_by_class_name(&apos;quit&apos;)).click().perform()</div><div class="line">            ActionChains(driver).move_to_element(driver.find_elements_by_xpath(&apos;//div[@class=&quot;button-wrap&quot;]/a&apos;)[2]).click().perform()</div><div class="line">            time.sleep(3)</div><div class="line"></div><div class="line">    def tearDown(self):</div><div class="line">        self.driver.quit()</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    unittest.main()</div></pre></td></tr></table></figure>
<h1 id="数据驱动-1"><a href="#数据驱动-1" class="headerlink" title="数据驱动"></a>数据驱动</h1><h2 id="数据参数化"><a href="#数据参数化" class="headerlink" title="数据参数化"></a>数据参数化</h2><p>&emsp;&emsp;在上面关于数据驱动的介绍中已经示例了使用数组进行参数化设置，这里将通过读取 txt 文件中的数据来实现参数化。</p>
<p>创建一个 data.txt 文件，文件内有三行数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">selenium</div><div class="line">webdriver</div><div class="line">bokeyuan</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过 for 循环，search 可以每次获取到文件中的一行数据，在定位到百度搜索框后将数据传入 send_keys()。这样通过循环调用，直到文件中的所有内容被读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">import time</div><div class="line"></div><div class="line">source = open(&apos;data.txt&apos;)</div><div class="line">values = source.readlines()</div><div class="line">source.close()</div><div class="line">for search in values:</div><div class="line">    driver = webdriver.Chrome()</div><div class="line">    driver.get(&apos;http://www.baidu.com&apos;)</div><div class="line">    driver.find_element_by_id(&apos;kw&apos;).send_keys(search, Keys.RETURN)</div><div class="line">    time.sleep(2)</div><div class="line">    driver.close()</div></pre></td></tr></table></figure>
<h2 id="登录参数化-读取txt文件"><a href="#登录参数化-读取txt文件" class="headerlink" title="登录参数化(读取txt文件)"></a>登录参数化(读取txt文件)</h2><p>&emsp;&emsp;按照上述思路，对自动化脚本中用户名、密码进行参数化。创建 userdata.txt 文件，存放用户名和密码，假设存放格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">username1 password1</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;在之前编写的 login.py 文件基础上作如下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">from selenium.common.exceptions import NoSuchElementException</div><div class="line"></div><div class="line">source = open(&apos;userdata.txt&apos;)</div><div class="line">username, password = source.readlines()[0].split()</div><div class="line">source.close()</div><div class="line"></div><div class="line">def login(self):</div><div class="line">    driver = self.driver</div><div class="line">    driver.find_element_by_id(&apos;u1&apos;).find_element_by_name(&apos;tj_login&apos;).click()</div><div class="line">    try:</div><div class="line">        usernameInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__userName&apos;)</div><div class="line">        passwordInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__password&apos;)</div><div class="line">        usernameInput.clear()</div><div class="line">        passwordInput.clear()</div><div class="line">        usernameInput.send_keys(username)</div><div class="line">        passwordInput.send_keys(password)</div><div class="line">        driver.find_element_by_id(&apos;TANGRAM__PSP_8__submit&apos;).submit()</div><div class="line">    except NoSuchElementException as msg:</div><div class="line">        return False</div><div class="line">    return True</div></pre></td></tr></table></figure>
<h2 id="登录参数化-函数"><a href="#登录参数化-函数" class="headerlink" title="登录参数化(函数)"></a>登录参数化(函数)</h2><p>&emsp;&emsp;函数可以预先给参数化赋值，借助这个特性，可以通过调用函数对用户名和密码进行参数化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># userinfo.py</div><div class="line">def Tester_Li(username=&apos;testusername&apos;, password=&apos;testpassword&apos;):</div><div class="line">    return username, password</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过给函数参数赋予默认值并返回的方法可以在函数中存储一些信息。再次修改 login.py 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># login.py</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.common.exceptions import NoSuchElementException</div><div class="line">import userinfo</div><div class="line"></div><div class="line">username, password = userinfo.Tester_Li()</div><div class="line"></div><div class="line">def login(self):</div><div class="line">    driver = self.driver</div><div class="line">    driver.find_element_by_id(&apos;u1&apos;).find_element_by_name(&apos;tj_login&apos;).click()</div><div class="line">    try:</div><div class="line">        usernameInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__userName&apos;)</div><div class="line">        passwordInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__password&apos;)</div><div class="line">        usernameInput.clear()</div><div class="line">        passwordInput.clear()</div><div class="line">        usernameInput.send_keys(username)</div><div class="line">        passwordInput.send_keys(password)</div><div class="line">        driver.find_element_by_id(&apos;TANGRAM__PSP_8__submit&apos;).submit()</div><div class="line">    except NoSuchElementException as msg:</div><div class="line">        return False</div><div class="line">    return True</div></pre></td></tr></table></figure>
<h2 id="登录参数化-读取字典"><a href="#登录参数化-读取字典" class="headerlink" title="登录参数化(读取字典)"></a>登录参数化(读取字典)</h2><p>&emsp;&emsp;使用一个函数来存储字典，假设文件名为 userinfo.py：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># userinfo.py</div><div class="line">def getUserInfo():</div><div class="line">    data = &#123;</div><div class="line">    &apos;Tester_Li&apos;: &#123;&apos;username&apos;: &apos;Li_username&apos;, &apos;password&apos;: &apos;Li_password&apos;&#125;,</div><div class="line">    &apos;Tester_Wang&apos;: &#123;&apos;username&apos;: &apos;Wang_username&apos;, &apos;password&apos;: &apos;Wang_password&apos;&#125;,</div><div class="line">    &#125;</div><div class="line">    return data</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># login.py</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.common.exceptions import NoSuchElementException</div><div class="line">import userinfo</div><div class="line"></div><div class="line">info_dict = userinfo.getUserInfo()[&apos;Tester_Li&apos;]</div><div class="line">username = info_dict[&apos;username&apos;]</div><div class="line">password = info_dict[&apos;password&apos;]</div><div class="line"></div><div class="line">def login(self):</div><div class="line">    driver = self.driver</div><div class="line">    driver.find_element_by_id(&apos;u1&apos;).find_element_by_name(&apos;tj_login&apos;).click()</div><div class="line">    try:</div><div class="line">        usernameInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__userName&apos;)</div><div class="line">        passwordInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__password&apos;)</div><div class="line">        usernameInput.clear()</div><div class="line">        passwordInput.clear()</div><div class="line">        usernameInput.send_keys(username)</div><div class="line">        passwordInput.send_keys(password)</div><div class="line">        driver.find_element_by_id(&apos;TANGRAM__PSP_8__submit&apos;).submit()</div><div class="line">    except NoSuchElementException as msg:</div><div class="line">        return False</div><div class="line">    return True</div></pre></td></tr></table></figure>
<h2 id="表单参数化-CSV"><a href="#表单参数化-CSV" class="headerlink" title="表单参数化(CSV)"></a>表单参数化(CSV)</h2><p>&emsp;&emsp;假设自动化脚本中要参数化一张表单，表单需要填写用户名、邮箱、年龄、性别等信息，就适合用读取 CSV 文件的方法来解决。创建 userinfo.csv 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">laowang,123456@126.com,23,男,</div><div class="line">xiaoli,123123@qq.com, 18, 女,</div><div class="line">xiaomin,456123@gmail.com, 29,女,</div></pre></td></tr></table></figure>
<p>使用 csv 库来读取 CSV 文件中的数据并格式化输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># encoding: utf-8</div><div class="line">import csv</div><div class="line">for user in csv.reader(file(&apos;userinfo.csv&apos;, &apos;rb&apos;)):</div><div class="line">    print &apos;Name: %s, Mail: %s, Age: %s, Sex: %s&apos; % tuple(user[0:4])</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Name: laowang, Mail: 123456@126.com, Age: 23, Sex: 男</div><div class="line">Name: xiaoli, Mail: 123123@qq.com, Age:  18, Sex:  女</div><div class="line">Name: xiaomin, Mail: 456123@gmail.com, Age:  29, Sex: 女</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;csv.reader() 用于读取 CSV 文件，每一次循环的 user 变量是一个列表，可以通过 user[index] 来读取其中的数据，上面将 user 中的数据抽取出来并转换为元组来简化代码。通过 csv 读取文件比较灵活，可以循环读取每一条数据，又不局限每次读取数据的个数。</p>
]]></content>
      
        <categories>
            
            <category> 软件测试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Selenium模拟操作实例]]></title>
      <url>http://lizonghang.github.io/2016/08/03/Selenium%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<h1 id="模拟百度登入登出"><a href="#模拟百度登入登出" class="headerlink" title="模拟百度登入登出"></a>模拟百度登入登出</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">from selenium.webdriver.common.by import By</div><div class="line">from selenium.webdriver.common.action_chains import ActionChains</div><div class="line">from selenium.webdriver.common.alert import Alert</div><div class="line">from selenium.webdriver.support.ui import WebDriverWait</div><div class="line">from selenium.webdriver.support import expected_conditions as EC</div><div class="line">import time</div><div class="line"></div><div class="line">driver = webdriver.Chrome()</div><div class="line">driver.get(&apos;https://www.baidu.com&apos;)</div><div class="line">try:</div><div class="line">    driver.find_element_by_id(&apos;u1&apos;).find_element_by_name(&apos;tj_login&apos;).click()</div><div class="line">    WebDriverWait(driver, 3).until(EC.presence_of_element_located((By.ID, &apos;TANGRAM__PSP_8__userName&apos;)))</div><div class="line">    driver.find_element_by_id(&apos;TANGRAM__PSP_8__userName&apos;).send_keys(&apos;username&apos;)</div><div class="line">    driver.find_element_by_id(&apos;TANGRAM__PSP_8__password&apos;).send_keys(&apos;password&apos;)</div><div class="line">    driver.find_element_by_id(&apos;TANGRAM__PSP_8__submit&apos;).submit()</div><div class="line">    WebDriverWait(driver, 3).until(EC.presence_of_element_located((By.ID, &apos;s_username_top&apos;)))</div><div class="line">    ActionChains(driver).move_to_element(driver.find_element_by_id(&apos;s_username_top&apos;)).perform()</div><div class="line">    ActionChains(driver).move_to_element(driver.find_element_by_class_name(&apos;quit&apos;)).click().perform()</div><div class="line">    WebDriverWait(driver, 3).until(EC.presence_of_element_located((By.CLASS_NAME, &apos;button-wrap&apos;)))</div><div class="line">    ActionChains(driver).move_to_element(driver.find_elements_by_xpath(&apos;//div[@class=&quot;button-wrap&quot;]/a&apos;)[2]).click().perform()</div><div class="line">    time.sleep(3)</div><div class="line">finally:</div><div class="line">    driver.quit()</div></pre></td></tr></table></figure>
<h1 id="模拟问卷星发布问卷"><a href="#模拟问卷星发布问卷" class="headerlink" title="模拟问卷星发布问卷"></a>模拟问卷星发布问卷</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"># encoding: utf-8</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">from selenium.webdriver.common.by import By</div><div class="line">from selenium.webdriver.support.ui import WebDriverWait</div><div class="line">from selenium.webdriver.support import expected_conditions as EC</div><div class="line">from selenium.common.exceptions import NoSuchElementException</div><div class="line">from selenium.webdriver.support.select import Select</div><div class="line">from selenium.webdriver.common.alert import Alert</div><div class="line">import time, sys</div><div class="line"></div><div class="line"># settings</div><div class="line">username = &apos;username&apos;</div><div class="line">password = &apos;password&apos;</div><div class="line"></div><div class="line">driver = webdriver.Chrome()</div><div class="line">driver.implicitly_wait(5)</div><div class="line">driver.get(&apos;http://www.baidu.com&apos;)</div><div class="line">driver.find_element_by_id(&apos;kw&apos;).send_keys(u&apos;问卷星&apos;, Keys.RETURN)</div><div class="line">driver.find_element_by_xpath(&apos;//div[@id=&quot;1&quot;]/h3&apos;).click()</div><div class="line">driver.switch_to_window(driver.window_handles[1])</div><div class="line">driver.find_element_by_id(&apos;ctl00_liLogin&apos;).click()</div><div class="line">time.sleep(1)</div><div class="line">username = driver.find_element_by_id(&apos;ctl00_ContentPlaceHolder1_UserName&apos;)</div><div class="line">password = driver.find_element_by_id(&apos;ctl00_ContentPlaceHolder1_Password&apos;)</div><div class="line">username.clear()</div><div class="line">password.clear()</div><div class="line">username.send_keys(username)</div><div class="line">password.send_keys(password, Keys.RETURN)</div><div class="line"></div><div class="line"># 登陆时可能出现验证码</div><div class="line">try:</div><div class="line">    driver.find_element_by_xpath(&apos;//div[@id=&quot;ctl01_ContentPlaceHolder1_divInfo&quot;]/div/div/span/a&apos;).click()</div><div class="line">except NoSuchElementException:</div><div class="line">    print u&apos;出现验证码，程序退出&apos;</div><div class="line">    sys.exit(0)</div><div class="line"></div><div class="line">driver.find_element_by_xpath(&apos;//ul[@class=&quot;CR-Obox&quot;]/li/a&apos;).click()</div><div class="line">driver.find_elements_by_xpath(&apos;//div[@id=&quot;divSearchResult&quot;]/ul/li&apos;)[0].click()</div><div class="line">driver.find_element_by_class_name(&apos;MOM-bottom&apos;).click()</div><div class="line"></div><div class="line"># 新建问卷时可能出现验证码</div><div class="line">try:</div><div class="line">    driver.find_element_by_id(&apos;hrefFiQ&apos;).click()</div><div class="line">except NoSuchElementException:</div><div class="line">    print u&apos;出现验证码，程序退出&apos;</div><div class="line">    sys.exit(0)</div><div class="line"></div><div class="line">select = Select(driver.find_element_by_xpath(&apos;//select[@id=&quot;ddlActivity&quot;]&apos;))</div><div class="line">print u&apos;新建的问卷名为: &apos;, select.first_selected_option.text</div><div class="line">driver.find_element_by_xpath(&apos;//ul[@class=&quot;BS-menu&quot;]/li&apos;).click()</div><div class="line">driver.find_elements_by_xpath(&apos;//tr&apos;)[0].find_element_by_class_name(&apos;delete&apos;).click()</div><div class="line">Alert(driver).accept()</div><div class="line">driver.find_elements_by_xpath(&apos;//ul[@class=&quot;BS-menu&quot;]/li&apos;)[-1].click()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 软件测试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Selenium自动化测试]]></title>
      <url>http://lizonghang.github.io/2016/07/31/Selenium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>参考Selenium官方文档 <a href="http://selenium-python.readthedocs.io/getting-started.html" target="_blank" rel="external">http://selenium-python.readthedocs.io/getting-started.html</a></p>
<h1 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h1><h2 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install selenium</div></pre></td></tr></table></figure>
<p>如果下载时抛出了如下错误，可不予理会：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OSError: [Errno 1] Operation not permitted: &apos;/System/Library/Frameworks/Python.framework/Versions/2.7/selenium&apos;</div></pre></td></tr></table></figure>
<p>进入 python 交互环境，尝试导入 selenium 模块即可</p>
<h2 id="chromedriver"><a href="#chromedriver" class="headerlink" title="chromedriver"></a>chromedriver</h2><p>如果要选择 Chrome 作为测试浏览器，需要先安装 chromedriver，否则在实例化时会抛出以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; brower = webdriver.chrome()</div><div class="line">...</div><div class="line">selenium.common.exceptions.WebDriverException: Message: &apos;chromedriver&apos; executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home</div></pre></td></tr></table></figure>
<p>Mac 用户可使用 Homebrew 直接下载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install chromedriver</div></pre></td></tr></table></figure>
<p>下载完成后可能会出现以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Error: parent directory is world writable but not sticky</div><div class="line">Please report this bug:</div><div class="line">    https://git.io/brew-troubleshooting</div><div class="line">/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/tmpdir.rb:92:in `mktmpdir&apos;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>解决方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo chmod +t /private/tmp/</div></pre></td></tr></table></figure>
<p>随后再尝试下载 chromedriver，进入 python 交互环境尝试实例化即可。</p>
<h1 id="简单用例"><a href="#简单用例" class="headerlink" title="简单用例"></a>简单用例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">import time</div><div class="line"># The instance of Chrome WebDriver is created.</div><div class="line">driver = webdriver.Chrome()</div><div class="line"># The driver.get() method will navigate to a page given by the URL. WebDriver will wait until the page has fully loaded (that is, the “onload” event has fired) before returning control to your test or script. It’s worth noting that if your page uses a lot of AJAX on load then WebDriver may not know when it has completely loaded.</div><div class="line">driver.get(&apos;http://www.python.org&apos;)</div><div class="line">print driver.title</div><div class="line"># WebDriver offers a number of ways to find elements using one of the find_element_by_* methods. For example, the input text element can be located by its name attribute using find_element_by_name method. Detailed explanation of finding elements is available in the Locating Elements chapter</div><div class="line">elem = driver.find_element_by_name(&apos;q&apos;)</div><div class="line"># Next we are sending keys, this is similar to entering keys using your keyboard. Special keys can be send using Keys class imported from selenium.webdriver.common.keys. To be safe, we’ll first clear any prepopulated text in the input field (e.g. “Search”) so it doesn’t affect our search results</div><div class="line">elem.clear()</div><div class="line">elem.send_keys(&apos;pycon&apos;)</div><div class="line">elem.send_keys(Keys.RETURN)</div><div class="line">print driver.page_source</div><div class="line">time.sleep(5)</div><div class="line"># Finally, the browser window is closed. You can also call quit method instead of close. The quit will exit entire browser whereas close` will close one tab, but if just one tab was open, by default most browser will exit entirely.</div><div class="line">driver.close()</div></pre></td></tr></table></figure>
<p>这段程序会打开浏览器，访问 <a href="http://www.python.org" target="_blank" rel="external">http://www.python.org</a> 并搜索 pycon，等待 5s 后关闭浏览器。</p>
<h1 id="用Selenium写测试单元"><a href="#用Selenium写测试单元" class="headerlink" title="用Selenium写测试单元"></a>用Selenium写测试单元</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">import unittest</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">import time</div><div class="line"></div><div class="line">class PythonOrgSearch(unittest.TestCase):</div><div class="line">    def setUp(self):</div><div class="line">        self.driver = webdriver.Chrome()</div><div class="line"></div><div class="line">    def test_search_in_python_org(self):</div><div class="line">        driver = self.driver</div><div class="line">        driver.get(&apos;http://www.python.org&apos;)</div><div class="line">        self.assertIn(&apos;Python&apos;, driver.title)</div><div class="line">        elem = driver.find_element_by_name(&apos;q&apos;)</div><div class="line">        elem.send_keys(&apos;pycon&apos;)</div><div class="line">        elem.send_keys(Keys.RETURN)</div><div class="line">        assert &apos;No results found.&apos; not in driver.page_source</div><div class="line">        time.sleep(5)</div><div class="line"></div><div class="line">    def tearDown(self):</div><div class="line">        self.driver.quit()</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    unittest.main()</div></pre></td></tr></table></figure>
<p>以上仅为关于 selenium 的一些简要功能介绍，详细用法参考后续文档</p>
]]></content>
      
        <categories>
            
            <category> 软件测试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[软件测试分类]]></title>
      <url>http://lizonghang.github.io/2016/07/31/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;关于软件测试领域名词很多，从不同的角度可以将软件测试分为不同的类，这里汇总常见软件测试的相关名词，对软件测试领域有个概况的了解。</p>
<h1 id="项目流程划分"><a href="#项目流程划分" class="headerlink" title="项目流程划分"></a>项目流程划分</h1><p><img src="/images/v-mode.png" alt=""></p>
<p>&emsp;&emsp;<strong>单元测试</strong>：单元测试(或模块测试)是对程序中的单个子程序或具有独立功能的代码段进行测试的过程。</p>
<p>&emsp;&emsp;<strong>集成测试</strong>：集成测试是单元测试的基础上，将通过单元模块组装成系统或子系统，再进行测试，重点是检查模块之间的接口是否正确。</p>
<p>&emsp;&emsp;<strong>系统测试</strong>：系统测试是针对整个产品系统进行的测试，验证系统是否满足了需求规格的定义，以及软件系统的正确性和性能等是否满足其规约所指定的要求。</p>
<p>&emsp;&emsp;<strong>验收测试</strong>：验收测试是部署软件之前的最后一个测试操作。验收测试的目的是确保软件准备就绪，向软件购买者展示该软件系统满足其用户的需求。</p>
<h1 id="黑盒、白盒、灰盒测试"><a href="#黑盒、白盒、灰盒测试" class="headerlink" title="黑盒、白盒、灰盒测试"></a>黑盒、白盒、灰盒测试</h1><p>&emsp;&emsp;<strong>黑盒测试</strong>：黑盒测试指的是把被测的软件看作黑盒子，不需要关心盒子里面的结构，只关心软件的输入和输出。它只检查程序呈现给用户的功能是否按照需求规格说明书的规定正常使用，程序是否能适当的接收输入数据并产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。</p>
<p>&emsp;&emsp;<strong>白盒测试</strong>：白盒测试指将盒子打开，研究内部源代码和程序执行结果。它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作。</p>
<p>&emsp;&emsp;<strong>灰盒测试</strong>：灰盒测试介于黑盒测试和灰盒测试之间，灰盒测试关注输出对输入的正确性，同时也关注内部表现，但这种关注不如白盒测试详细完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态。有时输出正确但内部出现错误，如果每次都用白盒测试来操作，效率会很低，因此需要采取灰盒测试的方法。</p>
<h1 id="功能测试与性能测试"><a href="#功能测试与性能测试" class="headerlink" title="功能测试与性能测试"></a>功能测试与性能测试</h1><p>&emsp;&emsp;<strong>功能测试</strong>：功能测试检查实际的功能是否符合用户的需求。测试的大部分工作也是围绕软件的功能进行，设计软件的目的也就是满足客户对功能的需求。如果偏离这个目的，任何测试工作都失去意义。功能测试又可以分为逻辑功能测试、界面测试、易用性测试、安装测试、兼容性测试等。</p>
<p>&emsp;&emsp;<strong>性能测试</strong>：性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。软件的性能包括很多方面，主要有时间性能和空间性能两种。<br>&emsp;&emsp;&emsp;&emsp;<strong>时间性能</strong>：主要是指软件的一个具体的响应时间。比如一次登录需要的时间，一次交易需要的时间等。抛开具体的测试环境来分析一次事务的响应时间没有意义。需要搭建一个具体且独立的测试环境。<br>&emsp;&emsp;&emsp;&emsp;<strong>空间性能</strong>：主要指软件运行时所消耗的系统资源，比如硬件资源、CPU、内存、网络带宽等。</p>
<h1 id="手工测试与自动化测试"><a href="#手工测试与自动化测试" class="headerlink" title="手工测试与自动化测试"></a>手工测试与自动化测试</h1><p>&emsp;&emsp;<strong>手工测试</strong>：手工测试是由人去执行测试用例，通过键盘鼠标等输入一些参数，查看返回结果是否符合预期结果。手工测试并非专业术语，手工测试通常是指在系统测试阶段所进行的功能测试，为了更明显的与自动化测试进行区分，这里使用了手工测试。</p>
<p>&emsp;&emsp;<strong>自动化测试</strong>：自动化测试时把以人为驱动的测试行为转化为机器执行的过程。通常在设计了测试用例并通过评审之后，由测试人员根据测试用例中描述的规程一步步执行测试，得到实际结果与期望结果比较。在此过程中，为了节省人力、时间或硬件资源，提高测试效率，便引入了自动化测试的概念。<br>&emsp;&emsp;自动化测试又可分为功能自动化测试与性能自动化测试。<br>&emsp;&emsp;&emsp;&emsp;<strong>功能自动化测试</strong>：一般所说的自动化测试指功能自动化测试，通过相关的测试技术，通过编码的方式用一段程序来测试一个软件的功能，这样就可以重复执行程序来进行重复的测试。如果一个软件一小部分发生改变，只需要修改一部分自动化测试代码就可以重复对整个软件进行功能测试，从而大大提高测试效率。<br>&emsp;&emsp;&emsp;&emsp;<strong>性能自动化测试</strong>：目前性能测试工作都是通过性能测试工具辅助完成的。通过工具可以模拟大量的用户向系统发送请求，用来验证系统的处理能力。</p>
<h1 id="冒烟、回归、随机测试"><a href="#冒烟、回归、随机测试" class="headerlink" title="冒烟、回归、随机测试"></a>冒烟、回归、随机测试</h1><p>&emsp;&emsp;<strong>冒烟测试</strong>：冒烟测试是指在对一个新版本进行系统大规模测试之前，先验证软件的基本功能是否实现，是否具备可测性。引入到软件测试中，就是指测试小组在正规测试一个新版本之前，先投入较少的人力和时间验证一个软件的主要功能，如果主要功能都没有实现，则打回开发组重新开发。这样做可以节省大量的时间成本和人力成本。</p>
<p>&emsp;&emsp;<strong>回归测试</strong>：回归测试是指修改了旧代码后，重新进行测试以确认修改后没有引入新的错误或导致其他代码产生错误。回归测试一般是在进行软件的第二轮测试开始的，验证第一轮中发现的问题是否得到修复。回归也是一个循环的过程，如果回归的问题通不过则需要开发人员修改后再次进行回归，直到通过为止。</p>
<p>&emsp;&emsp;<strong>随机测试</strong>：随机测试是指测试中所有输入数据都是随机生成的，其目的是模拟用户的真实操作，并发现一些边缘性的错误。随机测试可以发现一些隐蔽的错误，但是也有很多缺点，比如测试不系统，无法统计代码覆盖率和需求覆盖率，发现的问题难以重现。一般是放在测试的最后执行。随机测试更专业的升级版称为探索性测试。</p>
<h1 id="其他测试"><a href="#其他测试" class="headerlink" title="其他测试"></a>其他测试</h1><p>&emsp;&emsp;<strong>探索性测试</strong>：探索性测试可以说是一种测试思维技术。它没有很多实际的测试方法、技术和工具，但却是所有测试人员都应该掌握的测试思维方式。探索性强调测试人员的主观能动性，抛弃繁杂的测试计划和测试用例设计过程，强调在碰到问题时及时改变测试策略。</p>
<p>&emsp;&emsp;<strong>安全测试</strong>：安全测试是在 IT 软件产品生命周期中，特别是产品开发基本完成到发布阶段，对产品进行校验以验证产品符合安全需求定义和产品质量标准的过程。安全测试越来越受到企业的关注和重视，因为由于安全性问题造成的后果是不可估量的。尤其互联网产品最容易受到各种安全攻击。</p>
<h1 id="适合自动化测试的项目"><a href="#适合自动化测试的项目" class="headerlink" title="适合自动化测试的项目"></a>适合自动化测试的项目</h1><p>&emsp;&emsp;不是所有项目都适合实施自动化测试，否则可能会浪费大量的人力和时间却没有得到应有的收益。是否可以对项目开展自动化测试可以参考以下 10 个条件：</p>
<ol>
<li>测试任务明确，不会频繁变动</li>
<li>每日构建后的测试验证</li>
<li>比较频繁的回归测试</li>
<li>软件系统界面稳定，变动少</li>
<li>需要在多平台上运行相同的测试案例、组合遍历型的测试、大量的重复任务</li>
<li>软件维护周期长</li>
<li>项目进度压力不大</li>
<li>被测软件系统开发比较规范，能够保证系统的可测试性</li>
<li>具备大量的自动化测试平台</li>
<li>测试人员具备较强的编程能力</li>
</ol>
<p>&emsp;&emsp;并非以上条件都具备才能开展测试工作。在普遍经验中，只要满足下面三个条件就可以对项目开展自动化测试：</p>
<p>&emsp;&emsp;<strong>软件需求编程不频繁</strong><br>&emsp;&emsp;测试脚本的稳定性决定了自动化测试的维护成本。如果软件需求变动过于频繁，测试人员需要根据变动的需求来更新测试用例以及相关的测试脚本，而脚本的维护本身就是代码开发的过程，需要修改、调试，必要的时候还要修改自动化测试的框架，如果花费的成本不低于利用其节省的测试成本，那么自动化测试便是失败的。<br>&emsp;&emsp;项目中的某些模块相对稳定，而某些模块需求变动性很大。可以对相对稳定的模块进行自动化测试，而变动大的使用手工测试。</p>
<p>&emsp;&emsp;<strong>项目周期较长</strong><br>&emsp;&emsp;由于自动化测试需求的确定、自动化测试框架的设计、测试脚本的编写与调试均需要相当长的时间来完成，这样的过程本身就是一个测试软件的开发过程，需要较长的时间来完成。如果项目的周期比较短，没有足够的时间去支持这个过程，那么最好不适用自动化测试。</p>
<p>&emsp;&emsp;<strong>自动化测试脚本可重复使用</strong><br>&emsp;&emsp;自动化测试脚本的重复使用要从三个方面考虑。测试的项目之间是否有很大的差异性（如 C/S 系统和 B/S 系统的差异）；选择的测试工具是否适应这种差异；测试人员是否有能力开发适应这种差异的自动化测试框架。</p>
]]></content>
      
        <categories>
            
            <category> 软件测试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Python实现录音功能]]></title>
      <url>http://lizonghang.github.io/2016/07/30/Python%E5%AE%9E%E7%8E%B0%E5%BD%95%E9%9F%B3%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<h1 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h1><h2 id="portaudio"><a href="#portaudio" class="headerlink" title="portaudio"></a>portaudio</h2><p>安装 pyaudio 时若没有安装该模块将会报错，因此须提前安装好该模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install portaudio</div></pre></td></tr></table></figure>
<h2 id="pyaudio"><a href="#pyaudio" class="headerlink" title="pyaudio"></a>pyaudio</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install pyaudio</div></pre></td></tr></table></figure>
<h2 id="修改pip源"><a href="#修改pip源" class="headerlink" title="修改pip源"></a>修改pip源</h2><p>默认的源为 pypi.python.org，修改 pip 源可以加速模块的下载，可以大幅提高安装效率。</p>
<p>修改源之前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Collecting pyaudio</div><div class="line">  Downloading PyAudio-0.2.9.tar.gz (289kB)</div><div class="line">    14% |████▌                           | 40kB 9.8kB/s eta 0:00:26Exception:</div><div class="line">Traceback (most recent call last):</div><div class="line">...</div><div class="line">ReadTimeoutError: HTTPSConnectionPool(host=&apos;pypi.python.org&apos;, port=443): Read timed out.</div></pre></td></tr></table></figure>
<p>修改源之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Collecting pyaudio</div><div class="line">  Downloading http://mirrors.aliyun.com/pypi/packages/d0/dc/ffb9ce5e3f19bd289902915a9f68b7d199216065f8ea17d5b5e8e4ad86ee/PyAudio-0.2.9.tar.gz (289kB)</div><div class="line">    100% |████████████████████████████████| 296kB 940kB/s</div><div class="line">Installing collected packages: pyaudio</div><div class="line">  Running setup.py install for pyaudio ... done</div><div class="line">Successfully installed pyaudio-0.2.9</div></pre></td></tr></table></figure>
<p>修改步骤（Mac/Linux）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cd</div><div class="line">$ mkdir .pip</div><div class="line">$ cd .pip</div><div class="line">$ vim pip.conf</div></pre></td></tr></table></figure>
<p>输入如下内容保存后退出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[global]</div><div class="line">index-url = http://mirrors.aliyun.com/pypi/simple/</div><div class="line"></div><div class="line">[install]</div><div class="line">trusted-host=mirrors.aliyun.com</div></pre></td></tr></table></figure>
<p>重新执行 pip 下载命令即可。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">import wave, pyaudio</div><div class="line"></div><div class="line"># Settings</div><div class="line">CHUNK = 1024</div><div class="line">FORMAT = pyaudio.paInt16</div><div class="line">RATE = 8000</div><div class="line">CHANNELS = 1</div><div class="line">RECORD_SECONDS = 5</div><div class="line"></div><div class="line"># Record Function</div><div class="line">def recordWave():</div><div class="line">    pa = pyaudio.PyAudio()</div><div class="line">    stream = pa.open(format=FORMAT,</div><div class="line">                     channels=CHANNELS,</div><div class="line">                     rate=RATE,</div><div class="line">                     input=True,</div><div class="line">                     frames_per_buffer=CHUNK)</div><div class="line"></div><div class="line">    print &apos;Recording...&apos;</div><div class="line"></div><div class="line">    buffer = []</div><div class="line">    for i in range(0, int(RATE/CHUNK*RECORD_SECONDS)):</div><div class="line">        audio_data = stream.read(CHUNK)</div><div class="line">        buffer.append(audio_data)</div><div class="line"></div><div class="line">    print &apos;Record Done&apos;</div><div class="line"></div><div class="line">    stream.stop_stream()</div><div class="line">    stream.close()</div><div class="line">    pa.terminate()</div><div class="line"></div><div class="line">    wf = wave.open(&apos;record.wav&apos;, &apos;wb&apos;)</div><div class="line">    wf.setnchannels(CHANNELS)</div><div class="line">    wf.setsampwidth(pa.get_sample_size(FORMAT))</div><div class="line">    wf.setframerate(RATE)</div><div class="line">    wf.writeframes(b&apos;&apos;.join(buffer))</div><div class="line">    wf.close()</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    recordWave()</div></pre></td></tr></table></figure>
<h1 id="关于语音识别"><a href="#关于语音识别" class="headerlink" title="关于语音识别"></a>关于语音识别</h1><p>&emsp;&emsp;本来想实现语音控制电脑的，结果搜索了 Google、讯飞、百度、聚合数据（不要用，存在泄露信息嫌疑）等的语音识别接口，要么价格昂贵（3000~30000大洋，学生玩不起），要么得花上数日时间审核，微信只提供了个语义识别接口而不是语音识别接口。本来 Google 提供了免费且方便的接口 <code><a href="http://www.google.com/speech-api/v1/recognize?xjerr=1&amp;client=chromium" target="_blank" rel="external">http://www.google.com/speech-api/v1/recognize?xjerr=1&amp;client=chromium</a></code> ，这是第一代 API，没有要求 Key，结果后来就被玩坏了，这个接口就被废弃了。有趣的是后来又出现了一个很相似的 API，<code><a href="https://www.google.com/speech-api/v2/recognize?lang=en-us&amp;key=APIKEY" target="_blank" rel="external">https://www.google.com/speech-api/v2/recognize?lang=en-us&amp;key=APIKEY</a></code>，它需要申请 APIKEY，仅限 Chrome 内部私自使用了。<br>&emsp;&emsp;然而经过不断尝试，这个接口始终不能正常访问，原因本人还没有找到，超时报错：<code>requests.exceptions.ConnectionError: (‘Connection aborted.’, error(60, ‘Operation timed out’))</code> 。这也导致了本文从语音控制变成了简单的使用 pyaudio 录制语言。等有结果了再来完善本篇，若有读者找到了免费可行的 API 成功实现 Speech-To-Text 还请不吝赐教，QQ：870644199 或邮箱 870644199@qq.com。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Python生成验证码]]></title>
      <url>http://lizonghang.github.io/2016/07/30/Python%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;对于识别验证码的程序来说最难的部分是验证码字符的切割和特征码的建立。很多验证码加了很多干扰素和干扰线，不仅影响用户体验还达不到防止破解的很好的效果。若要使验证码难于被程序识别，需要注意：</p>
<ul>
<li>字符粘连，最后所有字符都有粘连的部分</li>
<li>不使用规则字符，验证码的各个部分使用不同比例的缩放或者旋转</li>
</ul>
<p>&emsp;&emsp;一般实现以上两点或这两点的变性，破解程序就很难识别。为了不影响用户体验，还需要注意形状相似字符的区分。本文以较简易的椒盐、干扰线和旋转来实现常用的一类验证码。</p>
<h1 id="字体素材"><a href="#字体素材" class="headerlink" title="字体素材"></a>字体素材</h1><p><img src="/images/font.png" alt=""></p>
<h1 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># Settings</div><div class="line">parser = argparse.ArgumentParser()</div><div class="line">parser.add_argument(&apos;input&apos;, help=&apos;font image source&apos;)</div><div class="line">parser.add_argument(&apos;fontwidth&apos;, help=&apos;width of the font&apos;)</div><div class="line">parser.add_argument(&apos;fontheight&apos;, help=&apos;height of the font&apos;)</div><div class="line">parser.add_argument(&apos;-o&apos;, help=&apos;target image path&apos;, default=&apos;./authcode.png&apos;)</div><div class="line">parser.add_argument(&apos;-l&apos;, help=&apos;authcode length&apos;, default=4)</div><div class="line">parser.add_argument(&apos;-s&apos;, help=&apos;salt counts&apos;, default=200)</div><div class="line">args = parser.parse_args()</div><div class="line">fontImgPath = args.input</div><div class="line">fontWidth = int(args.fontwidth)</div><div class="line">fontHeight = int(args.fontheight)</div><div class="line">targetImgPath = args.o</div><div class="line">codeLength = int(args.l)</div><div class="line">saltNum = int(args.s)</div><div class="line">base = (&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,</div><div class="line">      &apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;,</div><div class="line">      &apos;K&apos;,&apos;L&apos;,&apos;M&apos;,&apos;N&apos;,&apos;O&apos;,&apos;P&apos;,&apos;Q&apos;,&apos;R&apos;,&apos;S&apos;,&apos;T&apos;,</div><div class="line">      &apos;U&apos;,&apos;V&apos;,&apos;W&apos;,&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;)</div></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>fontImgPath - 必选，字体图片路径</li>
<li>fontWidth - 必选，字体图片中字体宽度</li>
<li>fontHeight - 必选，字体图片中字体高度</li>
<li>targetImgPath - 可选，生成验证码存放路径，默认为当前路径，图片名 authcode.png</li>
<li>codeLength - 可选，生成验证码中字符数目，默认为 4 个字符</li>
<li>saltNum - 可选，生成验证码中椒盐现象数目，默认为 200</li>
<li>base - 字符集合，必须与字体图片素材中的顺序匹配</li>
</ul>
<h1 id="生成基本验证码图片"><a href="#生成基本验证码图片" class="headerlink" title="生成基本验证码图片"></a>生成基本验证码图片</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Generate Authcode Image</div><div class="line">def getAuthcode(base, fontImgPath, codeLength, fontWidth, fontHeight):</div><div class="line">    code = &apos;&apos;</div><div class="line">    fontImg = Image.open(fontImgPath)</div><div class="line">    codeImg = Image.new(&apos;RGBA&apos;, (fontWidth*codeLength, fontHeight+6), (255,255,255,0))</div><div class="line">    for k in range(codeLength):</div><div class="line">        randInt = random.randint(0,len(base)-1)</div><div class="line">        code = &apos;&apos;.join((code, base[randInt]))</div><div class="line">        img_s = fontImg.crop((randInt*fontWidth,0,(randInt+1)*fontWidth,fontHeight))</div><div class="line">        img_s = img_s.rotate(random.randint(-30,30))</div><div class="line">        codeImg.paste(img_s, (k*fontWidth,3))</div><div class="line">    return codeImg, code</div></pre></td></tr></table></figure>
<p>首先创建新的 RGBA 格式空白图片，其宽为字体宽度与验证码字符个数之积，高为字体高度+6px。依次随机选取字体集合中的一个字符，从字体素材图片中截取相应字符并旋转 -30° ~ 30°，粘贴到新建的图片中。最后将新建的图片与验证码字符串返回。</p>
<h1 id="干扰素"><a href="#干扰素" class="headerlink" title="干扰素"></a>干扰素</h1><h2 id="椒盐现象"><a href="#椒盐现象" class="headerlink" title="椒盐现象"></a>椒盐现象</h2><p>在指定图片中添加指定个数的干扰点，干扰点颜色随机，位置随机（但不能影响验证码字符）。图像操作直接改变原图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Add Salt</div><div class="line">def addSalt(image, saltNum):</div><div class="line">    width, height = image.size</div><div class="line">    count = 0</div><div class="line">    while count &lt; saltNum:</div><div class="line">        randX = random.randint(0, width-1)</div><div class="line">        randY = random.randint(0, height-1)</div><div class="line">        if image.getpixel((randX, randY))[-1] == 0:</div><div class="line">            image.putpixel((randX, randY), (random.randint(100,255), random.randint(100,255), random.randint(100,255), 255))</div><div class="line">            count += 1</div><div class="line">        else:</div><div class="line">            continue</div></pre></td></tr></table></figure>
<h2 id="干扰线"><a href="#干扰线" class="headerlink" title="干扰线"></a>干扰线</h2><p>在指定图片中添加 2 条位置随机的干扰线（数目可改变，但会影响用户体验）。此处在图片上半部分与下半部分各添加一条黑色干扰线，并带有一定倾斜度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">## Add Lines</div><div class="line">def addLines(image):</div><div class="line">    width, height = image.size</div><div class="line">    draw = ImageDraw.Draw(image)</div><div class="line">    for k in range(2):</div><div class="line">        randHeight = (height/2)*(k%2)+random.randint(5, (height-1)/2-5)</div><div class="line">        startPoint = (0, randHeight)</div><div class="line">        if random.random() &lt; 0.5:</div><div class="line">            endPoint = (width-1, randHeight+random.randint(0,5))</div><div class="line">        else:</div><div class="line">            endPoint = (width-1, randHeight-random.randint(0,5))</div><div class="line">        draw.line((startPoint, endPoint), fill=(0,0,0,255))</div><div class="line">    del draw</div></pre></td></tr></table></figure>
<h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">from PIL import Image, ImageDraw</div><div class="line">import random, argparse</div><div class="line"></div><div class="line"># Settings</div><div class="line">parser = argparse.ArgumentParser()</div><div class="line">parser.add_argument(&apos;input&apos;, help=&apos;font image source&apos;)</div><div class="line">parser.add_argument(&apos;fontwidth&apos;, help=&apos;width of the font&apos;)</div><div class="line">parser.add_argument(&apos;fontheight&apos;, help=&apos;height of the font&apos;)</div><div class="line">parser.add_argument(&apos;-o&apos;, help=&apos;target image path&apos;, default=&apos;./authcode.png&apos;)</div><div class="line">parser.add_argument(&apos;-l&apos;, help=&apos;authcode length&apos;, default=4)</div><div class="line">parser.add_argument(&apos;-s&apos;, help=&apos;salt counts&apos;, default=200)</div><div class="line">args = parser.parse_args()</div><div class="line">fontImgPath = args.input</div><div class="line">fontWidth = int(args.fontwidth)</div><div class="line">fontHeight = int(args.fontheight)</div><div class="line">targetImgPath = args.o</div><div class="line">codeLength = int(args.l)</div><div class="line">saltNum = int(args.s)</div><div class="line">base = (&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,</div><div class="line">      &apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;,</div><div class="line">      &apos;K&apos;,&apos;L&apos;,&apos;M&apos;,&apos;N&apos;,&apos;O&apos;,&apos;P&apos;,&apos;Q&apos;,&apos;R&apos;,&apos;S&apos;,&apos;T&apos;,</div><div class="line">      &apos;U&apos;,&apos;V&apos;,&apos;W&apos;,&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;)</div><div class="line"></div><div class="line"># Generate Authcode Image</div><div class="line">def getAuthcode(base, fontImgPath, codeLength, fontWidth, fontHeight):</div><div class="line">    code = &apos;&apos;</div><div class="line">    fontImg = Image.open(fontImgPath)</div><div class="line">    codeImg = Image.new(&apos;RGBA&apos;, (fontWidth*codeLength, fontHeight+6), (255,255,255,0))</div><div class="line">    for k in range(codeLength):</div><div class="line">        randInt = random.randint(0,len(base)-1)</div><div class="line">        code = &apos;&apos;.join((code, base[randInt]))</div><div class="line">        img_s = fontImg.crop((randInt*fontWidth,0,(randInt+1)*fontWidth,fontHeight))</div><div class="line">        img_s = img_s.rotate(random.randint(-30,30))</div><div class="line">        codeImg.paste(img_s, (k*fontWidth,3))</div><div class="line">    return codeImg, code</div><div class="line"></div><div class="line"># Add Salt</div><div class="line">def addSalt(image, saltNum):</div><div class="line">    width, height = image.size</div><div class="line">    count = 0</div><div class="line">    while count &lt; saltNum:</div><div class="line">        randX = random.randint(0, width-1)</div><div class="line">        randY = random.randint(0, height-1)</div><div class="line">        if image.getpixel((randX, randY))[-1] == 0:</div><div class="line">            image.putpixel((randX, randY), (random.randint(100,255), random.randint(100,255), random.randint(100,255), 255))</div><div class="line">            count += 1</div><div class="line">        else:</div><div class="line">            continue</div><div class="line"></div><div class="line">## Add Lines</div><div class="line">def addLines(image):</div><div class="line">    width, height = image.size</div><div class="line">    draw = ImageDraw.Draw(image)</div><div class="line">    for k in range(2):</div><div class="line">        randHeight = (height/2)*(k%2)+random.randint(5, (height-1)/2-5)</div><div class="line">        startPoint = (0, randHeight)</div><div class="line">        if random.random() &lt; 0.5:</div><div class="line">            endPoint = (width-1, randHeight+random.randint(0,5))</div><div class="line">        else:</div><div class="line">            endPoint = (width-1, randHeight-random.randint(0,5))</div><div class="line">        draw.line((startPoint, endPoint), fill=(0,0,0,255))</div><div class="line">    del draw</div><div class="line"></div><div class="line"># Main</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    authcode, code = getAuthcode(base, fontImgPath, codeLength, fontWidth, fontHeight)</div><div class="line">    addSalt(authcode, saltNum)</div><div class="line">    addLines(authcode)</div><div class="line">    authcode.save(targetImgPath, &apos;PNG&apos;)</div><div class="line">    print &apos;Generate Authcode: &apos;,code</div></pre></td></tr></table></figure>
<h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python generate_authcode.py font.png 19 20 -o authcode.png -l 4 -s 200</div></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Generate Authcode:  3PHU</div></pre></td></tr></table></figure>
<p>生成验证码图片：</p>
<p><img src="/images/authcode.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[socket网络通信——UNIX域套接字]]></title>
      <url>http://lizonghang.github.io/2016/07/26/socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94UNIX%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
      <content type="html"><![CDATA[<p>从程序员的角度来看，使用 UNIX 域套接字和 TCP/IP 套接字存在两个根本区别。首先，套接字的地址是文件系统上的一个路径，而不是一个包含服务器名和端口的元组。其次，文件系统中创建的表示套接字的节点会持久保存，即时套接字关闭也仍然存在，所以每次服务器启动时都需要将其删除。只需在设置部分做一些修改就可以把前面的回应服务器例子更新为使用 UDS。</p>
<h1 id="UNIX域套接字"><a href="#UNIX域套接字" class="headerlink" title="UNIX域套接字"></a>UNIX域套接字</h1><p>注意：sock 的创建已经从 <code>socket.AF_INET</code> 改变为 <code>socket.AF_UNIX</code>，并且服务器地址是文件系统中的一个节点。运行以下代码后，将会在指定位置创建一个 readonly 文件，文件类型为 socket 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">import os</div><div class="line"></div><div class="line">server_address = &apos;/Users/mac/Desktop/uds_socket&apos;</div><div class="line">try:</div><div class="line">    os.unlink(server_address)</div><div class="line">except OSError:</div><div class="line">    if os.path.exists(server_address)</div><div class="line">        raise</div><div class="line"></div><div class="line"># Create a UDS socket</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">print &apos;Starting up on %s&apos; % server_address</div><div class="line">sock.bind(server_address)</div><div class="line">sock.listen(1)</div><div class="line"></div><div class="line">while True:</div><div class="line">    print &apos;Waiting for a connection ...&apos;</div><div class="line">    connection, client_address = sock.accept()</div><div class="line">    try:</div><div class="line">        print &apos;Connection from &apos;, client_address</div><div class="line">        while True:</div><div class="line">            data = connection.recv(16)</div><div class="line">            print &apos;Received &quot;%s&quot;&apos; % data</div><div class="line">            if data:</div><div class="line">                print &apos;Sending data back to the client&apos;</div><div class="line">                connection.sendall(data)</div><div class="line">            else:</div><div class="line">                print &apos;No data from %s&apos; % server_address</div><div class="line">                break</div><div class="line">    finally:</div><div class="line">        connection.close()</div></pre></td></tr></table></figure>
<p>还需要修改客户设置来使用 UDS，要假设套接字的相应文件系统节点存在，因为服务器要通过绑定这个地址来创建套接字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">import sys</div><div class="line"></div><div class="line">sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</div><div class="line">server_address = &apos;/Users/mac/Desktop/uds_socket&apos;</div><div class="line"></div><div class="line">print &apos;Connecting to %s ...&apos; % server_address</div><div class="line">try:</div><div class="line">    sock.connect(server_address)</div><div class="line">except socket.error, msg:</div><div class="line">    print msg</div><div class="line">    sys.exit(1)</div><div class="line"></div><div class="line"># Send data</div><div class="line">try:</div><div class="line">    message = &apos;This is the message, it will be repeated.&apos;</div><div class="line">    print &apos;Sending &quot;%s&quot;&apos; % message</div><div class="line">    sock.sendall(message)</div><div class="line">    amount_received = 0</div><div class="line">    amount_expected = len(message)</div><div class="line">    while amount_received &lt; amount_expected:</div><div class="line">        data = sock.recv(16)</div><div class="line">        amount_received += len(data)</div><div class="line">        print &apos;Received &quot;%s&quot;&apos; % data</div><div class="line">finally:</div><div class="line">    sock.close()</div></pre></td></tr></table></figure>
<p>程序输出基本上相同，但对地址信息有适当的更新。服务器显示接收的消息并发回给客户端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Starting up on /Users/mac/Desktop/uds_socket</div><div class="line">Waiting for a connection ...</div><div class="line">Connection from</div><div class="line">Received &quot;This is the mess&quot;</div><div class="line">Sending data back to the client</div><div class="line">Received &quot;age, it will be &quot;</div><div class="line">Sending data back to the client</div><div class="line">Received &quot;repeated.&quot;</div><div class="line">Sending data back to the client</div><div class="line">Received &quot;&quot;</div><div class="line">No data from /Users/mac/Desktop/uds_socket</div><div class="line">Waiting for a connection ...</div></pre></td></tr></table></figure>
<p>客户端采用增量方式逐部分接收消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Connecting to /Users/mac/Desktop/uds_socket ...</div><div class="line">Sending &quot;This is the message, it will be repeated.&quot;</div><div class="line">Received &quot;This is the mess&quot;</div><div class="line">Received &quot;age, it will be &quot;</div><div class="line">Received &quot;repeated.&quot;</div></pre></td></tr></table></figure>
<h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><p>由于 UDS 套接字由文件系统上的一个节点表示，所以可以使用标准文件系统权限来控制对服务器的访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls -l /Users/mac/Desktop/uds_socket</div><div class="line">srwxr-xr-x  1 Hang  staff  0  7 26 21:35 /Users/mac/Desktop/uds_socket</div></pre></td></tr></table></figure>
<p>如果客户作为一个用户运行而不是作为 root，则会导致一个错误，因为进程没有打开套接字的权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ python server.py</div><div class="line">Connecting to /Users/mac/Desktop/uds_socket</div><div class="line">[Errno 13] Permission denied</div></pre></td></tr></table></figure>
<h1 id="父进程与子进程通信"><a href="#父进程与子进程通信" class="headerlink" title="父进程与子进程通信"></a>父进程与子进程通信</h1><p>在 Unix 下，<code>socketpair()</code> 函数对于建立 UDS 套接字完成进程间通信很有用。它会创建一对连接的套接字，在创建子进程之后，可以用来在父进程和子进程之间通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">import os</div><div class="line"></div><div class="line">parent, child = socket.socketpair()</div><div class="line">pid = os.fork()</div><div class="line">if pid:</div><div class="line">    print &apos;In parent, sending message&apos;</div><div class="line">    child.close()</div><div class="line">    parent.sendall(&apos;message from parent&apos;)</div><div class="line">    response = parent.recv(1024)</div><div class="line">    print &apos;Response from child: &apos;, response</div><div class="line">    parent.close()</div><div class="line">else:</div><div class="line">    print &apos;In child, waiting for message&apos;</div><div class="line">    parent.close()</div><div class="line">    message = child.recv(1024)</div><div class="line">    print &apos;Message from parent: &apos;, message</div><div class="line">    child.sendall(&apos;message from child&apos;)</div><div class="line">    child.close()</div></pre></td></tr></table></figure>
<p>默认地会创建一个 UDS 套接字，不过调用者还可以传递地址簇、套接字类型，甚至协议选项来控制如何创建套接字。</p>
<p>运行输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">In parent, sending message</div><div class="line">In child, waiting for message</div><div class="line">Message from parent:  message from parent</div><div class="line">Response from child:  message from child</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 网络通信 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[socket网络通信——UDP客户和服务器]]></title>
      <url>http://lizonghang.github.io/2016/07/26/socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94UDP%E5%AE%A2%E6%88%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>用户数据报协议（user datagram protocol，UDP）的工作方式与 TCP/IP 不同。TCP 是一个面向流（stream-oriented）的协议，确保所有数据以正确的顺序传输。UDP 是一个面向消息（message-oriented）的协议。UDP 不需要一个长期活动的连接，所以建立 UDP 套接字要简单些。另一方面，UDP 消息必须放在一个数据包中（对于IPv4，意味着它们可以包含 65507 字节，因为 65535 字节大小的数据包还包括首部信息），而且无法得到 TCP 提供的传输保障。</p>
<h1 id="回应服务器"><a href="#回应服务器" class="headerlink" title="回应服务器"></a>回应服务器</h1><p>由于实际上并没有连接，服务器不需要监听和接受连接。它只需要使用 <code>bind()</code> 将其套接字与一个端口关联，然后等待各个消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"># Create a UDP socket</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</div><div class="line"># Bind the socket to the port</div><div class="line">sock.bind((&apos;localhost&apos;, 10000))</div></pre></td></tr></table></figure>
<p>使用 <code>recvfrom()</code> 从套接字读取消息，这个函数会返回数据，还会返回发出这个数据的客户地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">while True:</div><div class="line">    print &apos;Waiting to receive message ...&apos;</div><div class="line">    data, address = sock.recvfrom(4096)</div><div class="line">    print &apos;Received %s bytes from %s&apos; % (len(data), address)</div><div class="line">    print &apos;Data: &apos;, data</div><div class="line">    if data:</div><div class="line">        sent = sock.sendto(data, address)</div><div class="line">        print &apos;sent data &quot;%s&quot; back to %s&apos; % (data, address)</div></pre></td></tr></table></figure>
<h1 id="回应客户"><a href="#回应客户" class="headerlink" title="回应客户"></a>回应客户</h1><p>UDP 回应客户与服务器类似，但是不使用 <code>bind()</code> 将套接字关联到一个地址。它使用 <code>sendto()</code> 将消息直接传送到服务器，并使用 <code>recvfrom()</code> 接收响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"># Create a UDP socket</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</div><div class="line">message = &apos;This is the message, it will be repeat later.&apos;</div><div class="line">try:</div><div class="line">    print &apos;Send message: &apos;, message</div><div class="line">    sent = sock.sendto(message, (&apos;localhost&apos;, 10000))</div><div class="line">    print &apos;Waiting to receive callback message ...&apos;</div><div class="line">    data, server = sock.recvfrom(4096)</div><div class="line">    print &apos;Received callback message: &apos;, data</div><div class="line">finally:</div><div class="line">    sock.close()</div><div class="line">    print &apos;Socket closed&apos;</div></pre></td></tr></table></figure>
<h1 id="客户与服务器"><a href="#客户与服务器" class="headerlink" title="客户与服务器"></a>客户与服务器</h1><p>运行这个服务器将会生成以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Waiting to receive message ...</div><div class="line">Received 45 bytes from (&apos;127.0.0.1&apos;, 60844)</div><div class="line">Data:  This is the message, it will be repeat later.</div><div class="line">sent data &quot;This is the message, it will be repeat later.&quot; back to (&apos;127.0.0.1&apos;, 60844)</div><div class="line">Waiting to receive message ...</div></pre></td></tr></table></figure>
<p>客户端输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Send message:  This is the message, it will be repeat later.</div><div class="line">Waiting to receive callback message ...</div><div class="line">Received callback message:  This is the message, it will be repeat later.</div><div class="line">Socket closed</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 网络通信 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[轮廓检测]]></title>
      <url>http://lizonghang.github.io/2016/07/25/%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B/</url>
      <content type="html"><![CDATA[<h1 id="轮廓检测"><a href="#轮廓检测" class="headerlink" title="轮廓检测"></a>轮廓检测</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">im = cv2.imread(&apos;star.png&apos;)</div><div class="line">im = im.copy()</div><div class="line">gray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</div><div class="line">ret, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)</div><div class="line">contours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</div><div class="line">cv2.drawContours(im, contours, -1, (0,0,255), 3)</div><div class="line">cv2.imshow(&apos;img&apos;, im)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>需要注意的是 <code>cv2.findContours()</code> 函数接受的参数为二值图，所以读取的图像要先转成灰度图，再转成二值图。</p>
<p>原图：</p>
<p><img src="/images/star.png" alt=""></p>
<p>检测结果：</p>
<p><img src="/images/star-edge.jpg" alt=""></p>
<p>注意，<code>cv2.findContours()</code> 函数会修改输入的图像。</p>
<h1 id="cv2-findContours"><a href="#cv2-findContours" class="headerlink" title="cv2.findContours()"></a>cv2.findContours()</h1><p>函数原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">contours, hierarchy = cv2.findContours(image, mode, method[, contours[, hierarchy[, offset]]])</div></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>image - 输入图像</li>
<li>mode - 轮廓的检索模式。<code>cv2.RETR_EXTERNAL</code> 只检测外轮廓；<code>RETR_LIST</code> 检测的轮廓不建立等级关系；<code>RETR_CCOMP</code> 建立两个等级的轮廓，上一层为外边界，内层为内孔的边界。如果内孔内还有连通物体，则这个物体的边界也在顶层；<code>RETR_TREE</code> 建立一个等级树结构的轮廓。</li>
<li>method - 轮廓的近似办法。<code>cv2.CHAIN_APPROX_NONE</code> 存储所有的轮廓点，相邻的两个点的像素位置差不超过 1 ，即 max(abs(x1-x2), abs(y1-y2)) == 1；<code>cv2.CHAIN_APPROX_SIMP</code> 压缩水平方向、垂直方向、对角线方向的元素，只保留该方向的终点坐标。例如一个矩形轮廓只需要 4 个点来保存轮廓信息；<code> cv2.CHAIN_APPROX_TC89_L1</code>，CV_CHAIN_APPROX_TC89_KCOS 使用 teh-Chinl chain 近似算法。</li>
<li>contours - 返回的轮廓</li>
<li>hierarchy - 每条轮廓对应的属性</li>
</ul>
<h2 id="返回值contour"><a href="#返回值contour" class="headerlink" title="返回值contour"></a>返回值contour</h2><p><code>cv2.findContours()</code> 函数首先返回一个 list，list 中每个元素都是图像中的一个轮廓，用 numpy 中的 ndarray 表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print type(contours)</div><div class="line">print type(contours[0])</div><div class="line">print len(contours)</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;type &apos;list&apos;&gt;</div><div class="line">&lt;type &apos;numpy.ndarray&apos;&gt;</div><div class="line">2</div></pre></td></tr></table></figure>
<p>可以验证上述信息。可以看到本例中有两条轮廓，一个是五角星的，一个是矩形的。每个轮廓是一个 ndarray，每个 ndarray 是轮廓上的点的集合。</p>
<p>由于知道返回的轮廓有两个，因此可以通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cv2.drawContours(im, contours, 0, (0,0,255), 3)</div><div class="line">cv2.drawContours(im, contours, 1, (0,255,0), 3)</div></pre></td></tr></table></figure>
<p>分别绘制两个轮廓。同时使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print len(contours[0])</div><div class="line">print len(contours[1])</div></pre></td></tr></table></figure>
<p>输出两个轮廓中存储的点的个数。可见五角星只有 5 个元素，这是因为轮廓中并不是存储轮廓上所有点，而是只存储可以用直线描述轮廓的点的个数，比如一个矩形只需要 4 个顶点就可以描述轮廓。</p>
<h2 id="返回值hierarchy"><a href="#返回值hierarchy" class="headerlink" title="返回值hierarchy"></a>返回值hierarchy</h2><p>该函数还返回一个可选的 hierarchy 结果，这是一个 ndarray，其中元素个数和轮廓个数相同，每个轮廓 <code>contours[i]</code> 对应 4 个 hierarchy 元素 <code>hierarchy[i][0] ~ hierarchy[i][3]</code>，分别表示后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号，如果没有对应项，则该值为负数。通过如下查看各属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print type(hierarchy)</div><div class="line">print hierarchy.ndim</div><div class="line">print hierarchy[0].ndim</div><div class="line">print hierarchy.shape</div></pre></td></tr></table></figure>
<h1 id="轮廓的绘制"><a href="#轮廓的绘制" class="headerlink" title="轮廓的绘制"></a>轮廓的绘制</h1><p>OpenCV 通过 <code>cv2.drawContours()</code> 在图像上绘制轮廓。函数原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset ]]]]])</div></pre></td></tr></table></figure>
<ul>
<li>image - 在选定的图像上绘制轮廓</li>
<li>contours - 轮廓本身，是一个 list</li>
<li>contourIdx - 指定绘制哪条轮廓，如果为 -1 则绘制所有轮廓</li>
<li>后续参数比较显而易见，其中 thickness 表明轮廓线宽度，如果为 -1 （<code>cv2.FILLED</code>），则为填充模式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cv2.drawContours(im, contours, -1, (0,0,255), 2)</div><div class="line">cv2.imshow(&apos;image&apos;, im)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[霍夫变换检测直线]]></title>
      <url>http://lizonghang.github.io/2016/07/25/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E6%A3%80%E6%B5%8B%E7%9B%B4%E7%BA%BF/</url>
      <content type="html"><![CDATA[<h1 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h1><p>Hough 变换是经典的检测直线的算法，最初用来检测图像中的直线，也可以将其扩展，以检测图像中简单的结构。</p>
<p>OpenCV 提供了两种用于直线检测的 Hough 变换形式，其中基本的版本是 <code>cv2.HoughLines()</code>。输入一幅含有点集的二值图，其中一些点相互联系组成直线。通常这是通过如 Canny 算子获得的一幅边缘图像。<code>cv2.HoughLines()</code> 函数输出 <code>[float, float]</code> 形式的 ndarray，其中每个值表示检测到的线(ρ , θ)中浮点点值的参数。下面的例子先用 Canny 算子获得图像边缘，然后使用 Hough 变换检测直线。其中 <code>cv2.HoughLines()</code> 函数的参数3和4对应直线搜索的步长。在本例中，函数将通过步长为 1 的半径和步长为 π/180 的角来搜索所有可能的直线。最后一个参数是经过某一点曲线的数量的阈值，超过这个阈值就表示这个交点所代表的参数对 (ρ , θ) 在原图像为一条直线。</p>
<p>示例图像如下：</p>
<p><img src="/images/street.jpg" alt=""></p>
<p>直线检测代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;street.jpg&apos;)</div><div class="line">im = cv2.GaussianBlur(im, (3,3), 0)</div><div class="line">edges = cv2.Canny(im, 50, 150, apertureSize=3)</div><div class="line">lines = cv2.HoughLines(edges, 1, np.pi/180, 260)</div><div class="line">result = im.copy()</div><div class="line">for line in lines[0]:</div><div class="line">    rho = line[0]</div><div class="line">    theta= line[1]</div><div class="line">    if  (theta &lt; (np.pi/4. )) or (theta &gt; (3.*np.pi/4.0)):</div><div class="line">        pt1 = (int(rho/np.cos(theta)),0)</div><div class="line">        pt2 = (int((rho-result.shape[0]*np.sin(theta))/np.cos(theta)),result.shape[0])</div><div class="line">        cv2.line( result, pt1, pt2, (0,0,255))</div><div class="line">    else:</div><div class="line">        pt1 = (0,int(rho/np.sin(theta)))</div><div class="line">        pt2 = (result.shape[1], int((rho-result.shape[1]*np.cos(theta))/np.sin(theta)))</div><div class="line">        cv2.line(result, pt1, pt2, (0,0,255), 1)</div><div class="line"></div><div class="line">cv2.imshow(&apos;Hough&apos;, result)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/images/hough.jpg" alt=""></p>
<h1 id="概率霍夫变换"><a href="#概率霍夫变换" class="headerlink" title="概率霍夫变换"></a>概率霍夫变换</h1><p>前面例子得到的结果图片，其中 Hough 变换看起来就像在图像中查找对齐的边界像素点集合，但这样会在一些情况下导致虚假检测，如像素偶然对齐或多条直线穿过同样的对齐像素造成的多重检测。</p>
<p>要避免这样的问题，并检测图像中分段的直线（而不是贯穿整个图像的直线），就出现了概率 Hough 变换。在 OpenCV 中用函数 <code>cv2.HoughLinesP()</code> 实现。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;street.jpg&apos;)</div><div class="line">im = cv2.GaussianBlur(im, (3,3), 0)</div><div class="line">edges = cv2.Canny(im, 50, 150, apertureSize=3)</div><div class="line">result = im.copy()</div><div class="line">minLineLength = 100</div><div class="line">maxLineGap = 50</div><div class="line">lines = cv2.HoughLinesP(edges, 1, np.pi/180, 200, minLineLength, maxLineGap)</div><div class="line">for x1,y1,x2,y2 in lines[0]:</div><div class="line">    cv2.line(result, (x1,y1), (x2,y2), (0,0,255), 2)</div><div class="line"></div><div class="line">cv2.imshow(&apos;HoughP&apos;, result)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/images/houghP.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Laplacian算子]]></title>
      <url>http://lizonghang.github.io/2016/07/25/Laplacian%E7%AE%97%E5%AD%90/</url>
      <content type="html"><![CDATA[<p>图像中的边缘区域像素值会发生“跳跃”，对这些像素求导，其一阶导数在边缘位置为极值，这是 Sobel 算子的原理。如果对像素值求二阶导数，会发现边缘处的二阶导数值为 0 。Laplace 函数实现的方法是先用 Sobel 算子计算二阶 x 和 y 导数，再求和：</p>
<p><img src="/images/laplace_arg.jpg" alt=""></p>
<p>在 OpenCV-Python 中，Laplace 算子的函数原型如下，和 Sobel 算子中的参数基本一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.Laplacian(src, ddepth[, dst[, ksize[, scale[, delta[, borderType]]]]])</div></pre></td></tr></table></figure>
<p>测试图像：</p>
<p><img src="/images/tower.jpg" alt=""></p>
<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;tower.jpg&apos;)</div><div class="line">gray_lap = cv2.Laplacian(im, cv2.CV_16S, ksize=3)</div><div class="line">dst = cv2.convertScaleAbs(gray_lap)</div><div class="line"></div><div class="line">cv2.imshow(&apos;laplacian&apos;, dst)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/tower-lap.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Sobel算子]]></title>
      <url>http://lizonghang.github.io/2016/07/24/Sobel%E7%AE%97%E5%AD%90/</url>
      <content type="html"><![CDATA[<p>Sobel 算子是一种过滤器，但它带有方向。在 OpenCV-Python 中，使用 Sobel 算子的函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.Sobel(src, ddepth, dx, dy[, dst[, ksize[, scale[, delta[, borderType]]]]])</div></pre></td></tr></table></figure>
<p>必选参数：</p>
<ul>
<li>src - 需要处理的图像。</li>
<li>ddepth - 图像深度。-1 表示采用与原图像相同的深度。目标图像深度≥原图像深度。</li>
<li>dx, dy - 求导阶数，0 表示不求导。</li>
</ul>
<p>可选参数：</p>
<ul>
<li>ksize - Sobel 算子大小，必须为 1、3、5、7。</li>
<li>scale - 缩放导数的比例常数，默认情况下不伸缩。</li>
<li>delta - 可选增量，会加到最终 dst 中，默认情况下不额外增加。</li>
<li>borderType - 判断图像边界的模式。默认值为 <code>cv2.BORDER_DEFAULT。</code></li>
</ul>
<p>Sobel 函数使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lion.jpg&apos;)</div><div class="line">im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</div><div class="line"></div><div class="line">x = cv2.Sobel(im, cv2.CV_16S, 1, 0)</div><div class="line">y = cv2.Sobel(im, cv2.CV_16S, 0, 1)</div><div class="line"></div><div class="line">absX = cv2.convertScaleAbs(x)</div><div class="line">absY = cv2.convertScaleAbs(y)</div><div class="line"></div><div class="line">dst = cv2.addWeighted(absX, 0.5, absY, 0.5, 0)</div><div class="line"></div><div class="line">cv2.imshow(&apos;origin&apos;, im)</div><div class="line">cv2.imshow(&quot;absX&quot;, absX)</div><div class="line">cv2.imshow(&quot;absY&quot;, absY)</div><div class="line">cv2.imshow(&quot;Result&quot;, dst)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>由于 Sobel 函数求导数后会有负值，还会有大于 255 的值，而原图像是 uint8 ，所以 Sobel 建立的图像位数不够，会有截断。因此要使用 16 位有符号的数据类型，即 <code>cv2.CV_16S</code>。</p>
<p>处理后要用 <code>cv2.convertScaleAbs()</code> 将其转回原来的 uint8 形式，否则无法显示图像。 <code>cv2.convertScaleAbs()</code> 的原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.convertScaleAbs(src[, dst[, alpha[, beta]]])</div></pre></td></tr></table></figure>
<p>其中可选参数 <code>alpha</code> 是伸缩系数， <code>beta</code> 是加到结果上的一个值。结果返回 uint8 类型的图片。</p>
<p>由于 Sobel 算子是在两个方向计算的，最后要使用 <code>cv2.addWeighted()</code> 函数将其组合起来。函数原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.addWeighted(src1, alpha, src2, beta, gamma[, dst[, dtype]])</div></pre></td></tr></table></figure>
<p>其中 <code>alpha</code> 是第一幅图片中元素的权重， <code>beta</code> 是第二个图片中元素的权重， <code>gamma</code> 是加到最后结果上的一个值。</p>
<p>原图：</p>
<p><img src="/images/lion.jpg" alt=""></p>
<p>absX：</p>
<p><img src="/images/absX.jpg" alt=""></p>
<p>absY：</p>
<p><img src="/images/absY.jpg" alt=""></p>
<p>Result：</p>
<p><img src="/images/sobel.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[滤波]]></title>
      <url>http://lizonghang.github.io/2016/07/24/%E6%BB%A4%E6%B3%A2/</url>
      <content type="html"><![CDATA[<h1 id="滤波简介"><a href="#滤波简介" class="headerlink" title="滤波简介"></a>滤波简介</h1><p>过滤是信号和图像处理中基本的任务，目的是根据应用环境的不同，选择性的提取图像中某些认为重要的信号。过滤可以移除图像中的噪音、提取感兴趣的可视特征、允许图像重采样等等。</p>
<p>当观察一张图片时，我们观察的是图像中有多少灰度级（或颜色）及其分布。根据灰度分布的不同来区分不同的图像。也有其他方面可以对图像进行分析，例如观察图像中灰度的变化。某些图像中包含大量强度不变的区域（如蓝天），而在其他图像中的灰度变化可能会非常快（如包含许多小物体的拥挤的图像）。因此，观察图像中这些变化的频率就构成了另一条分类图像的方法，这个观点称为频域。而通过观察图像灰度分布来分类图像称为空间域。</p>
<p>频域分析将图像分成从低频到高频的不同部分。低频对应图像强度变化小的区域，而高频是图像强度变化非常大的区域。目前存在若干种转换方法，如傅里叶变换或余弦变换，可以用来清晰地显示图像的频率。由于图像是一个二维实体，所以其频率由水平频率和竖直频率共同组成。</p>
<p>在频率分析领域的框架中，滤波器是一个用来增强图像中某个波段或频率并阻塞（或降低）其他频率波段的操作。低通滤波器是消除图像中的高频部分，保留低频部分。高通滤波器消除低频部分，保留高频部分。</p>
<p>这里只介绍在 OpenCV-Python 中实现的初级滤波操作，之后介绍更复杂的滤波原理及实现。</p>
<p>以下图为例：</p>
<p><img src="/images/lena.jpg" alt=""></p>
<h1 id="低通滤波平滑图像"><a href="#低通滤波平滑图像" class="headerlink" title="低通滤波平滑图像"></a>低通滤波平滑图像</h1><h2 id="初级低通滤波"><a href="#初级低通滤波" class="headerlink" title="初级低通滤波"></a>初级低通滤波</h2><p>低通滤波器的目标是降低图像的变化率。如将每个像素替换为该像素周围像素的均值，这样就可以平滑并替代那些强度变化明显的区域。在 OpenCV 中可以通过 <code>cv2.blur()</code> 来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.blur(im, (5,5))</div></pre></td></tr></table></figure>
<p>其中 <code>dst</code> 是函数处理后返回的图像，第一个参数是待处理图像，第二个参数是低通滤波器的大小。其后含有几个可选参数用来设置滤波器的细节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">blured = cv2.blur(im, (5,5))</div><div class="line"></div><div class="line">cv2.namedWindow(&apos;Origin&apos;, cv2.WINDOW_NORMAL)</div><div class="line">cv2.namedWindow(&apos;Blur&apos;, cv2.WINDOW_NORMAL)</div><div class="line">cv2.imshow(&apos;Origin&apos;, im)</div><div class="line">cv2.imshow(&apos;Blur&apos;, blured)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/blur.png" alt=""></p>
<p>这种滤波器又称为 boxfilter，所以也可使用 <code>cv2.boxFilter()</code> 完成相同的工作。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.boxFilter(im, -1, (5,5))</div></pre></td></tr></table></figure>
<p>该函数与 <code>cv2.blur()</code> 效果完全相同，第二个参数 -1 表示输出图像使用的深度与输入图像相同。</p>
<h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><p>在某些情况下需要对一个像素的周围像素给予更多的重视。因此可用分配权重来重新计算这些周围点的值，可以通过高斯函数的权重方案来解决。<code>cv2.GaussianBlur()</code> 可作为滤波器，用以下方式调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.GaussianBlur(im, (5,5), 1.5)</div></pre></td></tr></table></figure>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>低通滤波与高斯滤波不同之处在于：低通滤波中，滤波器中每个像素的权重是相同的，即滤波器是线性的。而高斯滤波器中像素的权重与其距中心像素的距离成比例。</p>
<h1 id="中值滤波消除噪点"><a href="#中值滤波消除噪点" class="headerlink" title="中值滤波消除噪点"></a>中值滤波消除噪点</h1><p>中值滤波器对于消除椒盐现象很有用。调用方法与调用其他滤波器类似，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.medianBlur(im, 5)</div></pre></td></tr></table></figure>
<p>函数返回处理结果，第一个参数是待处理图像，第二个参数是孔径尺寸，是一个大于 1 的奇数。比如上面就会使用 5x5 领域组成一个数值集，对其进行处理，当前像素被均值替换。</p>
<p>若在某个像素周围有白色或黑色的像素，这些白色或黑色的像素不会选择作为中值（最大或最小值排除），而是被替换为领域值。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;saltImg.jpg&apos;)</div><div class="line">median = cv2.medianBlur(im, 5)</div><div class="line"></div><div class="line">cv2.namedWindow(&apos;Salt&apos;, cv2.WINDOW_NORMAL)</div><div class="line">cv2.namedWindow(&apos;Median&apos;, cv2.WINDOW_NORMAL)</div><div class="line">cv2.imshow(&apos;Salt&apos;, im)</div><div class="line">cv2.imshow(&apos;Median&apos;, median)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindow()</div></pre></td></tr></table></figure>
<p>处理结果如下：</p>
<p><img src="/images/median.png" alt=""></p>
<p>由于中值滤波不会处理最大和最小值，所以不会受噪声影响。相反，如果直接采用 <code>cv2.blur()</code> 进行均值滤波，则不会区分这些噪声点，滤波后的图像会受到噪声的影响。</p>
<p>中值滤波器在处理边缘也有优势，但中值滤波器会清除掉某些区域的纹理，如头发纹理。</p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[形态学处理]]></title>
      <url>http://lizonghang.github.io/2016/07/23/%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="定义结构元素"><a href="#定义结构元素" class="headerlink" title="定义结构元素"></a>定义结构元素</h1><p>形态学处理核心是定义结构元素，在 OpenCV-Python 中，可以使用其自带的 <code>getStructuringElement</code> 函数，也可以直接使用 NumPy 的 <code>ndarray</code> 来定义一个结构元素。首先看用 <code>getStructuringElement</code> 函数定义的结构元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element = cv2.getStructuringElement(cv2.MORPH_CROSS, (5,5))</div></pre></td></tr></table></figure>
<p>这就定义了一个 5x5 的十字形结构元素，如下：</p>
<p><img src="/images/cross.jpg" alt=""></p>
<p>也可以用 NumPy 定义结构元素，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NpKernel = numpy.uint8(numpy.zeros((5,5)))</div><div class="line">for i in range(5):</div><div class="line">    NpKernel[2, i] = 1</div><div class="line">    NpKernel[i, 2] = 1</div></pre></td></tr></table></figure>
<p>两者定义的结构元素完全一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print element</div><div class="line">[[0 0 1 0 0]</div><div class="line"> [0 0 1 0 0]</div><div class="line"> [1 1 1 1 1]</div><div class="line"> [0 0 1 0 0]</div><div class="line"> [0 0 1 0 0]]</div><div class="line">&gt;&gt;&gt; print NpKernel</div><div class="line">[[0 0 1 0 0]</div><div class="line"> [0 0 1 0 0]</div><div class="line"> [1 1 1 1 1]</div><div class="line"> [0 0 1 0 0]</div><div class="line"> [0 0 1 0 0]]</div></pre></td></tr></table></figure>
<p>用 OpenCV-Python 内置的常量定义椭圆（MORPH_ELLIPSE）和十字形结构（MORPH_CROSS）元素要简单一些，如果定义矩形（MORPH_RECT）和自定义结构元素，则用两者差不多。</p>
<p>测试图片：</p>
<p><img src="/images/origin.jpg" alt=""></p>
<h1 id="腐蚀和膨胀"><a href="#腐蚀和膨胀" class="headerlink" title="腐蚀和膨胀"></a>腐蚀和膨胀</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># encoding: utf-8</div><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;origin.jpg&apos;)</div><div class="line"># OpenCV定义结构元素</div><div class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))</div><div class="line"></div><div class="line"># 腐蚀图像</div><div class="line">eroded = cv2.erode(im, kernel)</div><div class="line">cv2.imshow(&apos;Eroded Image&apos;, eroded)</div><div class="line"></div><div class="line"># 膨胀图像</div><div class="line">dilated = cv2.dilate(im, kernel)</div><div class="line">cv2.imshow(&apos;Dilated Image&apos;, dilated)</div><div class="line"></div><div class="line"># 原图像</div><div class="line">cv2.imshow(&apos;Origin Image&apos;, im)</div><div class="line"></div><div class="line"># NumPy定义结构元素</div><div class="line">NpKernel = np.uint8(np.ones((3,3)))</div><div class="line"></div><div class="line"># 腐蚀图像</div><div class="line">Nperoded = cv2.erode(im, NpKernel)</div><div class="line">cv2.imshow(&apos;Eroded by NumPy kernel&apos;, Nperoded)</div><div class="line"></div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>腐蚀和膨胀的处理很简单，只需要设置好结构元素，然后分别调用 <code>cv2.erode()</code> 和 <code>cv2.dilate()</code> 函数即可。其中第一个参数是需要处理的图像，第二个参数是结构元素。函数返回处理后的图像。</p>
<p>结果如下：</p>
<p><img src="/images/erode-dilate.jpg" alt=""></p>
<h1 id="开运算和闭运算"><a href="#开运算和闭运算" class="headerlink" title="开运算和闭运算"></a>开运算和闭运算</h1><p>开运算和闭运算时将腐蚀和膨胀按照一定的次序进行处理，但这两者不可逆，即进行开运算后进行闭运算不能得到原来的图像。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># encoding: utf-8</div><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;origin.jpg&apos;)</div><div class="line"># OpenCV定义结构元素</div><div class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5))</div><div class="line"></div><div class="line"># 闭运算</div><div class="line">closed = cv2.morphologyEx(im, cv2.MORPH_CLOSE, kernel)</div><div class="line">cv2.imshow(&apos;Close&apos;, closed)</div><div class="line"></div><div class="line"># 开运算</div><div class="line">opened = cv2.morphologyEx(im, cv2.MORPH_OPEN, kernel)</div><div class="line">cv2.imshow(&apos;Open&apos;, opened)</div><div class="line"></div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>闭运算用来连接被误分为许多小块的对象，而开运算用于移除由图像噪音形成的斑点。因此，某些情况下可以连续运用这两种运算。如对一幅二值图连续使用闭运算和开运算，将获得图像中的主要对象。同样，如果想要消除图像中的噪声，也可以对图像先用开运算后用闭运算，不过这样也会消除一些破碎的对象。</p>
<p>对原始图像分别进行开运算和闭运算的结果如下：</p>
<p><img src="/images/open.jpg" alt=""><br><img src="/images/close.jpg" alt=""></p>
<h1 id="用形态学运算检测边和角点"><a href="#用形态学运算检测边和角点" class="headerlink" title="用形态学运算检测边和角点"></a>用形态学运算检测边和角点</h1><p>仅作为介绍形态学处理的例子，实际使用时建议使用 Canny 或 Harris 等算法</p>
<h2 id="检测边缘"><a href="#检测边缘" class="headerlink" title="检测边缘"></a>检测边缘</h2><p>形态学检测边缘的原理为：在膨胀时图像中的物体会想向周围扩张；腐蚀时图像中的物体会收缩。比较这两幅图像，由于其变化的区域只发生在边缘，所以将两幅图像相减，得到的就是图像中物体的边缘。</p>
<p>以下图为例：</p>
<p><img src="/images/lampo.jpg" alt=""></p>
<p>边缘检测代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#encoding: utf-8</div><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lampo.jpg&apos;)</div><div class="line"># 转换颜色模式为灰度图</div><div class="line">im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</div><div class="line"># OpenCV 3x3结构元素</div><div class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))</div><div class="line"># 膨胀图像</div><div class="line">dilated = cv2.dilate(im, kernel)</div><div class="line"># 腐蚀图像</div><div class="line">eroded = cv2.erode(im, kernel)</div><div class="line"># 两幅图像相减得到边缘，第一个参数是膨胀图像，第二个参数是腐蚀图像</div><div class="line">edges = cv2.absdiff(dilated, eroded)</div><div class="line"># edges是灰度图，二值化处理以更清楚观察结果</div><div class="line">retval, edges = cv2.threshold(edges, 50, 100, cv2.THRESH_BINARY)</div><div class="line"># 反转颜色</div><div class="line">edges = cv2.bitwise_not(edges)</div><div class="line"></div><div class="line">cv2.imshow(&apos;origin&apos;, im)</div><div class="line">cv2.imshow(&apos;edges&apos;, edges)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/lampo-edge.jpg" alt=""></p>
<h2 id="检测拐角"><a href="#检测拐角" class="headerlink" title="检测拐角"></a>检测拐角</h2><p>拐角检测与边缘检测的原理相同，不同的是先用十字形的结构元素膨胀像素，这种情况下图像中只会在边缘处扩张，而角点不发生变化。接着用菱形的结构元素腐蚀原图像，导致只有在拐角处才会收缩，而直线边缘都未发生变化。第二步是用 X 形膨胀原图像，角点膨胀比边要多。这样第二次用方块腐蚀时，角点恢复原状，而边要腐蚀得更多。所以当两幅图像相减时，只保留了拐角处。</p>
<p>以下图为例：</p>
<p><img src="/images/building.jpg" alt=""></p>
<p>拐角检测代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#encoding: utf-8</div><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;building.jpg&apos;)</div><div class="line"># 转换颜色模式为灰度图</div><div class="line">im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</div><div class="line"># 构造 5x5 的结构元素，分别为十字形、菱形、方形和X形</div><div class="line">cross = cv2.getStructuringElement(cv2.MORPH_CROSS, (5,5))</div><div class="line">diamond = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5))</div><div class="line">diamond[0,0], diamond[0,1], diamond[1,0], diamond[4,4], diamond[4,3], diamond[3,4], diamond[4,0], diamond[4,1], diamond[3,0], diamond[0,3], diamond[0,4], diamond[1,4] = 0,0,0,0,0,0,0,0,0,0,0,0</div><div class="line">square = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5))</div><div class="line">x = cv2.getStructuringElement(cv2.MORPH_CROSS, (5,5))</div><div class="line"># 使用十字形结构元素膨胀图像</div><div class="line">detect1 = cv2.dilate(im, cross)</div><div class="line"># 使用菱形结构元素腐蚀图像</div><div class="line">detect1 = cv2.erode(detect1, diamond)</div><div class="line"># 使用X结构元素膨胀图像</div><div class="line">detect2 = cv2.dilate(im, x)</div><div class="line"># 使用方形结构元素腐蚀图像</div><div class="line">detect2 = cv2.erode(detect2, square)</div><div class="line"># 将两幅图像相减获得角</div><div class="line">horn = cv2.absdiff(detect2, detect1)</div><div class="line"># 使用阈值获得二值图</div><div class="line">retval, horn = cv2.threshold(horn, 40, 255, cv2.THRESH_BINARY)</div><div class="line"># 在原图上用半径为5的圆将点标出</div><div class="line">for j in range(horn.size):</div><div class="line">    y = j / horn.shape[0]</div><div class="line">    x = j % horn.shape[0]</div><div class="line">    if horn[x,y] == 255:</div><div class="line">        cv2.circle(im, (y,x), 5, (255,0,0))</div><div class="line"># 显示修改后的原图</div><div class="line">cv2.imshow(&apos;Horn Detect&apos;, im)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>由于封装的缘故，OpenCV 中函数参数中使用的坐标系和 NumPy 和 ndarray 的坐标系是不同的，在标点时可以看出。通过上面的代码可以检测图像中的拐角并标出，效果图如下：</p>
<p><img src="/images/horn.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Canny边缘检测]]></title>
      <url>http://lizonghang.github.io/2016/07/22/Canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</url>
      <content type="html"><![CDATA[<h1 id="Canny函数原型"><a href="#Canny函数原型" class="headerlink" title="Canny函数原型"></a>Canny函数原型</h1><p>OpenCV-Python 中 Canny 函数的原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">edge = cv2.Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient]]])</div></pre></td></tr></table></figure>
<ul>
<li>第一个参数是需要处理的原图像，该图像必须为单通道的灰度图</li>
<li>第二个参数是阈值1</li>
<li>第三个参数是阈值2</li>
</ul>
<p>其中较大的阈值2用于检测图像中明显的边缘，但一般情况下检测的效果不大完美，边缘检测出来是断断续续的。所以用较小的阈值1将这些间断的边缘连接起来。</p>
<p>可选参数中 <code>apertureSize</code> 就是 Sobel 算子的大小。而 <code>L2gradient</code> 参数是一个布尔值，若为真则使用更精确的 L2 范数进行计算（即两个方向的导数的平方和再开方），否则使用 L1 范数（直接将两个方向导数的绝对值相加）。</p>
<p>函数返回一幅二值图，其中包含检测出的边缘。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>Canny 函数使用只需要指定最大和最小阈值即可。以下图为例：</p>
<p><img src="/images/tower.jpg" alt=""></p>
<p>使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line">import cv2</div><div class="line">im = cv2.imread(&apos;tower.jpg&apos;)</div><div class="line">im = cv2.GaussianBlur(im, (3,3), 0)</div><div class="line">canny = cv2.Canny(im, 30, 100)</div><div class="line">cv2.imwrite(&apos;canny.jpg&apos;, canny)</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/canny.jpg" alt=""></p>
<p>可以调整阈值以改变边缘效果。</p>
<p>由于 Canny 只能处理灰度图，所以需要先将读取的图像转成灰度图。然后使用高斯平滑处理原图像以降噪。最后调用 Canny 函数，指定最大和最小阈值，其中 <code>apertureSize</code> 默认为 3。</p>
<h1 id="动态调整阈值"><a href="#动态调整阈值" class="headerlink" title="动态调整阈值"></a>动态调整阈值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">def CannyThreshold(lowThreshold):</div><div class="line">    detected_edges = cv2.GaussianBlur(gray, (3,3), 0) # Denoise</div><div class="line">    detected_edges = cv2.Canny(detected_edges, lowThreshold, lowThreshold*ratio,apertureSize=kernel_size) # Canny Edge Detect</div><div class="line">    dst = cv2.bitwise_and(im, im, mask=detected_edges) # Get Edge Image With Color</div><div class="line">    cv2.imshow(&apos;canny&apos;, dst)</div><div class="line"></div><div class="line"># Settings</div><div class="line">lowThreshold = 0 # Track Bar Start from State-0</div><div class="line">max_lowThreshold = 100 # Track Bar End with State-100</div><div class="line">ratio = 3 # threshold2 = threshold1 * ratio</div><div class="line">kernel_size = 3 # Size of Sobel</div><div class="line"></div><div class="line"># Running</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    im = cv2.imread(&apos;tower.jpg&apos;) # Read From File</div><div class="line">    gray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY) # GBR Convert To Gray</div><div class="line">    cv2.namedWindow(&apos;canny&apos;) # Create New Window</div></pre></td></tr></table></figure>
<p>得到的局部效果图如下：</p>
<p><img src="/images/canny_dial.jpg" alt=""></p>
<p>上图中有一个滑动条，拖动可改变 Canny 边缘检测效果，可以自行尝试一下。</p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[直方图的计算与显示]]></title>
      <url>http://lizonghang.github.io/2016/07/22/%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E8%AE%A1%E7%AE%97%E4%B8%8E%E6%98%BE%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>与 C++ 中一样，在 Python 中调用的 OpenCV 直方图计算函数为 <code>cv2.calcHist()</code>。</p>
<p><code>cv2.calcHist()</code> 的原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.calcHist(images, channels, mask, histSize, ranges[, hist[, accumlate ]])</div></pre></td></tr></table></figure>
<p>下面为一个简单例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">hist = cv2.calcHist(</div><div class="line">    [im],</div><div class="line">    [0], #使用的通道</div><div class="line">    None, #没有使用mask</div><div class="line">    [256], #HistSize</div><div class="line">    [0.0, 255.0] #直方图柱的范围</div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li>其中第一个参数 <code>images</code> 必须用方括号括起</li>
<li>第二个参数 <code>channels</code> 是用于计算直方图的通道，这里使用灰度图计算直方图，所以就直接使用第一个通道</li>
<li>第三个参数 <code>mask</code> 没有使用，用 <code>None</code></li>
<li>第四个参数 <code>histSize</code> 表示这个直方图分成多少份（即多少个直方柱）</li>
<li>第五个参数 <code>ranges</code> 表示直方图中各个像素的值， <code>[0.0, 255.0]</code> 表示直方图能表示像素值从 0.0 到 255.0 的像素</li>
<li>由于直方图作为函数结果返回了，所以 <code>hist</code> 没有意义</li>
<li><code>accumulate</code> 是一个布尔值，用来表示直方图是否叠加</li>
</ul>
<h1 id="彩色图像不同通道的直方图"><a href="#彩色图像不同通道的直方图" class="headerlink" title="彩色图像不同通道的直方图"></a>彩色图像不同通道的直方图</h1><p>以下图为例：</p>
<p><img src="/images/lena.jpg" alt=""></p>
<p>首先读取并分离各通道：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r,g,b = cv2.split(im)</div></pre></td></tr></table></figure>
<p>接着计算每个通道的直方图，这里将其封装成一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def calcAndDrawHist(image, color):</div><div class="line">    hist = cv2.calcHist([image], [0], None, [256], [0.0, 255.0])</div><div class="line">    minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(hist)</div><div class="line">    histImg = numpy.zeros([256,256,3], numpy.uint8)</div><div class="line">    hpt = int(0.9*256)</div><div class="line">    for h in range(256):</div><div class="line">        intensity = int(hist[h] * hpt / maxVal)</div><div class="line">        cv2.line(histImg, (h,256), (h,256-intensity), color)</div><div class="line">    return histImg</div></pre></td></tr></table></figure>
<p>在主函数中调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">    r, g, b = cv2.split(im)</div><div class="line">    histImgR = calcAndDrawHist(r, [255, 0, 0])</div><div class="line">    histImgG = calcAndDrawHist(g, [0, 255, 0])</div><div class="line">    histImgB = calcAndDrawHist(b, [0, 0, 255])</div><div class="line">    cv2.imwrite(&apos;/Users/mac/Desktop/histImgR.jpg&apos;, histImgR)</div><div class="line">    cv2.imwrite(&apos;/Users/mac/Desktop/histImgG.jpg&apos;, histImgG)</div><div class="line">    cv2.imwrite(&apos;/Users/mac/Desktop/histImgB.jpg&apos;, histImgB)</div></pre></td></tr></table></figure>
<p>得到的三个通道的直方图如下：</p>
<p><img src="/images/histImgR.jpg" alt=""><br><img src="/images/histImgG.jpg" alt=""><br><img src="/images/histImgB.jpg" alt=""></p>
<p>也可不分离通道，用折线来描绘直方图的边界，可在一个图中同时绘出三个通道的直方图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">h = numpy.zeros((256,256,3))</div><div class="line">bins = numpy.arange(256).reshape(256,1)</div><div class="line">color = [(255,0,0),(0,255,0),(0,0,255)]</div><div class="line">for ch,color in enumerate(color):</div><div class="line">    originHist = cv2.calcHist([im], [ch], None, [256], [0,256])</div><div class="line">    cv2.normalize(originHist, originHist, 0, 255*0.9, cv2.NORM_MINMAX)</div><div class="line">    hist = numpy.int32(numpy.around(originHist))</div><div class="line">    pts = numpy.column_stack((bins, hist))</div><div class="line">    cv2.polylines(h, [pts], False, color)</div><div class="line">h = numpy.flipud(h)</div><div class="line">cv2.imwrite(&apos;colorhist.jpg&apos;, h)</div></pre></td></tr></table></figure>
<p>结果如下图所示：</p>
<p><img src="/images/colorhist.jpg" alt=""></p>
<ul>
<li>for 循环是对三个通道遍历一次，每次绘制相应通道的直方图的折线。for 循环的第一行是计算对应通道的直方图。</li>
<li>这里直接调用了 OpenCV 的归一化函数，该函数将直方图的范围限定在 0~255×0.9 之间。</li>
<li><code>hist = numpy.int32(numpy.around(originHist))</code> 先将生成的原始直方图中的每个元素四舍六入五凑偶取整（cv2.calcHist函数得到的是 float32 类型的数组），接着将整数部分转成 <code>numpy.int32</code> 类型。即61.123先转成61.0，再转成61。这里必须使用 <code>numpy.int32()</code> 进行转换，numpy 的转换函数可以对数组中的每个元素都进行转换，而Python的转换函数只能转换一个元素，如果使用 Python 的转换函数，将导致 <code>only length-1 arrays can be converted to Python scalars</code> 错误。</li>
<li><code>pts = numpy.column_stack((bins,hist))</code> 是将直方图中每个bin的值转成相应的坐标。比如hist[0] =3，…，hist[126] = 178，…，hist[255] = 5；而bins的值为[[0],[1],[2]…,[255]]。使用 <code>np.column_stack</code> 将其组合成[0, 3]、[126, 178]、[255, 5]这样的坐标作为元素组成的数组。</li>
<li><code>cv2.polylines()</code> 函数根据这些点绘制出折线，&lt;/code&gt;False&lt;/code&gt; 参数指出这个折线不需要闭合。第四个参数指定了折线的颜色。</li>
<li><code>h = numpy.flipud(h)</code> 反转绘制好的直方图。因为绘制时，[0,0]在图像的左上角。</li>
</ul>
<h1 id="NumPy的直方图计算"><a href="#NumPy的直方图计算" class="headerlink" title="NumPy的直方图计算"></a>NumPy的直方图计算</h1><p>使用 NumPy 的直方图计算函数 <code>numpy.histogram()</code> 也能实现相同的效果，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">➜  Desktop vim cv.py</div><div class="line">➜  Desktop ls</div><div class="line">import numpy</div><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">h = numpy.zeros((300,256,3))</div><div class="line">bins = numpy.arange(257)</div><div class="line">bin = bins[0:-1]</div><div class="line">color = [(255,0,0),(0,255,0),(0,0,255)]</div><div class="line"></div><div class="line">for ch,color in enumerate(color):</div><div class="line">    item = im[:,:,ch]</div><div class="line">    N,bins = numpy.histogram(item, bins)</div><div class="line">    v = N.max()</div><div class="line">    N = numpy.int32(numpy.around((N*255)/v))</div><div class="line">    N = N.reshape(256,1)</div><div class="line">    pts = numpy.column_stack((bin,N))</div><div class="line">    cv2.polylines(h, [pts], False, color)</div><div class="line">h = numpy.flipud(h)</div><div class="line">cv2.imwrite(&apos;colorhist_np.jpg&apos;, h)</div></pre></td></tr></table></figure>
<p>效果图和上图相同。</p>
<p>通过 NumPy 和 matplotlib 可以更方便的绘制出直方图，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import numpy</div><div class="line">import cv2</div><div class="line">import matplotlib.pyplot as plt</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">bins = numpy.arange(257)</div><div class="line">item = im[:,:,1] # G通道直方图</div><div class="line">hist, bins = numpy.histogram(item, bins)</div><div class="line">width = 0.7*(bins[1]-bins[0])</div><div class="line">center = (bins[:-1]+bins[1:])/2</div><div class="line">plt.bar(center, hist, align=&apos;center&apos;, width=width)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/plt.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenCV像素与通道]]></title>
      <url>http://lizonghang.github.io/2016/07/21/OpenCV%E5%83%8F%E7%B4%A0%E4%B8%8E%E9%80%9A%E9%81%93/</url>
      <content type="html"><![CDATA[<h1 id="访问像素"><a href="#访问像素" class="headerlink" title="访问像素"></a>访问像素</h1><p>像素的访问和访问 numpy 中 ndarray 的方法完全一样，灰度图为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">img[j,i] = 255</div></pre></td></tr></table></figure>
<p>其中 j，i 分别表示图像的行和列。对于RGB图像第三个数表示通道，为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img[j,i,0] = 255</div><div class="line">img[j,i,1] = 255</div><div class="line">img[j,i,2] = 255</div></pre></td></tr></table></figure>
<p>下面通过对图像添加人工的椒盐现象来说明 OpenCV 中需要注意的一些问题。</p>
<p>实验图如下：</p>
<p><img src="/images/lena.jpg" alt=""></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy</div><div class="line"></div><div class="line">def salt(img, n):</div><div class="line">    for k in range(n):</div><div class="line">        i = int(numpy.random.random() * img.shape[1])</div><div class="line">        j = int(numpy.random.random() * img.shape[0])</div><div class="line">        if img.ndim == 2:</div><div class="line">            img[j,i] = 255</div><div class="line">        elif img.ndim == 3:</div><div class="line">            img[j,i,0] = 255</div><div class="line">            img[j,i,1] = 255</div><div class="line">            img[j,i,2] = 255</div><div class="line">    return img</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    img = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">    saltImg = salt(img, 1000)</div><div class="line">    cv2.imshow(&apos;SaltImage&apos;, saltImg)</div><div class="line">    cv2.waitKey(0)</div><div class="line">    cv2.destroyAllWindows()</div><div class="line">    cv2.imwrite(&apos;/Users/mac/Desktop/saltImg.jpg&apos;, saltImg)</div></pre></td></tr></table></figure>
<p>处理后能得到类似下面这样带有模拟椒盐现象的图片：</p>
<p><img src="/images/saltImg.jpg" alt=""></p>
<p>需要注意的是：</p>
<ul>
<li>与 C++ 不同，在 Python 中灰度图的 <code>img.ndim = 2</code>，而 C++ 中灰度图图像的通道数 <code>img.channel() = 1</code></li>
<li>这里使用了 numpy 的随机数， Python自身也有一个随机数生成函数。<code>numpy.random</code> 模块中拥有更多的方法，而 Python 自带的 <code>random</code> 只是一个轻量级的模块。不过需要注意的是 <code>numpy.random.seed()</code> 不是线程安全的，而 Python 自带的 <code>random.seed()</code> 是线程安全的。如果使用随机数时需要用到多线程，建议使用 Python 自带的 <code>random()</code> 和 <code>random.seed()，或者构建一个本地的 <code>numpy.random.Random</code> 类的实例。</code></li>
</ul>
<h1 id="分离、合并通道"><a href="#分离、合并通道" class="headerlink" title="分离、合并通道"></a>分离、合并通道</h1><p>由于 OpenCV-Python 和 NumPy 结合的很紧，所以即可使用 OpenCV自带的 <code>split</code>函数，也可以直接操作 Numpy 数组来分离通道。</p>
<h2 id="OpenCV分离通道"><a href="#OpenCV分离通道" class="headerlink" title="OpenCV分离通道"></a>OpenCV分离通道</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r, g, b = cv2.split(im)</div><div class="line">cv2.imshow(&apos;Red&apos;, r)</div><div class="line">cv2.imshow(&apos;Green&apos;, g)</div><div class="line">cv2.imshow(&apos;Blue&apos;, b)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>其中 <code>cv2.split()</code> 返回 RGB 三个通道，如果只想返回其中一个通道，可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">r = cv2.split(im)[0]</div><div class="line">g = cv2.split(im)[1]</div><div class="line">b = cv2.split(im)[2]</div></pre></td></tr></table></figure>
<h2 id="NumPy分离通道"><a href="#NumPy分离通道" class="headerlink" title="NumPy分离通道"></a>NumPy分离通道</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r = numpy.zeros((im.shape[0], im.shape[1]), dtype=im.dtype)</div><div class="line">g = numpy.zeros((im.shape[0], im.shape[1]), dtype=im.dtype)</div><div class="line">b = numpy.zeros((im.shape[0], im.shape[1]), dtype=im.dtype)</div><div class="line">r[:,:] = im[:,:,0]</div><div class="line">g[:,:] = im[:,:,1]</div><div class="line">b[:,:] = im[:,:,2]</div><div class="line">cv2.imshow(&apos;Red&apos;, r)</div><div class="line">cv2.imshow(&apos;Green&apos;, g)</div><div class="line">cv2.imshow(&apos;Blue&apos;, b)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>注意先要开辟一个相同大小的图片出来。这是由于 numpy 中数组的复制有三种方式，详见<a href="/2016/07/20/numpy深入探讨/#复制和镜像">NumPy数组复制</a>。</p>
<h1 id="合并通道"><a href="#合并通道" class="headerlink" title="合并通道"></a>合并通道</h1><h2 id="OpenCV合并通道"><a href="#OpenCV合并通道" class="headerlink" title="OpenCV合并通道"></a>OpenCV合并通道</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r,g,b = cv2.split(im)</div><div class="line">mergeImg = cv2.merge([r,g,b])</div><div class="line">cv2.imshow(&apos;merge&apos;, mergeImg)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<h2 id="Numpy合并通道"><a href="#Numpy合并通道" class="headerlink" title="Numpy合并通道"></a>Numpy合并通道</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r,g,b = cv2.split(im)</div><div class="line">merged = numpy.dstack([r,g,b])</div><div class="line">cv2.imshow(&apos;merge&apos;, merged)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<h2 id="合并效果"><a href="#合并效果" class="headerlink" title="合并效果"></a>合并效果</h2><p>实际使用时建议用 OpenCV 自带的合并函数，在效果上存在一点歧义，有人测试出二者的 <code>strides</code> 属性不同，而实际测出的却相同。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r,g,b = cv2.split(im)</div><div class="line">mergedByCV2 = numpy.dstack([r,g,b])</div><div class="line">mergedByNumpy = cv2.merge([r,g,b])</div><div class="line">print &apos;merged by opencv2.0: &apos;, mergedByCV2.strides</div><div class="line">print &apos;merged by numpy: &apos;, mergedByNumpy.strides</div></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">merged by opencv2.0:  (1500, 3, 1)</div><div class="line">merged by numpy:  (1500, 3, 1)</div></pre></td></tr></table></figure>
<p>NumPy 数组的 <code>strides</code> 属性表示的是在每个维数上以字节计算的步长。如下例（int64）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(6)</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([0, 1, 2, 3, 4, 5])</div><div class="line">&gt;&gt;&gt; a.strides</div><div class="line">(8,)</div><div class="line">&gt;&gt;&gt; b = numpy.arange(12).reshape((3,4))</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [ 4,  5,  6,  7],</div><div class="line">       [ 8,  9, 10, 11]])</div><div class="line">&gt;&gt;&gt; b.strides</div><div class="line">(32, 8)</div><div class="line">&gt;&gt;&gt; c = numpy.arange(27).reshape(3,3,3)</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([[[ 0,  1,  2],</div><div class="line">        [ 3,  4,  5],</div><div class="line">        [ 6,  7,  8]],</div><div class="line"></div><div class="line">       [[ 9, 10, 11],</div><div class="line">        [12, 13, 14],</div><div class="line">        [15, 16, 17]],</div><div class="line"></div><div class="line">       [[18, 19, 20],</div><div class="line">        [21, 22, 23],</div><div class="line">        [24, 25, 26]]])</div><div class="line">&gt;&gt;&gt; c.strides</div><div class="line">(72, 24, 8)</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[numpy深入探讨]]></title>
      <url>http://lizonghang.github.io/2016/07/20/numpy%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/</url>
      <content type="html"><![CDATA[<p>前两篇文章对NumPy数组做了基本的介绍，本篇文章对NumPy数组进行较深入的探讨。首先介绍自定义类型的数组，接着数组的组合，最后介绍数组复制方面的问题。</p>
<h1 id="自定义结构数组"><a href="#自定义结构数组" class="headerlink" title="自定义结构数组"></a>自定义结构数组</h1><p>通过 NumPy 也可以定义像 C 语言那样的结构类型。在 NumPy中定义结构的方法如下：</p>
<p>定义结构类型名称；定义字段名称；标明字段数据类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">student = numpy.dtype(&#123;&apos;names&apos;: [&apos;name&apos;, &apos;age&apos;, &apos;weight&apos;], &apos;formats&apos;: [&apos;S32&apos;, &apos;i&apos;, &apos;f&apos;]&#125;, align=True)</div></pre></td></tr></table></figure>
<p>这里 <code>student</code> 是自定义结构类型的名称，使用 <code>dtype()</code> 函数创建，在第一个参数中， <code>‘names’</code> 和 <code>‘formats’</code> 不能改变， <code>names</code>中列出的是结构中的字段名称， <code>formats</code> 中列出的是对应字段的数据类型。<code>S32</code>表示 32 字节长度的字符串， <code>i</code> 表示 32 位的整数， <code>f</code> 表示 32 位长度的浮点数。最后一个参数为 <code>True</code> 时，表示要求进行内存对齐。</p>
<p>字段中使用 NumPy 的字符编码来表示数据类型。更详细的数据类型见下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>字符编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数</td>
<td>i</td>
</tr>
<tr>
<td>无符号整数</td>
<td>u</td>
</tr>
<tr>
<td>单精度浮点数</td>
<td>f</td>
</tr>
<tr>
<td>双精度浮点数</td>
<td>d</td>
</tr>
<tr>
<td>布尔值</td>
<td>b</td>
</tr>
<tr>
<td>复数</td>
<td>D</td>
</tr>
<tr>
<td>字符串</td>
<td>S</td>
</tr>
<tr>
<td>Unicode</td>
<td>U</td>
</tr>
<tr>
<td>Void</td>
<td>V</td>
</tr>
</tbody>
</table>
</div>
<p>在定义好结构类型之后，就可以定义以该类型为元素的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = numpy.array([(&apos;Zhang&apos;, 32, 65.5), (&apos;Wang&apos;, 24, 55.2)], dtype=student)</div></pre></td></tr></table></figure>
<p>除了在每个元素中依次列出对应字段的数据外，还需要在 <code>array</code> 函数中指定对应的数据类型。</p>
<h1 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h1><p>首先创建两个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(9).reshape(3,3)</div><div class="line">&gt;&gt;&gt; b = 2 * a</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[0, 1, 2],</div><div class="line">       [3, 4, 5],</div><div class="line">       [6, 7, 8]])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  2,  4],</div><div class="line">       [ 6,  8, 10],</div><div class="line">       [12, 14, 16]])</div></pre></td></tr></table></figure>
<h2 id="水平组合"><a href="#水平组合" class="headerlink" title="水平组合"></a>水平组合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.hstack((a,b))</div><div class="line">array([[ 0,  1,  2,  0,  2,  4],</div><div class="line">       [ 3,  4,  5,  6,  8, 10],</div><div class="line">       [ 6,  7,  8, 12, 14, 16]])</div></pre></td></tr></table></figure>
<p>也可通过 <code>concatenate</code> 函数并指定相应的轴来获得这一效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.concatenate((a,b), axis=1)</div><div class="line">array([[ 0,  1,  2,  0,  2,  4],</div><div class="line">       [ 3,  4,  5,  6,  8, 10],</div><div class="line">       [ 6,  7,  8, 12, 14, 16]])</div></pre></td></tr></table></figure>
<h2 id="垂直组合"><a href="#垂直组合" class="headerlink" title="垂直组合"></a>垂直组合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.vstack((a,b))</div><div class="line">array([[ 0,  1,  2],</div><div class="line">       [ 3,  4,  5],</div><div class="line">       [ 6,  7,  8],</div><div class="line">       [ 0,  2,  4],</div><div class="line">       [ 6,  8, 10],</div><div class="line">       [12, 14, 16]])</div></pre></td></tr></table></figure>
<p>同样可通过 <code>concatenate</code> 函数并指定相应的轴来获得这一效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.concatenate((a,b), axis=0)</div><div class="line">array([[ 0,  1,  2],</div><div class="line">       [ 3,  4,  5],</div><div class="line">       [ 6,  7,  8],</div><div class="line">       [ 0,  2,  4],</div><div class="line">       [ 6,  8, 10],</div><div class="line">       [12, 14, 16]])</div></pre></td></tr></table></figure>
<h2 id="深度组合"><a href="#深度组合" class="headerlink" title="深度组合"></a>深度组合</h2><p>另外还有深度方面的组合函数 <code>dstack</code>，顾名思义，就是在数组的第三个轴（即深度）上组合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.dstack((a,b))</div><div class="line">array([[[ 0,  0],</div><div class="line">        [ 1,  2],</div><div class="line">        [ 2,  4]],</div><div class="line"></div><div class="line">       [[ 3,  6],</div><div class="line">        [ 4,  8],</div><div class="line">        [ 5, 10]],</div><div class="line"></div><div class="line">       [[ 6, 12],</div><div class="line">        [ 7, 14],</div><div class="line">        [ 8, 16]]])</div></pre></td></tr></table></figure>
<p>仔细观察发现对应的元素都组合成一个新的列表，该列表作为新的数组的元素。</p>
<h2 id="行组合"><a href="#行组合" class="headerlink" title="行组合"></a>行组合</h2><p>行组合可将多个一维数组作为新数组的每一行进行组合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(2)</div><div class="line">&gt;&gt;&gt; b = a + 2</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([0, 1])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([2, 3])</div><div class="line">&gt;&gt;&gt; numpy.row_stack((a,b))</div><div class="line">array([[0, 1],</div><div class="line">       [2, 3]])</div></pre></td></tr></table></figure>
<h2 id="列组合"><a href="#列组合" class="headerlink" title="列组合"></a>列组合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a</div><div class="line">array([0, 1])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([2, 3])</div><div class="line">&gt;&gt;&gt; numpy.column_stack((a,b))</div><div class="line">array([[0, 2],</div><div class="line">       [1, 3]])</div></pre></td></tr></table></figure>
<h1 id="分割数组"><a href="#分割数组" class="headerlink" title="分割数组"></a>分割数组</h1><p>分割数组的函数有 <code>hsplit</code>、<code>vsplit</code>、<code>dsplit</code>、<code>split</code>。可将数组分割成相同大小的子数组，或指定原数组分割的位置。</p>
<h2 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.hsplit(a, 3)</div><div class="line">[array([[0],</div><div class="line">       [3],</div><div class="line">       [6]]), array([[1],</div><div class="line">       [4],</div><div class="line">       [7]]), array([[2],</div><div class="line">       [5],</div><div class="line">       [8]])]</div></pre></td></tr></table></figure>
<p>也可以调用 <code>split</code> 函数并指定 <code>axis=1</code> 来获得这样的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.split(a, 3, axis=1)</div></pre></td></tr></table></figure>
<h2 id="垂直分割"><a href="#垂直分割" class="headerlink" title="垂直分割"></a>垂直分割</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.vsplit(a, 3)</div><div class="line">[array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])]</div></pre></td></tr></table></figure>
<p>也可以调用 <code>split</code> 函数并指定 <code>axis=0</code> 来获得这样的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.split(a, 3, axis=0)</div></pre></td></tr></table></figure>
<h2 id="深度分割"><a href="#深度分割" class="headerlink" title="深度分割"></a>深度分割</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = numpy.arange(27).reshape(3,3,3)</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([[[ 0,  1,  2],</div><div class="line">        [ 3,  4,  5],</div><div class="line">        [ 6,  7,  8]],</div><div class="line"></div><div class="line">       [[ 9, 10, 11],</div><div class="line">        [12, 13, 14],</div><div class="line">        [15, 16, 17]],</div><div class="line"></div><div class="line">       [[18, 19, 20],</div><div class="line">        [21, 22, 23],</div><div class="line">        [24, 25, 26]]])</div><div class="line">&gt;&gt;&gt; numpy.dsplit(c, 3)</div><div class="line">[array([[[ 0],</div><div class="line">        [ 3],</div><div class="line">        [ 6]],</div><div class="line"></div><div class="line">       [[ 9],</div><div class="line">        [12],</div><div class="line">        [15]],</div><div class="line"></div><div class="line">       [[18],</div><div class="line">        [21],</div><div class="line">        [24]]]), array([[[ 1],</div><div class="line">        [ 4],</div><div class="line">        [ 7]],</div><div class="line"></div><div class="line">       [[10],</div><div class="line">        [13],</div><div class="line">        [16]],</div><div class="line"></div><div class="line">       [[19],</div><div class="line">        [22],</div><div class="line">        [25]]]), array([[[ 2],</div><div class="line">        [ 5],</div><div class="line">        [ 8]],</div><div class="line"></div><div class="line">       [[11],</div><div class="line">        [14],</div><div class="line">        [17]],</div><div class="line"></div><div class="line">       [[20],</div><div class="line">        [23],</div><div class="line">        [26]]])]</div></pre></td></tr></table></figure>
<h1 id="复制和镜像"><a href="#复制和镜像" class="headerlink" title="复制和镜像"></a>复制和镜像</h1><p>当运算和处理数组时，它们的数据有时被拷贝到新的数组，有时不是。有三种情况：</p>
<h2 id="完全不复制"><a href="#完全不复制" class="headerlink" title="完全不复制"></a>完全不复制</h2><p>简单的赋值，而不复制数组对象或它们的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(12)</div><div class="line">&gt;&gt;&gt; b = a # 不创建新对象</div><div class="line">&gt;&gt;&gt; b is a</div><div class="line">True</div><div class="line">&gt;&gt;&gt; b.shape = (3,4)</div><div class="line">&gt;&gt;&gt; a.shape</div><div class="line">(3, 4)</div></pre></td></tr></table></figure>
<p>Python 传递不定对象作为参考，所以函数调用不拷贝数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def f(x):</div><div class="line">...     print id(x)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; id(a)</div><div class="line">4560419696</div><div class="line">&gt;&gt;&gt; f(a)</div><div class="line">4560419696</div></pre></td></tr></table></figure>
<h2 id="视图（View）和浅复制"><a href="#视图（View）和浅复制" class="headerlink" title="视图（View）和浅复制"></a>视图（View）和浅复制</h2><p>不同的数组对象分享同一个数据。视图方法创造一个新的数组对象指向同一数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = a.view()</div><div class="line">&gt;&gt;&gt; c is a</div><div class="line">False</div><div class="line">&gt;&gt;&gt; c.base is a </div><div class="line">True</div><div class="line">&gt;&gt;&gt; c.flags.owndata</div><div class="line">False</div><div class="line">&gt;&gt;&gt; c.shape = (2,6) # a的形状不变</div><div class="line">&gt;&gt;&gt; a.shape</div><div class="line">(3, 4)</div><div class="line">&gt;&gt;&gt; c[0,4] = 12 # a的数据改变</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [12,  5,  6,  7],</div><div class="line">       [ 8,  9, 10, 11]])</div></pre></td></tr></table></figure>
<p>切片数组返回它的一个视图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = a[:, 1:3]</div><div class="line">&gt;&gt;&gt; s[:] = 10 # s[:]是s的镜像，共享数据</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 0, 10, 10,  3],</div><div class="line">       [12, 10, 10,  7],</div><div class="line">       [ 8, 10, 10, 11]])</div></pre></td></tr></table></figure>
<h2 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h2><p>完全复制数组和它的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = a.copy()</div><div class="line">&gt;&gt;&gt; d is a</div><div class="line">False</div><div class="line">&gt;&gt;&gt; d.base is a</div><div class="line">False</div><div class="line">&gt;&gt;&gt; d[0,0] = 99</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 0, 10, 10,  3],</div><div class="line">       [12, 10, 10,  7],</div><div class="line">       [ 8, 10, 10, 11]])</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[numpy数组操作]]></title>
      <url>http://lizonghang.github.io/2016/07/20/numpy%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h1 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.array([20,30,40,50])</div><div class="line">&gt;&gt;&gt; b = numpy.arange(4)</div><div class="line">&gt;&gt;&gt; c = a - b</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([20, 29, 38, 47])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([0, 1, 2, 3])</div><div class="line">&gt;&gt;&gt; b**2</div><div class="line">array([0, 1, 4, 9])</div><div class="line">&gt;&gt;&gt; 10*numpy.sin(a)</div><div class="line">array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])</div><div class="line">&gt;&gt;&gt; a &lt; 35</div><div class="line">array([ True,  True, False, False], dtype=bool)</div></pre></td></tr></table></figure>
<p>NumPy 中的乘法运算符按元素逐个计算，矩阵乘法可以使用 dot 函数或创建矩阵对象实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; A = numpy.array([[1,1],[0,1]])</div><div class="line">&gt;&gt;&gt; B = numpy.array([[2,0],[3,4]])</div><div class="line">&gt;&gt;&gt; A*B</div><div class="line">array([[2, 0],</div><div class="line">       [0, 4]])</div><div class="line">&gt;&gt;&gt; numpy.dot(A,B)</div><div class="line">array([[5, 4],</div><div class="line">       [3, 4]])</div></pre></td></tr></table></figure>
<p>当数组中存储的是不同类型的元素时，数组将使用占用更多位的数据类型作为其本身的数据类型，也就是偏向更精确的数据类型，这种行为叫做 upcast：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.ones(3, dtype=numpy.int32)</div><div class="line">&gt;&gt;&gt; b = numpy.linspace(0, numpy.pi, 3)</div><div class="line">&gt;&gt;&gt; b.dtype.name</div><div class="line">&apos;float64&apos;</div><div class="line">&gt;&gt;&gt; c = a + b</div><div class="line">&gt;&gt;&gt; c.dtype.name</div><div class="line">&apos;float64&apos;</div><div class="line">&gt;&gt;&gt; d = numpy.exp(c*1j)</div><div class="line">&gt;&gt;&gt; d.dtype.name</div><div class="line">&apos;complex128&apos;</div></pre></td></tr></table></figure>
<p>许多非数组运算，如计算数组所有元素之和，都作为 ndarray 类的方法来实现，使用时需要用 ndarray 类的实例来调用这些方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.random.random((2,3))</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 0.68091784,  0.41612706,  0.86948767],</div><div class="line">       [ 0.78411139,  0.25901918,  0.6092565 ]])</div><div class="line">&gt;&gt;&gt; a.sum()</div><div class="line">3.6189196384603322</div><div class="line">&gt;&gt;&gt; a.min()</div><div class="line">0.2590191823646294</div><div class="line">&gt;&gt;&gt; a.max()</div><div class="line">0.86948766685829515</div></pre></td></tr></table></figure>
<p>这些运算将数组看作是一维线性列表。但可通过指定 axis 参数（即数组的行）对指定的轴做相应的运算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = numpy.arange(12).reshape(3,4)</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [ 4,  5,  6,  7],</div><div class="line">       [ 8,  9, 10, 11]])</div><div class="line">&gt;&gt;&gt; b.sum(axis=0)</div><div class="line">array([12, 15, 18, 21])</div><div class="line">&gt;&gt;&gt; b.min(axis=1)</div><div class="line">array([0, 4, 8])</div><div class="line">&gt;&gt;&gt; b.cumsum(axis=1)</div><div class="line">array([[ 0,  1,  3,  6],</div><div class="line">       [ 4,  9, 15, 22],</div><div class="line">       [ 8, 17, 27, 38]])</div></pre></td></tr></table></figure>
<h1 id="索引，切片和迭代"><a href="#索引，切片和迭代" class="headerlink" title="索引，切片和迭代"></a>索引，切片和迭代</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(10)**3</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])</div><div class="line">&gt;&gt;&gt; a[2]</div><div class="line">8</div><div class="line">&gt;&gt;&gt; a[2:5]</div><div class="line">array([ 8, 27, 64])</div><div class="line">&gt;&gt;&gt; a[:6:2] = -1000</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([-1000,     1, -1000,    27, -1000,   125,   216,   343,   512,   729])</div><div class="line">&gt;&gt;&gt; a[::-1]</div><div class="line">array([  729,   512,   343,   216,   125, -1000,    27, -1000,     1, -1000])</div></pre></td></tr></table></figure>
<p>多维数组可以每个轴有一个索引，这些索引由一个逗号分割的元组给出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def f(x,y):</div><div class="line">...     return 10*x+y</div><div class="line">...</div><div class="line">&gt;&gt;&gt; b = numpy.fromfunction(f, (5,4), dtype=int)</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line">&gt;&gt;&gt; b[2,3]</div><div class="line">23</div><div class="line">&gt;&gt;&gt; b[0:5,1]</div><div class="line">array([ 1, 11, 21, 31, 41])</div><div class="line">&gt;&gt;&gt; b[:,1]</div><div class="line">array([ 1, 11, 21, 31, 41])</div><div class="line">&gt;&gt;&gt; b[1:3,:]</div><div class="line">array([[10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23]])</div></pre></td></tr></table></figure>
<p>b[i] 中括号中的表达式被当做 i 和一系列 : 来代表剩下的轴。NumPy 允许使用 b[i, …]。’…’代表许多产生一个完整的索引元组必要的分号。如果 x 是秩为 5 的数组，那么：</p>
<ul>
<li>x[1,2,…] 等同于 x[1,2,:,:,:]</li>
<li>x[…,3] 等同于 x[:,:,:,:,3]</li>
<li>x[4,…,5,:] 等同于 x[4,:,:,5,:]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = numpy.arange(12).reshape((3,4))</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [ 4,  5,  6,  7],</div><div class="line">       [ 8,  9, 10, 11]])</div><div class="line">&gt;&gt;&gt; c.shape</div><div class="line">(3, 4)</div><div class="line">&gt;&gt;&gt; c[1,...]</div><div class="line">array([4, 5, 6, 7])</div><div class="line">&gt;&gt;&gt; c[...,2]</div><div class="line">array([ 2,  6, 10])</div></pre></td></tr></table></figure>
<p>如果想对数组中每个元素都进行处理，可以使用 <code>flat</code> 属性，该属性是一个数组元素迭代器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line">&gt;&gt;&gt; for element in b.flat:</div><div class="line">...     print element,</div><div class="line">...</div><div class="line">0 1 2 3 10 11 12 13 20 21 22 23 30 31 32 33 40 41 42 43</div></pre></td></tr></table></figure>
<h1 id="形状操作"><a href="#形状操作" class="headerlink" title="形状操作"></a>形状操作</h1><p>可以用多种方式修改数组的形状：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line">&gt;&gt;&gt; b.shape</div><div class="line">(5, 4)</div><div class="line"></div><div class="line">&gt;&gt;&gt; b.ravel() # 平坦化数组</div><div class="line">array([ 0,  1,  2,  3, 10, 11, 12, 13, 20, 21, 22, 23, 30, 31, 32, 33, 40,</div><div class="line">       41, 42, 43])</div><div class="line"></div><div class="line">&gt;&gt;&gt; b.shape = (10,2)</div><div class="line">&gt;&gt;&gt; b.transpose()</div><div class="line">array([[ 0,  2, 10, 12, 20, 22, 30, 32, 40, 42],</div><div class="line">       [ 1,  3, 11, 13, 21, 23, 31, 33, 41, 43]])</div></pre></td></tr></table></figure>
<p><code>reshape()</code> 函数改变调用数组的形状并返回该数组，而 <code>resize()</code> 函数改变调用数组自身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line"></div><div class="line">&gt;&gt;&gt; b.reshape((2,10))</div><div class="line">array([[ 0,  1,  2,  3, 10, 11, 12, 13, 20, 21],</div><div class="line">       [22, 23, 30, 31, 32, 33, 40, 41, 42, 43]])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line"></div><div class="line">&gt;&gt;&gt; b.resize((2,10))</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3, 10, 11, 12, 13, 20, 21],</div><div class="line">       [22, 23, 30, 31, 32, 33, 40, 41, 42, 43]])</div></pre></td></tr></table></figure>
<p>如果在 <code>reshape()</code> 操作中指定一个维度为 -1，那么其准确维度将根据实际情况计算得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line">&gt;&gt;&gt; b.reshape((4,-1))</div><div class="line">array([[ 0,  1,  2,  3, 10],</div><div class="line">       [11, 12, 13, 20, 21],</div><div class="line">       [22, 23, 30, 31, 32],</div><div class="line">       [33, 40, 41, 42, 43]])</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[numpy数组初探]]></title>
      <url>http://lizonghang.github.io/2016/07/20/numpy%E6%95%B0%E7%BB%84%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<h1 id="NumPy数组"><a href="#NumPy数组" class="headerlink" title="NumPy数组"></a>NumPy数组</h1><p>Numpy 数组是一个多维数组对象，称为 ndarray，由实际的数据和描述这些数据的元数据组成。大部分操作仅针对元数据，而不改变底层实际的数据。</p>
<p>关于 NumPy 数组需要知道：NumPy 数组的下标从 0 开始；同一个 NumPy 数组中的所有元素的类型必须是相同的。</p>
<h1 id="NumPy-数组属性"><a href="#NumPy-数组属性" class="headerlink" title="NumPy 数组属性"></a>NumPy 数组属性</h1><p>NumPy 数组的维数称为秩（rank），每一个线性的数组称为一个轴（axes），秩其实是描述轴的数量。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中的每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴，第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。</p>
<p>NumPy 的数组中比较重要的 ndarray 对象属性有：</p>
<ul>
<li><code>ndarray.ndim</code> - 数组的维数/秩。最常见为二维数组。</li>
<li><code>ndarray.shape</code> - 数组的维度。为一个表示数组在每个维度上大小的整数元组。例如二维数组中，表示数组的“行数”和“列数”。<code>ndarray.shape</code> 返回一个元组，这个元组的长度就是维度的数目，即 <code>ndim</code> 属性。</li>
<li><code>ndarray.size</code> - 数组元素的总个数，等于 <code>shape</code> 属性中元组元素的乘积。</li>
<li><code>ndarray.dtype</code> - 表示数组中元素类型的对象，可使用标准的 Python 类型创建或指定 <code>dtype</code>。</li>
<li><code>ndarray.itemsize</code> - 数组中每个元素的字节大小。例如一个元素类型为 float64 的数组 <code>itemsize</code> 属性值为 8，一个元素类型为 complex32 的数组 <code>itemsize</code> 属性为 4。</li>
<li><code>ndarray.data</code> - 包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</li>
</ul>
<h1 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h1><h2 id="numpy-array"><a href="#numpy-array" class="headerlink" title="numpy.array()"></a>numpy.array()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import numpy</div><div class="line">&gt;&gt;&gt; a = numpy.array([2,3,4])</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([2, 3, 4])</div><div class="line">&gt;&gt;&gt; a.dtype</div><div class="line">dtype(&apos;int64&apos;)</div><div class="line">&gt;&gt;&gt; b = numpy.array([1.2, 3.5, 5.1])</div><div class="line">&gt;&gt;&gt; b.dtype</div><div class="line">dtype(&apos;float64&apos;)</div></pre></td></tr></table></figure>
<p>使用 <code>numpy.array()</code> 函数创建时，参数必须是由方括号括起的列表，而不能使用多个数值作为参数调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.array(1,2,3,4)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: only 2 non-keyword arguments accepted</div></pre></td></tr></table></figure>
<p>可使用双重序列表示二维的数组，三重序列表示三维数组，以此类推：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = numpy.array([(1.5,2,3),(4,5,6)])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 1.5,  2. ,  3. ],</div><div class="line">       [ 4. ,  5. ,  6. ]])</div></pre></td></tr></table></figure>
<p>可以在创建时显式指定数组中元素的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = numpy.array([[1,2],[3,4]], dtype=complex)</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([[ 1.+0.j,  2.+0.j],</div><div class="line">       [ 3.+0.j,  4.+0.j]])</div></pre></td></tr></table></figure>
<h2 id="numpy-zeros-、numpy-ones-、numpy-empty"><a href="#numpy-zeros-、numpy-ones-、numpy-empty" class="headerlink" title="numpy.zeros()、numpy.ones()、numpy.empty()"></a>numpy.zeros()、numpy.ones()、numpy.empty()</h2><p>通常刚开始时数组的元素未知，而数组的大小已知。因此 NumPy 提供了一些使用占位符创建数组的函数。这些函数有助于满足除了数组扩展的需要，同时降低了高昂的运算开销。</p>
<p>用函数 <code>numpy.zeros()</code> 可创建一个全是 0 的数组，用函数 <code>numpy.ones()</code> 可创建一个全为 1 的数组，函数 <code>numpy.empty()</code> 创建一个内容随机并且依赖于内存状态的数组。默认创建的数组类型（dtype）都是 float64。</p>
<p>可以用 <code>d.dtype.itemsize</code> 来查看数组中元素占用的字节数目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = numpy.zeros((3,4))</div><div class="line">&gt;&gt;&gt; d.dtype</div><div class="line">dtype(&apos;float64&apos;)</div><div class="line">&gt;&gt;&gt; d</div><div class="line">array([[ 0.,  0.,  0.,  0.],</div><div class="line">       [ 0.,  0.,  0.,  0.],</div><div class="line">       [ 0.,  0.,  0.,  0.]])</div><div class="line">&gt;&gt;&gt; d.dtype.itemsize</div><div class="line">8</div></pre></td></tr></table></figure>
<p>也可以自己制定数组中元素的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.ones((2,3,4), dtype=numpy.int8)</div><div class="line">array([[[1, 1, 1, 1],</div><div class="line">        [1, 1, 1, 1],</div><div class="line">        [1, 1, 1, 1]],</div><div class="line"></div><div class="line">       [[1, 1, 1, 1],</div><div class="line">        [1, 1, 1, 1],</div><div class="line">        [1, 1, 1, 1]]], dtype=int8)</div><div class="line">&gt;&gt;&gt; numpy.empty((2,3))</div><div class="line">array([[ 0.,  0.,  0.],</div><div class="line">       [ 0.,  0.,  0.]])</div></pre></td></tr></table></figure>
<h2 id="numpy-arange"><a href="#numpy-arange" class="headerlink" title="numpy.arange()"></a>numpy.arange()</h2><p>NumPy 提供一个类似 <code>arange()</code> 的函数返回一个数列形式的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.arange(10,30,5)</div><div class="line">array([10, 15, 20, 25])</div><div class="line">&gt;&gt;&gt; numpy.arange(0,2,0.5)</div><div class="line">array([ 0. ,  0.5,  1. ,  1.5])</div></pre></td></tr></table></figure>
<h2 id="numpy-linspace"><a href="#numpy-linspace" class="headerlink" title="numpy.linspace()"></a>numpy.linspace()</h2><p>当 <code>numpy.arange()</code> 使用浮点数参数时，由于浮点数精度有限，通常无法预测获得的元素个数。因此，最好使用函数 <code>numpy.linspace()</code> 去接收我们想要的元素个数来代替用 <code>range</code> 来指定步长：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.linspace(-1, 0, 5)</div><div class="line">array([-1.  , -0.75, -0.5 , -0.25,  0.  ])</div></pre></td></tr></table></figure>
<p>数组中的元素是通过下标来访问的，可以以切片的形式访问数组中多个元素。</p>
<h1 id="NumPy基本数据类型"><a href="#NumPy基本数据类型" class="headerlink" title="NumPy基本数据类型"></a>NumPy基本数据类型</h1><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>用一个字节存储的布尔类型</td>
<td>True / False</td>
</tr>
<tr>
<td>int8</td>
<td>整数</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>int16</td>
<td>整数</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td>int32</td>
<td>整数</td>
<td>-2^31 ~ 2^31-1</td>
</tr>
<tr>
<td>int64</td>
<td>整数</td>
<td>-2^63 ~ 2^63-1</td>
</tr>
<tr>
<td>uint8</td>
<td>无符号整数</td>
<td>0 ~ 255</td>
</tr>
<tr>
<td>uint16</td>
<td>无符号整数</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td>uint32</td>
<td>无符号整数</td>
<td>0 ~ 2^32-1</td>
</tr>
<tr>
<td>uint64</td>
<td>无符号整数</td>
<td>0 ~ 2^64-1</td>
</tr>
<tr>
<td>float16</td>
<td>半精度浮点数16位</td>
<td>正负号1位，指数5位，精度10位</td>
</tr>
<tr>
<td>float32</td>
<td>单精度浮点数32位</td>
<td>正负号1位，指数8位，精度23位</td>
</tr>
<tr>
<td>float64</td>
<td>双精度浮点数64位</td>
<td>正负号1位，指数11位，精度52位</td>
</tr>
<tr>
<td>float</td>
<td>双精度浮点数64位</td>
<td>正负号1位，指数11位，精度52位</td>
</tr>
<tr>
<td>complex64</td>
<td>复数</td>
<td>分别用两个32位浮点数表示实部和虚部</td>
</tr>
<tr>
<td>complex128</td>
<td>复数</td>
<td>分别用两个64位浮点数表示实部和虚部</td>
</tr>
<tr>
<td>complex</td>
<td>复数</td>
<td>分别用两个64位浮点数表示实部和虚部</td>
</tr>
</tbody>
</table>
</div>
<h2 id="NumPy类型转换"><a href="#NumPy类型转换" class="headerlink" title="NumPy类型转换"></a>NumPy类型转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.float64(42)</div><div class="line">42.0</div><div class="line">&gt;&gt;&gt; numpy.int8(42.0)</div><div class="line">42</div><div class="line">&gt;&gt;&gt; numpy.bool(42)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; numpy.bool(42.0)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; numpy.float(True)</div><div class="line">1.0</div></pre></td></tr></table></figure>
<p>许多函数的参数中可以指定参数的类型，这个类型参数是可选的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.arange(7, dtype=numpy.uint16)</div><div class="line">array([0, 1, 2, 3, 4, 5, 6], dtype=uint16)</div></pre></td></tr></table></figure>
<h1 id="输出数组"><a href="#输出数组" class="headerlink" title="输出数组"></a>输出数组</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(6)</div><div class="line">&gt;&gt;&gt; print a</div><div class="line">[0 1 2 3 4 5]</div><div class="line"></div><div class="line">&gt;&gt;&gt; b = numpy.arange(12).reshape(4,3)</div><div class="line">&gt;&gt;&gt; print b</div><div class="line">[[ 0  1  2]</div><div class="line"> [ 3  4  5]</div><div class="line"> [ 6  7  8]</div><div class="line"> [ 9 10 11]]</div><div class="line"> </div><div class="line">&gt;&gt;&gt; c = numpy.arange(24).reshape(2,3,4)</div><div class="line">&gt;&gt;&gt; print c</div><div class="line">[[[ 0  1  2  3]</div><div class="line">  [ 4  5  6  7]</div><div class="line">  [ 8  9 10 11]]</div><div class="line"></div><div class="line"> [[12 13 14 15]</div><div class="line">  [16 17 18 19]</div><div class="line">  [20 21 22 23]]]</div></pre></td></tr></table></figure>
<p>如果一个数组太长，则 NumPy 自动省略中间部分而只打印两端的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print numpy.arange(10000)</div><div class="line">[   0    1    2 ..., 9997 9998 9999]</div><div class="line"></div><div class="line">&gt;&gt;&gt; print numpy.arange(10000).reshape(100,100)</div><div class="line">[[   0    1    2 ...,   97   98   99]</div><div class="line"> [ 100  101  102 ...,  197  198  199]</div><div class="line"> [ 200  201  202 ...,  297  298  299]</div><div class="line"> ...,</div><div class="line"> [9700 9701 9702 ..., 9797 9798 9799]</div><div class="line"> [9800 9801 9802 ..., 9897 9898 9899]</div><div class="line"> [9900 9901 9902 ..., 9997 9998 9999]]</div></pre></td></tr></table></figure>
<p>可以通过设置 <code>set_printoptions()</code> 函数来禁用 NumPy 的这种行为并强制打印整个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.set_printoptions(threshold=&apos;nan&apos;)</div><div class="line">&gt;&gt;&gt; print numpy.arange(10000).reshape(100,100)</div></pre></td></tr></table></figure>
<p>此后输出时数组的所有元素都会显示出来。</p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[socket网络通信——TCP/IP客户和服务器]]></title>
      <url>http://lizonghang.github.io/2016/07/18/socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94TCP-IP%E5%AE%A2%E6%88%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="TCP-IP客户和服务器"><a href="#TCP-IP客户和服务器" class="headerlink" title="TCP/IP客户和服务器"></a>TCP/IP客户和服务器</h1><p>套接字可以配置为一个服务器，监听到来的消息，或者也可以配置为客户，连接到其他应用。TCP/IP 套接字的两端连接后，可以完成双向通信。</p>
<h2 id="回应服务器"><a href="#回应服务器" class="headerlink" title="回应服务器"></a>回应服务器</h2><p>下面的例子接收到来的消息，再回复给发送者。首先创建一个 TCP/IP 套接字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div></pre></td></tr></table></figure>
<p>然后使用 <code>bind()</code> 将这个套接字与服务器地址关联。在这里，地址是 localhost （当前服务器），端口号为 10000：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sock.bind((&apos;localhost&apos;, 10000))</div></pre></td></tr></table></figure>
<p>调用 <code>listen()</code> 将这个套接字置为服务器模式，调用 <code>accept()</code> 等待到来的连接。整数参数是在后台排队的连接数，达到这个连接数后，系统会拒绝连接新用户。该例希望一次只处理一个连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sock.listen(1)</div><div class="line">while True:</div><div class="line">    print &apos;wait for a connection&apos;</div><div class="line">    connection, client_address = sock.accept()</div></pre></td></tr></table></figure>
<p><code>accept()</code> 返回服务器和客户之间的一个打开的连接，并返回客户地址。这个连接实际上是另一个端口上的一个不同的套接字（由内核分配）。数据使用 <code>recv()</code> 从连接读取，并用 <code>sendall()</code> 传输。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">    print &apos;connection from &apos;, client_address</div><div class="line">    while True:</div><div class="line">        data = connection.revc(16)</div><div class="line">        print &apos;received &apos;, data</div><div class="line">        if data:</div><div class="line">            print &apos;sending data back to the client&apos;</div><div class="line">            connection.sendall(data)</div><div class="line">        else:</div><div class="line">            print &apos;no data from &apos;, client_address</div><div class="line">            break</div><div class="line">finally:</div><div class="line">    connection.close()</div></pre></td></tr></table></figure>
<p>与一个客户的通信完成时，需要用 <code>close()</code> 清理这个连接。例子使用 <code>finally</code> 确保 <code>close()</code> 总会被调用，即时出现了一个错误也不例外。</p>
<p>服务器端全部代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">sock.bind((&apos;localhost&apos;, 10000))</div><div class="line">sock.listen(1)</div><div class="line">while True:</div><div class="line">    print &apos;wait for a connection&apos;</div><div class="line">    connection, client_address = sock.accept()</div><div class="line">    try:</div><div class="line">        print &apos;connection from &apos;, client_address</div><div class="line">        while True:</div><div class="line">            data = connection.recv(16)</div><div class="line">            print &apos;received &apos;, data</div><div class="line">            if data:</div><div class="line">                print &apos;sending data back to the client&apos;</div><div class="line">                connection.sendall(data)</div><div class="line">            else:</div><div class="line">                print &apos;no data from &apos;, client_address</div><div class="line">                break</div><div class="line">    finally:</div><div class="line">        connection.close()</div><div class="line">        print &apos;connection closed()&apos;</div></pre></td></tr></table></figure>
<h2 id="回应客户"><a href="#回应客户" class="headerlink" title="回应客户"></a>回应客户</h2><p>与服务器不同，客户程序采用另一种方式建立 socket。它不绑定到一个端口并监听，而是使用 <code>connect()</code> 将套接字直接关联到远程地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">print &apos;connecting to server&apos;</div><div class="line">sock.connect((&apos;localhost&apos;, 10000))</div></pre></td></tr></table></figure>
<p>建立连接后，可以通过 socket 利用 <code>sendall()</code> 发送数据，并用 <code>recv()</code> 接收数据，这和服务器中是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">    message = &apos;abcdefghijklmnopqrstuvwxyz&apos;</div><div class="line">    sock.sendall(message)</div><div class="line">    amount_received = 0</div><div class="line">    amount_expected = len(message)</div><div class="line">    while amount_received &lt; amount_expected:</div><div class="line">        data = sock.recv(16)</div><div class="line">        amount_received += len(data)</div><div class="line">        print &apos;received &apos;, data</div><div class="line">finally:</div><div class="line">    print &apos;socket closed&apos;</div><div class="line">    sock.close()</div></pre></td></tr></table></figure>
<p>发送了整个消息并接收到一个副本时，套接字会关闭，以释放端口。</p>
<p>客户端全部代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">print &apos;connecting to server&apos;</div><div class="line">sock.connect((&apos;localhost&apos;, 10000))</div><div class="line">try:</div><div class="line">    message = &apos;abcdefghijklmnopqrstuvwxyz&apos;</div><div class="line">    sock.sendall(message)</div><div class="line">    amount_received = 0</div><div class="line">    amount_expected = len(message)</div><div class="line">    while amount_received &lt; amount_expected:</div><div class="line">        data = sock.recv(16)</div><div class="line">        amount_received += len(data)</div><div class="line">        print &apos;received &apos;, data</div><div class="line">finally:</div><div class="line">    print &apos;socket closed&apos;</div><div class="line">    sock.close()</div></pre></td></tr></table></figure>
<h2 id="客户与服务器"><a href="#客户与服务器" class="headerlink" title="客户与服务器"></a>客户与服务器</h2><p>要在不同的终端窗口运行客户和服务器，使它们能够相互通信。服务器输出显示了到来的连接和数据，以及发回给客户的响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">wait for a connection</div><div class="line">connection from  (&apos;127.0.0.1&apos;, 50124)</div><div class="line">received  abcdefghijklmnop</div><div class="line">sending data back to the client</div><div class="line">received  qrstuvwxyz</div><div class="line">sending data back to the client</div><div class="line">received</div><div class="line">no data from  (&apos;127.0.0.1&apos;, 50124)</div><div class="line">connection closed()</div><div class="line">wait for a connection</div></pre></td></tr></table></figure>
<p>客户端输出显示了来自服务器的响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">connecting to server</div><div class="line">received  abcdefghijklmnop</div><div class="line">received  qrstuvwxyz</div><div class="line">socket closed</div></pre></td></tr></table></figure>
<h2 id="简易客户连接"><a href="#简易客户连接" class="headerlink" title="简易客户连接"></a>简易客户连接</h2><p>如何使用便利函数 <code>create_connection()</code> 来连接服务器，TCP/IP 客户可以省去几步。这个函数只有一个参数，这是一个包含服务器地址的二值元组，函数将由这个参数推导出用于连接的最佳地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">def get_constants(prefix):</div><div class="line">    return dict((getattr(socket, n), n) for n in dir(socket) if n.startswith(prefix))</div><div class="line"></div><div class="line">families = get_constants(&apos;AF_&apos;)</div><div class="line">types = get_constants(&apos;SOCK_&apos;)</div><div class="line">protocols = get_constants(&apos;IPPROTO_&apos;)</div><div class="line"></div><div class="line">sock = socket.create_connection((&apos;localhost&apos;, 10000))</div><div class="line">print &apos;Family: &apos;, families[sock.family]</div><div class="line">print &apos;Type: &apos;, types[sock.type]</div><div class="line">print &apos;Protocol: &apos;, protocols[sock.proto]</div><div class="line">print</div><div class="line"></div><div class="line">try:</div><div class="line">    message = &apos;This is the message, It will be repeated.&apos;</div><div class="line">    print &apos;sending &quot;%s&quot;&apos; % message</div><div class="line">    sock.sendall(message)</div><div class="line">    amount_received = 0</div><div class="line">    amount_expected = len(message)</div><div class="line">    while amount_received &lt; amount_expected:</div><div class="line">        data = sock.recv(16)</div><div class="line">        amount_received += len(data)</div><div class="line">        print &apos;received &quot;%s&quot;&apos; % data</div><div class="line">finally:</div><div class="line">    sock.close()</div><div class="line">    print &apos;socket closed&apos;</div></pre></td></tr></table></figure>
<p><code>create_connection()</code> 使用 <code>getaddrinfo()</code> 来查找候选连接参数，并返回一个打开的 socket，它的第一个配置可以成功创建一个连接。可以检查 family、type 和 proto 属性确定返回的 socket 类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Family:  AF_INET</div><div class="line">Type:  SOCK_STREAM</div><div class="line">Protocol:  IPPROTO_TCP</div><div class="line"></div><div class="line">sending &quot;This is the message, It will be repeated.&quot;</div><div class="line">received &quot;This is the mess&quot;</div><div class="line">received &quot;age, It will be &quot;</div><div class="line">received &quot;repeated.&quot;</div><div class="line">socket closed</div></pre></td></tr></table></figure>
<h2 id="选择监听地址"><a href="#选择监听地址" class="headerlink" title="选择监听地址"></a>选择监听地址</h2><p>将服务器绑定到正确的地址很重要，这样客户才能与之通信。前面的例子都使用 <code>‘localhost’</code> 作为 IP 地址，这会限制为只能连接在同一服务器上运行的客户。可以使用服务器的一个公共地址，如 <code>gethostname()</code> 返回的值，从而允许其他主机连接。下面的例子修改了回应服务器，让它监听一个指定的地址，例如服务器地址 114.215.121.63 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">server_address = (&apos;114.215.121.63&apos;, 10000)</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">sock.bind(server_address)</div><div class="line">sock.listen(1)</div><div class="line">while True:</div><div class="line">    print &apos;wait for a connection&apos;</div><div class="line">    connection, client_address = sock.accept()</div><div class="line">    try:</div><div class="line">        print &apos;client connected: &apos;, client_address</div><div class="line">        while True:</div><div class="line">            data = connection.recv(16)</div><div class="line">            print &apos;received &apos;, data</div><div class="line">            if data:</div><div class="line">                connection.sendall(data)</div><div class="line">            else:</div><div class="line">                break</div><div class="line">    finally:</div><div class="line">        connection.close()</div></pre></td></tr></table></figure>
<p>测试之前，需要对客户程序做类似的修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">server_address = (&apos;114.215.121.63&apos;, 10000)</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">print &apos;connecting to server&apos;</div><div class="line">sock.connect(server_address)</div><div class="line">try:</div><div class="line">    message = &apos;This is the message, it will be repeat later.&apos;</div><div class="line">    print &apos;sending &quot;%s&quot;&apos; % message</div><div class="line">    sock.sendall(message)</div><div class="line">    amount_received = 0</div><div class="line">    amount_expected = len(message)</div><div class="line">    while amount_received &lt; amount_expected:</div><div class="line">        data = sock.recv(16)</div><div class="line">        amount_received += len(data)</div><div class="line">        print &apos;received &apos;, data</div><div class="line">finally:</div><div class="line">    print &apos;socket closed&apos;</div><div class="line">    sock.close()</div></pre></td></tr></table></figure>
<p>在服务器 114.215.121.63 上启动服务器程序，监听端口 10000。在另一个主机上运行客户端程序，会产生以下结果：</p>
<p>服务器端输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wait for a connection</div><div class="line">client connected:  (&apos;171.212.168.187&apos;, 50688)</div><div class="line">received  This is the mess</div><div class="line">received  age, it will be</div><div class="line">received  repeat later.</div><div class="line">received</div><div class="line">wait for a connection</div></pre></td></tr></table></figure>
<p>客户端输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">connecting to server</div><div class="line">sending &quot;This is the message, it will be repeat later.&quot;</div><div class="line">received  This is the mess</div><div class="line">received  age, it will be</div><div class="line">received  repeat later.</div><div class="line">socket closed</div></pre></td></tr></table></figure>
<p>很多服务器有不止一个网络接口，相应的会有不止一个 IP 地址。并不需要运行服务的不同副本分别绑定到各个 IP 地址，可以使用一个特殊的地址 <code>INADDR_ANY</code> 同时监听所有地址。socket 为 <code>INADDR_ANY</code> 定义了一个常量，这是一个整数值，但在传递到 <code>bind()</code> 之前必须将它转换为采用点记法的地址字符串。作为一种快捷方式，可以使用 ‘0.0.0.0’ 或者空串，而不是完成转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server_address = (&apos;&apos;, 10000)</div></pre></td></tr></table></figure>
<p>要看一个套接字使用的具体地址，可以调用其 <code>getsockname()</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">server_address = (&apos;&apos;, 10000)</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">sock.bind(server_address)</div><div class="line">print &apos;starting up on %s, port %s&apos; % sock.getsockname()</div></pre></td></tr></table></figure>
<p>输出的套接字使用的具体地址如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">starting up on 0.0.0.0, port 10000</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 网络通信 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[图像载入、显示、复制、新建和保存]]></title>
      <url>http://lizonghang.github.io/2016/07/17/OpenCV-Python%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>OpenCV的全称是Open Source Computer Vision Library，是一个跨平台的计算机视觉库。OpenCV可用于开发实时的图像处理、计算机视觉以及模式识别程序。OpenCV可用于解决如下领域的问题：</p>
<ul>
<li>人机交互</li>
<li>物体识别</li>
<li>图像分区</li>
<li>人脸识别</li>
<li>动作识别</li>
<li>运动跟踪</li>
<li>机器人</li>
</ul>
<p>OpenCV可以在Windows, Android, Maemo, FreeBSD, OpenBSD, iOS, Linux和Mac OS等平台上运行。</p>
<p>OpenCV1.0时代的基于 C 语言接口而建的图像存储格式IplImage*，如果在退出前忘记release掉的话，就会照成内存泄露。这导致debug时越来越多的纠缠于内存管理，而不是着力解决开发目标。但自从OpenCV踏入2.0时代用Mat类数据结构作为主打之后，OpenCV变得越发像Matlab那样，上手非常快。甚至有些函数名称都和matlab一样，比如大家所熟知的imread，imwrite，imshow等函数。</p>
<p><code>cv::Mat</code>类是用于保存图像以及其他矩阵数据的数据结构。默认情况下，其尺寸为0，我们也可以指定初始尺寸,比如定义一个Mat类对象，就要写<code>cv::Mat pic(320,640,cv::Scalar(100));</code>。它是对应于OpenCV1.0时代的IplImage的主要用来存放图像的数据结构。</p>
<h1 id="读取并显示图像"><a href="#读取并显示图像" class="headerlink" title="读取并显示图像"></a>读取并显示图像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;) # 读取文件</div><div class="line">cv2.namedWindow(&apos;lena&apos;) # 创建窗口</div><div class="line">cv2.imshow(&apos;lena&apos;, im) # 在窗口显示图像</div><div class="line"># cv2.waitKey(10000) # 等待10s</div><div class="line">cv2.waitKey(0) # 保持等待直到按下任意键</div><div class="line">cv2.destroyAllWindows() # 释放窗口</div></pre></td></tr></table></figure>
<h1 id="创建-复制图像"><a href="#创建-复制图像" class="headerlink" title="创建/复制图像"></a>创建/复制图像</h1><p>新的OpenCV的接口中没有CreateImage接口，如果要创建图像，需要使用numpy的函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">emptyImage = numpy.zeros(im.shape, numpy.uint8)</div></pre></td></tr></table></figure>
<p>图像使用NumPy数组的属性来表示图像的尺寸和通道信息。如果输出im.shape，将得到(750, 500, 3)，最后的3表示这是一个RGB图像。</p>
<p>也可以复制原图像得到新图像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tempImage = im.copy()</div></pre></td></tr></table></figure>
<p>还可以用cvtColor获得原图像的副本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tempImage = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)  </div><div class="line">tempImage[...] = 0 # 转成空白的黑色图像</div></pre></td></tr></table></figure>
<h1 id="保存图像"><a href="#保存图像" class="headerlink" title="保存图像"></a>保存图像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.imwrite(&apos;/Users/mac/Desktop/temp.jpg&apos;, tempImage)</div></pre></td></tr></table></figure>
<p>imwrite()有第三个可选参数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.imwrite(&apos;/Users/mac/Desktop/temp.jpg&apos;, tempImage, [int(cv2.IMWRITE_JPEG_QUALITY), 5])</div></pre></td></tr></table></figure>
<p>第三个参数针对特定的格式：</p>
<ul>
<li>对于JPEG，第三个参数表示的是图像的质量，用0-100的整数表示，默认为95。<code>cv2.IMWRITE_JPEG_QUALITY</code>类型为Long，必须转换成int。下面是以不同质量存储的两幅图：</li>
</ul>
<p>图像质量保存为5时：</p>
<p><img src="/images/temp_5.jpg" alt=""></p>
<p>图像质量保存为100时：</p>
<p><img src="/images/temp_100.jpg" alt=""></p>
<ul>
<li>对于PNG，第三个参数表示的是压缩级别。cv2.IMWRITE_PNG_COMPRESSION，从0到9,压缩级别越高，图像尺寸越小。默认级别为3：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cv2.imwrite(&quot;temp0.png&quot;, tempImage, [int(cv2.IMWRITE_PNG_COMPRESSION), 0])   </div><div class="line">cv2.imwrite(&quot;temp9.png&quot;, tempImage, [int(cv2.IMWRITE_PNG_COMPRESSION), 9])</div></pre></td></tr></table></figure>
<p>得到的图片存储大小分别为929KB和317KB</p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac上安装python-opencv]]></title>
      <url>http://lizonghang.github.io/2016/07/16/Mac%E4%B8%8A%E5%AE%89%E8%A3%85python-opencv/</url>
      <content type="html"><![CDATA[<p>如何正确安装OpenCV历来是一个堪称玄学的问题，在成功安装OpenCV的道路上经历了种种艰辛，这真的是我最恶心的一次安装经历。下载源码并编译的方法就不说了，下面介绍较简易的使用Homebrew安装的方法。</p>
<p>第一步：安装OpenCV</p>
<p>直接使用命令<code>brew install opencv</code>是不行的，因为homebrew找不到它，会产生如下报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">➜  ~ brew install opencv</div><div class="line">Error: No available formula with the name &quot;opencv&quot;</div><div class="line">==&gt; Searching for similarly named formulae...</div><div class="line">Error: No similarly named formulae found.</div><div class="line">==&gt; Searching taps...</div><div class="line">These formulae were found in taps:</div><div class="line">homebrew/science/opencv                  homebrew/science/opencv3</div><div class="line">To install one of them, run (for example):</div><div class="line">  brew install homebrew/science/opencv</div><div class="line">==&gt; You haven&apos;t updated Homebrew in a while.</div><div class="line">A formula for opencv might have been added recently.</div><div class="line">Run `brew update` to get the latest Homebrew updates!</div></pre></td></tr></table></figure>
<p>你需要先将opencv所在的science分类加入homebrew的搜索列表中再尝试下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ brew tap homebrew/science</div><div class="line">$ brew install opencv</div></pre></td></tr></table></figure>
<p>请留意安装过程中的输出信息，最好保存一下，之后可能有用，确保opencv正确安装后就可以删掉了。</p>
<p>安装过程中自动为你安装好了以下库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">==&gt; Installing dependencies for homebrew/science/opencv: eigen, ilmbase,</div><div class="line">==&gt; Installing homebrew/science/opencv dependency: eigen</div><div class="line">🍺  /usr/local/Cellar/eigen/3.2.8: 368 files, 3.5M</div><div class="line">==&gt; Installing homebrew/science/opencv dependency: ilmbase</div><div class="line">🍺  /usr/local/Cellar/ilmbase/2.2.0: 362 files, 5.6M</div><div class="line">==&gt; Installing homebrew/science/opencv dependency: openexr</div><div class="line">🍺  /usr/local/Cellar/openexr/2.2.0: 131 files, 11.4M</div><div class="line">==&gt; Installing homebrew/science/opencv dependency: homebrew/python/numpy</div><div class="line">🍺  /usr/local/Cellar/numpy/1.11.1: 430 files, 9M</div><div class="line">==&gt; Installing homebrew/science/opencv</div><div class="line">🍺  /usr/local/Cellar/opencv/2.4.13: 276 files, 35.8M</div></pre></td></tr></table></figure>
<p>其中已为你安装好numpy，其版本为1.11.1，如果你此前已经通过pip安装过numpy了，那需要很多额外步骤。</p>
<p>进入python环境，测试opencv是否正确安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import cv2</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ImportError: No module named cv2</div></pre></td></tr></table></figure>
<p>python找不到opencv，这就蛋疼了。翻看opencv的安装记录，有如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Python modules have been installed and Homebrew&apos;s site-packages is not</div><div class="line">in your Python sys.path, so you will not be able to import the modules</div><div class="line">this formula installed. If you plan to develop with these modules,</div><div class="line">please run:</div><div class="line">  mkdir -p /Users/mac/Library/Python/2.7/lib/python/site-packages</div><div class="line">  echo &apos;import site; site.addsitedir(&quot;/usr/local/lib/python2.7/site-packages&quot;)&apos; &gt;&gt; /Users/mac/Library/Python/2.7/lib/python/site-packages/homebrew.pth</div></pre></td></tr></table></figure>
<p>Homebrew的site-packages不在python的sys.path路径中，所以python无法导入安装好的opencv模块，如果想要python能够找到，执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir -p /Users/mac/Library/Python/2.7/lib/python/site-packages</div><div class="line">$ echo &apos;import site; site.addsitedir(&quot;/usr/local/lib/python2.7/site-packages&quot;)&apos; &gt;&gt; /Users/mac/Library/Python/2.7/lib/python/site-packages/homebrew.pth</div></pre></td></tr></table></figure>
<p>再尝试<code>import cv2</code>，可能会有如下报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RuntimeError: module compiled against API version 0xa but this version of numpy is 0x9</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ImportError: numpy.core.multiarray failed to import</div></pre></td></tr></table></figure>
<p>这是由于numpy版本过低导致的，可能是你系统中已经安装的numpy版本不能满足opencv的需求。并且没有提示找不到模块，所以python能正确找到opencv了。尝试<code>sudo pip uninstall numpy</code>，可能会有下面的报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Exception:</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/basecommand.py&quot;, line 215, in main</div><div class="line">    status = self.run(options, args)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/commands/uninstall.py&quot;, line 76, in run</div><div class="line">    requirement_set.uninstall(auto_confirm=options.yes)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/req/req_set.py&quot;, line 336, in uninstall</div><div class="line">    req.uninstall(auto_confirm=auto_confirm)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/req/req_install.py&quot;, line 742, in uninstall</div><div class="line">    paths_to_remove.remove(auto_confirm)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/req/req_uninstall.py&quot;, line 115, in remove</div><div class="line">    renames(path, new_path)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/utils/__init__.py&quot;, line 267, in renames</div><div class="line">    shutil.move(old, new)</div><div class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 302, in move</div><div class="line">    copy2(src, real_dst)</div><div class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 131, in copy2</div><div class="line">    copystat(src, dst)</div><div class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 103, in copystat</div><div class="line">    os.chflags(dst, st.st_flags)</div><div class="line">OSError: [Errno 1] Operation not permitted: &apos;/tmp/pip-8Z9Jmh-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy-1.8.0rc1-py2.7.egg-info&apos;</div><div class="line">The directory &apos;/Users/mac/Library/Caches/pip/http&apos; or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo&apos;s -H flag.</div></pre></td></tr></table></figure>
<p>并且，在使用<code>sudo pip install matplotlib</code>时也有类似的报错。可以改成<code>sudo pip install --ignore-installed matplotlib</code>试试。</p>
<p>这是由于System Integrity Protection导致的，需要关闭保护SIP，否则即时加了sudo也没用，尝试卸载和升级都需要关闭保护SIP。后面会介绍一种更简单的方法，这一段可略过。具体操作如下：</p>
<ol>
<li>重启电脑，电脑启动的时候按住command+R</li>
<li>等画面上显示苹果logo后会看到[OS X 工具程式]窗口，选择终端，要把键盘按下去，不要轻按</li>
<li>终端打开后输入<code>csrutil disable</code>，之后重启</li>
</ol>
<p>重启之后再升级或重装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install --upgrade numpy</div></pre></td></tr></table></figure>
<p>另一种更简单的方式和安装opencv时一样隐藏在安装信息中，就在opencv路径信息的上一段里，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &apos;import sys; sys.path.insert(1, &quot;/usr/local/lib/python2.7/site-packages&quot;)&apos; &gt;&gt; /Users/mac/Library/Python/2.7/lib/python/site-packages/homebrew.pth</div></pre></td></tr></table></figure>
<p>由于<code>mkdir -p /Users/mac/Library/Python/2.7/lib/python/site-packages</code>之前已经创建过了，可以不再创建。执行完命令后，重启一下终端，再进入python环境测试是否能正确导入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import cv2</div><div class="line">&gt;&gt;&gt; import numpy</div><div class="line">&gt;&gt;&gt; from matplotlib import pyplot</div></pre></td></tr></table></figure>
<p>本机异常已消除，若还有其他异常，请另行寻找解决方法。以下是本机安装的版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print cv2.__version__</div><div class="line">2.4.13</div><div class="line">&gt;&gt;&gt; print numpy.__version__</div><div class="line">1.11.1</div><div class="line">&gt;&gt;&gt; print matplotlib.__version__</div><div class="line">1.3.1</div></pre></td></tr></table></figure>
<p>希望这篇文章能帮助你脱离玄学的道路。</p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[儿童锁屏幕监测报警]]></title>
      <url>http://lizonghang.github.io/2016/07/15/%E5%84%BF%E7%AB%A5%E9%94%81%E5%B1%8F%E5%B9%95%E7%9B%91%E6%B5%8B%E6%8A%A5%E8%AD%A6/</url>
      <content type="html"><![CDATA[<p>这是一个丧尽天良的程序，用于家长对孩子使用电脑时的监控，当程序发现屏幕上出现了疑似色情的图片/视频时，将屏幕进行截图保存并邮件通知家长，也能判断出程序是否正常退出。可以设置采样间隔与监控时间，可以设置截图保存路径与图片尺寸。</p>
<p>假设文件名为ScreenScrape.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># encoding: utf-8</div><div class="line">from PIL import Image, ImageGrab</div><div class="line">import time</div><div class="line">import argparse</div><div class="line">import smtplib</div><div class="line">from email import encoders</div><div class="line">from email.header import Header</div><div class="line">from email.mime.text import MIMEText</div><div class="line">from email.utils import parseaddr, formataddr</div><div class="line"></div><div class="line">parser = argparse.ArgumentParser()</div><div class="line">parser.add_argument(&apos;p&apos;, help=&apos;Path to Save the Images.&apos;)</div><div class="line">parser.add_argument(&apos;-W&apos;, help=&apos;Width of the Scraped Images&apos;, default=1000)</div><div class="line">parser.add_argument(&apos;-H&apos;, help=&apos;Height of the Scraped Images.&apos;, default=600)</div><div class="line">parser.add_argument(&apos;-d&apos;, help=&apos;Scrape Duration(Minute).&apos;, default=1)</div><div class="line">parser.add_argument(&apos;-t&apos;, help=&apos;Total Scrape Time(Minute)&apos;, default=30)</div><div class="line">args = parser.parse_args()</div><div class="line"># 图片存放路径、图片尺寸、检测间隔、检测时长</div><div class="line">path, width, height, duration, totalTime = args.p, int(args.W), int(args.H), float(args.d), float(args.t)</div><div class="line"></div><div class="line">message = u&apos;屏幕检测到异常截图，请及时查看您的电脑&apos;</div><div class="line">fromUser = &apos;user_to_send_email&apos;</div><div class="line">password = &apos;vaelgxgnybtlbafd&apos; # 开启SMTP/POP3等，获得的校验码为密码，不是登陆密码</div><div class="line">toUser = &apos;user_to_receive_email&apos;</div><div class="line">smtp_server = &apos;smtp.qq.com&apos; # 可以是其他邮件代理服务器</div><div class="line"></div><div class="line">send_once = False # 只发送一次邮件</div><div class="line"></div><div class="line">start_time = int(time.time())</div><div class="line">def inTotalTime():</div><div class="line">    &apos;&apos;&apos;判断检测时间是否到时，上限时间totalTime&apos;&apos;&apos;</div><div class="line">    now_time = int(time.time())</div><div class="line">    elapseTimeByMinutes = (now_time - start_time) / 60.0</div><div class="line">    if elapseTimeByMinutes &lt; totalTime:</div><div class="line">        return True</div><div class="line">    else:</div><div class="line">        return False</div><div class="line"></div><div class="line">def _format_addr(s):</div><div class="line">    &apos;&apos;&apos;调整邮件信息格式&apos;&apos;&apos;</div><div class="line">    name, addr = parseaddr(s)</div><div class="line">    return formataddr((Header(name, &apos;utf-8&apos;).encode(), addr.encode(&apos;utf-8&apos;) if isinstance(addr, unicode) else addr))</div><div class="line"></div><div class="line">def sendMessage(message, fromUser, password, toUser, smtp_server):</div><div class="line">    &apos;&apos;&apos;发送邮件&apos;&apos;&apos;</div><div class="line">    msg = MIMEText(message, &apos;plain&apos;, &apos;utf-8&apos;)</div><div class="line">    # 下面三项不标明可能被当作垃圾邮件，导致接收方收不到邮件</div><div class="line">    msg[&apos;From&apos;] = _format_addr(u&apos;Mac管理员-%s&apos; % fromUser) # 邮件中标明发件人</div><div class="line">    msg[&apos;To&apos;] = _format_addr(u&apos;家长-%s&apos; % toUser) # 邮件中标明收件人</div><div class="line">    msg[&apos;Subject&apos;] = Header(u&apos;屏幕监测报告&apos;, &apos;utf-8&apos;).encode() # 邮件标题</div><div class="line">    server = smtplib.SMTP_SSL(smtp_server, 465)</div><div class="line">    # server.set_debuglevel(1) # 发送邮件过程中的详细信息</div><div class="line">    server.login(fromUser, password)</div><div class="line">    server.sendmail(fromUser, toUser, msg.as_string())</div><div class="line">    server.quit()</div><div class="line"></div><div class="line">def handleRudeImage(im):</div><div class="line">    &apos;&apos;&apos;保存截图并发送邮件通知&apos;&apos;&apos;</div><div class="line">    filename = str(int(time.time())) + &apos;.jpg&apos;</div><div class="line">    im.save(path+filename, &apos;JPEG&apos;)</div><div class="line">    global send_once</div><div class="line">    if not send_once:</div><div class="line">        sendMessage(message, fromUser, password, toUser, smtp_server)</div><div class="line">        send_once = True</div><div class="line"></div><div class="line">def screenScrape():</div><div class="line">    &apos;&apos;&apos;屏幕截取、鉴黄与处置&apos;&apos;&apos;</div><div class="line">    im = ImageGrab.grab().resize((width, height)).convert(&apos;YCbCr&apos;)</div><div class="line">    w, h = im.size</div><div class="line">    sx = im.getdata()</div><div class="line">    count = 0</div><div class="line">    for i, ycbcr in enumerate(sx):</div><div class="line">        y, cb, cr = ycbcr</div><div class="line">        if 86 &lt;= cb &lt;= 117 and 140 &lt;= cr &lt;= 168:</div><div class="line">            count += 1</div><div class="line">    if count &gt; w * h * 0.3:</div><div class="line">        handleRudeImage(im)</div><div class="line">#        print &apos;Sexy Playing&apos;</div><div class="line">#    else:</div><div class="line">#        print &apos;Normal&apos;</div><div class="line">    im.close()</div><div class="line"></div><div class="line">while inTotalTime():</div><div class="line">    time.sleep(duration*60) # 间隔duration分钟对屏幕采样</div><div class="line">    screenScrape()</div><div class="line"></div><div class="line"># 程序正常退出提醒</div><div class="line">sendMessage(u&apos;监控程序正常退出&apos;, fromUser, password, toUser, smtp_server)</div></pre></td></tr></table></figure>
<p>运行程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python ScreenScrape.py path [-W Width] [-H Height] [-d duration] [-t totalTime]</div></pre></td></tr></table></figure>
<ul>
<li>path - 存放截图的文件夹，必选</li>
<li>Width - 存储截图时的截图宽度，可选</li>
<li>Height - 存储截图时的截图高度，可选</li>
<li>duration - 采样周期，单位min，可选</li>
<li>totalTime - 监控时长，单位min，可选</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[多张图片合成GIF图]]></title>
      <url>http://lizonghang.github.io/2016/07/14/%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90GIF%E5%9B%BE/</url>
      <content type="html"><![CDATA[<h1 id="需要的库"><a href="#需要的库" class="headerlink" title="需要的库"></a>需要的库</h1><h2 id="PIL"><a href="#PIL" class="headerlink" title="PIL"></a>PIL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install Pillow</div></pre></td></tr></table></figure>
<h2 id="images2gif"><a href="#images2gif" class="headerlink" title="images2gif"></a>images2gif</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install images2gif</div></pre></td></tr></table></figure>
<h1 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h1><p>将以下gif图分割为多张静态PNG格式图，并以这些PNG图为例：</p>
<p><img src="/images/niko.gif" alt=""></p>
<h1 id="帧分割"><a href="#帧分割" class="headerlink" title="帧分割"></a>帧分割</h1><p>由于需要将图片按顺序进行合成，需要将图片在文件夹中顺序排列。假设文件名为split.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line"></div><div class="line">im = Image.open(&apos;niko.gif&apos;)</div><div class="line">im.seek(0)</div><div class="line"></div><div class="line">try:</div><div class="line">    while True:</div><div class="line">        im.save(&apos;./nikos/&apos; + chr(im.tell() + ord(&apos;a&apos;))  + &apos;.png&apos;, &apos;PNG&apos;)</div><div class="line">        im.seek(im.tell()+1)</div><div class="line">except EOFError, msg:</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>执行分割GIF图程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python split.py</div></pre></td></tr></table></figure>
<p>将得到的图片放置于nikos/文件夹中</p>
<h1 id="帧合成"><a href="#帧合成" class="headerlink" title="帧合成"></a>帧合成</h1><p>假设文件名为GetGifAnimation.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">#encoding: utf-8</div><div class="line">from PIL import Image</div><div class="line">import os</div><div class="line">import images2gif</div><div class="line">import argparse</div><div class="line"></div><div class="line">parser = argparse.ArgumentParser()</div><div class="line">parser.add_argument(&apos;image_path&apos;, help=&apos;The Path to Source Images, to Create the Gif Animation.&apos;)</div><div class="line">parser.add_argument(&apos;-T&apos;, help=&apos;Target to Save the Gif&apos;, default=&apos;./generate.gif&apos;)</div><div class="line">parser.add_argument(&apos;-W&apos;, help=&apos;Width of the Gif&apos;, default=300)</div><div class="line">parser.add_argument(&apos;-H&apos;, help=&apos;Height of the Gif&apos;, default=281)</div><div class="line">args = parser.parse_args()</div><div class="line">srcImageFilePath = args.image_path</div><div class="line">if srcImageFilePath.split(&apos;/&apos;)[-1]:</div><div class="line">    srcImageFilePath += &apos;/&apos;</div><div class="line">targetGIFPath = args.T</div><div class="line">targetGIFWidth = args.W</div><div class="line">targetGIFHeight = args.H</div><div class="line">targetSize = (targetGIFWidth, targetGIFHeight)</div><div class="line"></div><div class="line">def GetGifAnimationFromImages(srcImageFilePath):</div><div class="line">    images = []</div><div class="line">    for item in os.listdir(srcImageFilePath):</div><div class="line">        suffix = item.split(&apos;.&apos;)[-1]</div><div class="line">        if suffix == &apos;png&apos;:</div><div class="line">            images.append(Image.open(srcImageFilePath + item).resize(targetSize))</div><div class="line">    images2gif.writeGif(targetGIFPath, images, duration=0.1, nq=0.1)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    GetGifAnimationFromImages(srcImageFilePath)</div></pre></td></tr></table></figure>
<h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python GetGifAnimation.py &lt;path-to-images&gt; [-T targetGIFPath] [-W targetGIFWidth] [-H targetGIFHeight]</div></pre></td></tr></table></figure>
<p>合成的gif图为generate.gif</p>
<h1 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h1><h2 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;images2gif.py&quot;, line 436, in writeGifToFile</div><div class="line">  fp.write(globalPalette)</div><div class="line">TypeError: must be string or buffer, not None</div></pre></td></tr></table></figure>
<p>将images2gif.py文件中的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for im in images:</div><div class="line">    palettes.append( getheader(im)[1] )</div></pre></td></tr></table></figure>
<p>更改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for im in images:</div><div class="line">    palettes.append(im.palette.getdata()[1])</div></pre></td></tr></table></figure>
<h2 id="ValueError"><a href="#ValueError" class="headerlink" title="ValueError"></a>ValueError</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;./GetGifAnimation.py&quot;, line 31, in &lt;module&gt;</div><div class="line">    GetGifAnimationFromImages(srcImageFilePath)</div><div class="line">  File &quot;./GetGifAnimation.py&quot;, line 28, in GetGifAnimationFromImages</div><div class="line">    images2gif.writeGif(targetGIFPath, images, duration=0.1, nq=0.1)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/images2gif/images2gif.py&quot;, line 572, in writeGif</div><div class="line">    images, xy, images_info = gifWriter.handleSubRectangles(images, subRectangles)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/images2gif/images2gif.py&quot;, line 295, in handleSubRectangles</div><div class="line">    images, xy = self.getSubRectangles(images)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/images2gif/images2gif.py&quot;, line 332, in getSubRectangles</div><div class="line">    diff = np.abs(im-prev)</div><div class="line">ValueError: operands could not be broadcast together with shapes (281,300,4) (281,300,3)</div></pre></td></tr></table></figure>
<p>错误的原因是存在png图片（a.png）不含有alpha通道，可能是分割GIF图时PIL库中代码导致透明通道丢失。可以手动将图片导出为带alpha通道的PNG图片，ValueError即解除。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[socket网络通信——寻址、协议簇和套接字类型]]></title>
      <url>http://lizonghang.github.io/2016/07/14/socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94%E5%AF%BB%E5%9D%80%E3%80%81%E5%8D%8F%E8%AE%AE%E7%B0%87%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;socket模块提供了一个底层C API，可以使用BSD套接字接口实现网络通信。它包括socket类，用于处理具体的数据通道，还包括用于完成网络相关任务的函数，如将一个服务器名称转换为一个地址，以及格式化数据以便在网络上发送。</p>
<h1 id="寻址、协议簇和套接字类型"><a href="#寻址、协议簇和套接字类型" class="headerlink" title="寻址、协议簇和套接字类型"></a>寻址、协议簇和套接字类型</h1><p>&emsp;&emsp;套接字（socket）是程序在本地或者通过互联网来回传递数据时所用通信通道的一个端点。套接字有两个主要属性来控制如何发送数据：地址簇（address family）控制所用的OSI网络层协议，套接字类型（socket type）控制传输层协议。</p>
<p>&emsp;&emsp;Python支持3个地址簇。最常用的是AF_INET，用于IPv4 Internet寻址。IPv4地址长度为4个字节，通常表示为4个数的序列，每个字节对应一个数，用点号分隔（如10.1.1.5和127.0.0.1）。这些值通常被称为“IP地址”。目前几乎所有互联网网络应用都使用IPv4.</p>
<p>&emsp;&emsp;AF_INET6用于IPv6 Internet寻址。IPv6是下一代Internet协议。它支持128位地址和通信流调整，还支持IPv4所不支持的一些路由特性。目前采用IPv6的应用还很有限，不过在不断增长。</p>
<p>&emsp;&emsp;AF_UNIX是UNIX域套接字（UNIX Domain Sockets， UDS）的地址簇，这是一种POSIX兼容系统上的进程间通信协议。UDS的实现通常允许操作系统直接从进程向进程传递数据，而不用通过网络栈。这比使用AF_INET更高效，但是由于要用文件系统作为寻址的命名空间，UDS仅限于同一个系统上的进程。相比其他IPC机制（如命名管道或共享内存），使用UDS的优势在于它与IP网络应用的编程接口是一样的。这说明应用在单个主机上运行时可以利用高效的通信，在网络上发送数据时仍然可以使用同样的代码。</p>
<pre>注意：AF_UNIX常量仅在支持UDS的系统上定义。</pre>

<p>&emsp;&emsp;套接字类型往往是SOCK_DGRAM或SOCK_STREAM，SOCK_DGRAM对应用户数据报协议（user datagram protocol，UDP），SOCK_STREAM对应传输控制协议（transmission control protocol，TCP）。UDP不需要传输握手过程或其他设置过程（setup），但是提供的传输可靠性较低。UDP消息可能乱序传送，也可能传送多次，或者根本不传送。TCP则相反，可以确保每个消息只传送一次，而且按正确的顺序传送。不过，由于增加了可靠性，可能会引入额外的延迟，因为数据报可能需要重新传输。大多数传送大量数据的应用协议（如HTTP）都建立在TCP基础上。UDP通常用于顺序不太重要的协议（因为消息可以放在一个数据包中，例如DNS），或者用于广播（向多个主机发送相同的数据）。</p>
<h2 id="在网络上查找主机"><a href="#在网络上查找主机" class="headerlink" title="在网络上查找主机"></a>在网络上查找主机</h2><p>&emsp;&emsp;socket包含一些函数与网络上的域名服务交互，使得程序可以将服务器的主机名转换为其数字网络地址。应用使用地址来连接一个服务器之前不需要显式转换地址，不过报告错误时除了报告所用的名字之外，还包含这个数字地址会很有用。</p>
<h3 id="socket-gethostname"><a href="#socket-gethostname" class="headerlink" title="socket.gethostname()"></a>socket.gethostname()</h3><p>&emsp;&emsp;要查找当前主机的名字，可以使用<code>gethostname()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import socket</div><div class="line">&gt;&gt;&gt; print socket.gethostname()</div><div class="line">macdeMacBook-Pro.local</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回的名字取决于当前系统的网络设置，在不同的网络上返回的名字可能有变化（如一个连接到WLAN的笔记本电脑）。</p>
<h3 id="socket-gethostbyname"><a href="#socket-gethostbyname" class="headerlink" title="socket.gethostbyname()"></a>socket.gethostbyname()</h3><p>&emsp;&emsp;下面使用<code>gethostbyname()</code>访问操作系统主机名解析API，将服务器名字转换为其数字地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import socket</div><div class="line">&gt;&gt;&gt; for host in [&apos;homer&apos;, &apos;www&apos;, &apos;www.python.org&apos;, socket.gethostname()]:</div><div class="line">...     try:</div><div class="line">...             print &apos;%s : %s&apos; % (host, socket.gethostbyname(host))</div><div class="line">...     except socket.error, msg:</div><div class="line">...             print &apos;%s : %s&apos; % (host, msg)</div><div class="line">... </div><div class="line">homer : [Errno 8] nodename nor servname provided, or not known</div><div class="line">www : [Errno 8] nodename nor servname provided, or not known</div><div class="line">www.python.org : 151.101.36.223</div><div class="line">macdeMacBook-Pro.local : 192.168.0.101</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果当前系统的DNS配置在搜索中包括一个或多个域，名字（name）参数不要求是完全限定名（不需要包含域名和基名）。如果一个名字无法找到，会产生一个socket.error类型的异常。</p>
<h3 id="socket-gethostbyname-ex"><a href="#socket-gethostbyname-ex" class="headerlink" title="socket.gethostbyname_ex()"></a>socket.gethostbyname_ex()</h3><p>&emsp;&emsp;要访问有关服务器的更多命名信息，可以使用函数<code>gethostbyname_ex()</code>，它会返回服务器的标准主机名、所有别名，以及可以用来到达这个主机的所有可用IP地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import socket</div><div class="line">&gt;&gt;&gt; for host in [&apos;baidu.com&apos;, &apos;www.python.org&apos;, socket.gethostname(), &apos;nosuchname&apos;]:</div><div class="line">...     print host</div><div class="line">...     try:</div><div class="line">...             hostname, aliases, addresses = socket.gethostbyname_ex(host)</div><div class="line">...             print &apos; Hostname:&apos;, hostname</div><div class="line">...             print &apos; Aliases:&apos;, aliases</div><div class="line">...             print &apos; Addresses:&apos;, addresses</div><div class="line">...     except socket.error as msg:</div><div class="line">...             print &apos;ERROR:&apos;, msg</div><div class="line">...     print</div><div class="line">...</div><div class="line">baidu.com</div><div class="line"> Hostname: baidu.com</div><div class="line"> Aliases: []</div><div class="line"> Addresses: [&apos;111.13.101.208&apos;, &apos;123.125.114.144&apos;, &apos;180.149.132.47&apos;, &apos;220.181.57.217&apos;]</div><div class="line"></div><div class="line">www.python.org</div><div class="line"> Hostname: prod.python.map.fastlylb.net</div><div class="line"> Aliases: [&apos;www.python.org&apos;, &apos;python.map.fastly.net&apos;]</div><div class="line"> Addresses: [&apos;151.101.16.223&apos;]</div><div class="line"></div><div class="line">macdeMacBook-Pro.local</div><div class="line"> Hostname: macdemacbook-pro.local</div><div class="line"> Aliases: []</div><div class="line"> Addresses: [&apos;10.200.55.2&apos;, &apos;10.57.129.2&apos;, &apos;192.168.0.103&apos;]</div><div class="line"></div><div class="line">nosuchname</div><div class="line">ERROR: [Errno 8] nodename nor servname provided, or not known</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果能得到一个服务器的所有已知IP地址，客户端就可以实现其自己的负载平衡或故障恢复算法。</p>
<h3 id="socket-gethostbyaddr"><a href="#socket-gethostbyaddr" class="headerlink" title="socket.gethostbyaddr()"></a>socket.gethostbyaddr()</h3><p>&emsp;&emsp;如果得到一个服务器的地址，可以使用<code>gethostbyaddr()</code>完成一个逆向查找来得到主机名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import socket</div><div class="line">&gt;&gt;&gt; hostname, aliases, addresses = socket.gethostbyaddr(&apos;127.0.0.1&apos;)</div><div class="line">&gt;&gt;&gt; print &apos;Hostname: %s\nAliases: %s\nAddresses: %s&apos; % (hostname, aliases, addresses)</div><div class="line">Hostname: localhost</div><div class="line">Aliases: [&apos;1.0.0.127.in-addr.arpa&apos;]</div><div class="line">Addresses: [&apos;127.0.0.1&apos;]</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回值是一个元组，其中包含完全主机名、所有别名、以及与这个名字关联的所有IP地址。</p>
<h2 id="查找服务信息"><a href="#查找服务信息" class="headerlink" title="查找服务信息"></a>查找服务信息</h2><p>&emsp;&emsp;除了IP地址之外，每个套接字地址还包括一个整数端口号（port number）。很多应用可以在用一个端口上运行并监听一个IP地址，不过一次只有一个套接字可以使用该地址端口。通过结合IP地址、协议和端口号，可以唯一的标识一个通信通道，确保通过一个套接字发送的消息可以到达正确的目标。</p>
<h3 id="socket-getservbyname"><a href="#socket-getservbyname" class="headerlink" title="socket.getservbyname()"></a>socket.getservbyname()</h3><p>&emsp;&emsp;有些端口号已经预先分配给某个特定的协议。例如，使用SMTP的 email 服务器使用 TCP 在端口25相互通信，Web 客户和服务器使用 80 作为 HTTP 的端口号。网络服务的端口号和标准名可以使用 <code>getservbyname()</code> 查找：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print socket.getservbyname(&apos;ftp&apos;)</div><div class="line">21</div><div class="line">&gt;&gt;&gt; print socket.getservbyname(&apos;https&apos;)</div><div class="line">443</div><div class="line">&gt;&gt;&gt; print socket.getservbyname(&apos;http&apos;)</div><div class="line">80</div><div class="line">&gt;&gt;&gt; print socket.getservbyname(&apos;smtp&apos;)</div><div class="line">25</div></pre></td></tr></table></figure>
<h3 id="socket-getservbyport"><a href="#socket-getservbyport" class="headerlink" title="socket.getservbyport()"></a>socket.getservbyport()</h3><p>要逆向完成服务端口查找，可以使用 <code>getservbyport</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print socket.getservbyport(80)</div><div class="line">http</div></pre></td></tr></table></figure>
<h3 id="socket-getprotobyname"><a href="#socket-getprotobyname" class="headerlink" title="socket.getprotobyname()"></a>socket.getprotobyname()</h3><p>可以使用 <code>getprotobyname()</code> 获取分配给一个传输协议的端口号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print socket.getprotobyname(&apos;tcp&apos;)</div><div class="line">6</div><div class="line">&gt;&gt;&gt; print socket.getprotobyname(&apos;udp&apos;)</div><div class="line">17</div><div class="line">&gt;&gt;&gt; print socket.getprotobyname(&apos;icmp&apos;)</div><div class="line">1</div></pre></td></tr></table></figure>
<p>协议码值是标准化的，作为常量在 socket 中定义，这些协议码都有前缀 <code>IPPROTO_</code>：</p>
<ul>
<li>TCP - <code>socket.IPPROTO_TCP = 6</code></li>
<li>UDP - <code>socket.IPPROTO_UDP = 17</code></li>
<li>ICMP - <code>socket.IPPROTO_ICMP = 1</code> </li>
</ul>
<h2 id="查找服务器地址"><a href="#查找服务器地址" class="headerlink" title="查找服务器地址"></a>查找服务器地址</h2><h3 id="socket-getaddrinfo"><a href="#socket-getaddrinfo" class="headerlink" title="socket.getaddrinfo()"></a>socket.getaddrinfo()</h3><p><code>getaddrinfo()</code> 将一个服务的基本地址转换为一个元组列表，其中包含建立一个连接所需的全部信息。每个元组的内容会有变化，包含不同的网络簇或协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print socket.getaddrinfo(&apos;www.python.org&apos;, &apos;http&apos;)</div><div class="line">[(2, 2, 17, &apos;&apos;, (&apos;151.101.36.223&apos;, 80)), (2, 1, 6, &apos;&apos;, (&apos;151.101.36.223&apos;, 80))]</div></pre></td></tr></table></figure>
<p>下面的程序将解释上述元素的含义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">def get_constants(prefix):</div><div class="line">	return dict((getattr(socket, n), n) for n in dir(socket) if n.startswith(prefix))</div><div class="line"></div><div class="line">families = get_constants(&apos;AF_&apos;)</div><div class="line">types = get_constants(&apos;SOCK_&apos;)</div><div class="line">protocols = get_constants(&apos;IPPROTO_&apos;)</div><div class="line">response = socket.getaddrinfo(&apos;www.python.org&apos;, &apos;http&apos;)</div><div class="line">for family, socktype, proto, canonname, sockaddr in response:</div><div class="line">	print &apos;Family		:&apos;, families[family]</div><div class="line">	print &apos;Type		:&apos;, types[socktype]</div><div class="line">	print &apos;Protocol	:&apos;, protocols[proto]</div><div class="line">	print &apos;Canonical Name	:&apos;, canonname</div><div class="line">	print &apos;Socket Address	:&apos;, sockaddr</div><div class="line">	print</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Family		: AF_INET</div><div class="line">Type		: SOCK_DGRAM</div><div class="line">Protocol	: IPPROTO_UDP</div><div class="line">Canonical Name	:</div><div class="line">Socket Address	: (&apos;151.101.16.223&apos;, 80)</div><div class="line"></div><div class="line">Family		: AF_INET</div><div class="line">Type		: SOCK_STREAM</div><div class="line">Protocol	: IPPROTO_TCP</div><div class="line">Canonical Name	:</div><div class="line">Socket Address	: (&apos;151.101.16.223&apos;, 80)</div></pre></td></tr></table></figure>
<p><code>getaddrinfo()</code> 有多个参数来过滤结果列表。例子中给出的主机和端口值是必要参数。可选参数包括 family、socktype、proto 和 flags。这些可选值可以取 0 或 socket 定义的某个常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response = socket.getaddrinfo(&apos;www.python.org&apos;, &apos;http&apos;, socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP, socket.AI_CANONNAME)</div></pre></td></tr></table></figure>
<p>这一次由于标志（flags）包括 <code>AI_CONONNAME</code>，如果这个主机有别名，结果中会包含服务器的标准名（可能与查找所用的值不同）。如果没有这个标志，标准名值则为空。</p>
<h2 id="IP地址表示"><a href="#IP地址表示" class="headerlink" title="IP地址表示"></a>IP地址表示</h2><h3 id="socket-inet-aton-和socket-inet-ntoa"><a href="#socket-inet-aton-和socket-inet-ntoa" class="headerlink" title="socket.inet_aton()和socket.inet_ntoa()"></a>socket.inet_aton()和socket.inet_ntoa()</h3><p>用 C 编写的网络程序使用数据类型 struct sockaddr 将 IP 地址表示为二进制值（而不是Python程序中常见的地址）。要在 Python 表示和 C 表示之间转换 IPv4 地址，可以使用 <code>inet_aton()</code> 和 <code>inet_ntoa()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import binascii</div><div class="line">import socket</div><div class="line">import struct</div><div class="line">import sys</div><div class="line"></div><div class="line">for string_address in [&apos;192.168.1.1&apos;, &apos;127.0.0.1&apos;]:</div><div class="line">    packed = socket.inet_aton(string_address)</div><div class="line">    print &apos;Original: &apos;, string_address</div><div class="line">    print &apos;Packed: &apos;, binascii.hexlify(packed)</div><div class="line">    print &apos;Unpacked: &apos;, socket.inet_ntoa(packed)</div><div class="line">    print</div></pre></td></tr></table></figure>
<p>数据包格式中的4个字节可以传递到C库、通过网络安全地传输，或者紧凑地保存在一个数据库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Original:  192.168.1.1</div><div class="line">Packed:  c0a80101</div><div class="line">Unpacked:  192.168.1.1</div><div class="line"></div><div class="line">Original:  127.0.0.1</div><div class="line">Packed:  7f000001</div><div class="line">Unpacked:  127.0.0.1</div></pre></td></tr></table></figure>
<h3 id="socket-inet-pton-和socket-inet-ntop"><a href="#socket-inet-pton-和socket-inet-ntop" class="headerlink" title="socket.inet_pton()和socket.inet_ntop()"></a>socket.inet_pton()和socket.inet_ntop()</h3><p>相关函数 <code>inet_pton()</code> 和 <code>inet_ntop()</code> 都能处理 IPv4 和 IPv6 地址，根据传入的地址簇参数生成适当的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import binascii</div><div class="line">import socket</div><div class="line">import struct</div><div class="line">import sys</div><div class="line"></div><div class="line">string_address = &apos;2002:ac10:10a:1234:21e:52ff:fe74:40e&apos;</div><div class="line">packed = socket.inet_pton(socket.AF_INET6, string_address)</div><div class="line">print &apos;Original: &apos;, string_address</div><div class="line">print &apos;Packed: &apos;, binascii.hexlify(packed)</div><div class="line">print &apos;Unpacked: &apos;, socket.inet_ntop(socket.AF_INET6, packed)</div></pre></td></tr></table></figure>
<p>IPv6 地址已经是十六进制值，所以将打包版本转换为一个十六进制数系列时会生成一个与原值类似的串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Original:  2002:ac10:10a:1234:21e:52ff:fe74:40e</div><div class="line">Packed:  2002ac10010a1234021e52fffe74040e</div><div class="line">Unpacked:  2002:ac10:10a:1234:21e:52ff:fe74:40e</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 网络通信 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Python制作长图]]></title>
      <url>http://lizonghang.github.io/2016/07/14/Python%E5%88%B6%E4%BD%9C%E9%95%BF%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p>代码功能将多张图片合并为一张长图，保持各子图比例相同。需要第三方库PIL和numpy。numpy是一个开源数字扩展库，可以用来处理大型矩阵。</p>
<h1 id="安装第三方库"><a href="#安装第三方库" class="headerlink" title="安装第三方库"></a>安装第三方库</h1><h2 id="安装PIL"><a href="#安装PIL" class="headerlink" title="安装PIL"></a>安装PIL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install pillow</div></pre></td></tr></table></figure>
<h2 id="安装numpy"><a href="#安装numpy" class="headerlink" title="安装numpy"></a>安装numpy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install numpy</div></pre></td></tr></table></figure>
<h1 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h1><p>我们需要的图片素材有：</p>
<p><img src="/images/menbi1.jpg" alt=""><br><img src="/images/menbi2.jpg" alt=""><br><img src="/images/menbi3.jpg" alt=""><br><img src="/images/menbi4.jpg" alt=""><br><img src="/images/menbi5.jpg" alt=""><br><img src="/images/menbi6.jpg" alt=""><br><img src="/images/menbi7.jpg" alt=""></p>
<p>合成效果为：</p>
<p><img src="/images/MergeImage.jpg" alt=""></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>假设文件名为merge.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># encoding: utf-8</div><div class="line">from PIL import Image</div><div class="line">import numpy</div><div class="line">import os</div><div class="line">import sys</div><div class="line">import random</div><div class="line">import argparse</div><div class="line"></div><div class="line">parser = argparse.ArgumentParser()</div><div class="line">parser.add_argument(&apos;image_dir&apos;, help=&apos;Path to Image Direction&apos;)</div><div class="line">parser.add_argument(&apos;-w&apos;, help=&apos;Image Width&apos;, type=int, default=300)</div><div class="line">args = parser.parse_args()</div><div class="line">root = args.image_dir # 图片文件夹目录</div><div class="line">if root.split(&apos;/&apos;)[-1]:</div><div class="line">    root += &apos;/&apos;</div><div class="line">pxsize = args.w # 单张照片宽度</div><div class="line">images = [] # 存放所有照片路径</div><div class="line"></div><div class="line">def getPhotos():</div><div class="line">    &apos;&apos;&apos;获取所有照片的索引&apos;&apos;&apos;</div><div class="line">    image_num = 0</div><div class="line">    for im in os.listdir(root):</div><div class="line">        suffix = im.split(&apos;.&apos;)[-1]</div><div class="line">        if suffix == &apos;jpg&apos; or suffix == &apos;JPG&apos; or suffix == &apos;jpeg&apos; or suffix == &apos;png&apos;:</div><div class="line">            images.append(root + im)</div><div class="line">            image_num += 1</div><div class="line">    return image_num</div><div class="line"></div><div class="line">xnum = 1 # 行照片数目</div><div class="line">ynum = getPhotos() # 列照片数目</div><div class="line">if ynum &gt; 70:</div><div class="line">    print &apos;图片数目过多，最高70&apos;</div><div class="line">    sys.exit()</div><div class="line"></div><div class="line">def getTotalHeight():</div><div class="line">    &apos;&apos;&apos;获取合并图片总长&apos;&apos;&apos;</div><div class="line">    totalHeight = 0</div><div class="line">    for i in range(xnum):</div><div class="line">        for j in range(ynum): </div><div class="line">            totalHeight += len(transfer(images[j])) + 1</div><div class="line">    return totalHeight</div><div class="line"></div><div class="line">def transfer(img_path):</div><div class="line">    &apos;&apos;&apos;将图片尺寸等比例转换&apos;&apos;&apos;</div><div class="line">    im = Image.open(img_path)</div><div class="line">    rate = float(im.size[0]) / im.size[1]</div><div class="line">    target_width = pxsize</div><div class="line">    target_height = int(pxsize / rate)</div><div class="line">    im = im.resize((target_width, target_height))</div><div class="line">    return numpy.array(im)[:target_height, :target_width]</div><div class="line"></div><div class="line">def mergeImage():</div><div class="line">    &apos;&apos;&apos;合并图片&apos;&apos;&apos;</div><div class="line">    point = 0</div><div class="line">    I = numpy.array(Image.new(&apos;RGB&apos;, (pxsize, getTotalHeight()), (255,255,255)))</div><div class="line">    for i in range(xnum):</div><div class="line">        for j in range(ynum):</div><div class="line">            DA = transfer(images[j]) </div><div class="line">            I[point:point+len(DA), (i*pxsize):((i+1)*pxsize)] = DA</div><div class="line">            point += len(DA) + 1</div><div class="line">    Image.fromarray(I.astype(numpy.uint8)).save(&apos;MergeImage.jpg&apos;, &apos;JPEG&apos;)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    getPhotos()</div><div class="line">    mergeImage()</div></pre></td></tr></table></figure>
<h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python merge.py &lt;path-to-image-file&gt; [-w width]</div></pre></td></tr></table></figure>
<ul>
<li>path-to-image-file - 必选，指向存放要合并的图片的文件夹</li>
<li>-w width - 可选，指定生成图片的宽度，默认为300px</li>
<li>默认生成图片存放路径为文件merge.py同级目录</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Python中执行JS命令]]></title>
      <url>http://lizonghang.github.io/2016/07/10/Python%E4%B8%AD%E6%89%A7%E8%A1%8CJS%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<ul>
<li>自动将Javascipt代码翻译成Python代码 - 支持全部ECMA Scipt 5.1</li>
<li>可使用<code>pyimport</code>语法从Javascript代码中导入Python库</li>
<li>解释速度快，可作为独立的JS解释器</li>
<li>友好的JS执行方式，<code>js2py.eval_js</code></li>
</ul>
<h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install js2py</div></pre></td></tr></table></figure>
<h1 id="Simple-Example"><a href="#Simple-Example" class="headerlink" title="Simple Example"></a>Simple Example</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import js2py</div><div class="line">&gt;&gt;&gt; js2py.eval_js(&apos;console.log(&quot;Hello World!&quot;)&apos;)</div><div class="line">&apos;Hello World!&apos;</div><div class="line">&gt;&gt;&gt; add = js2py.eval_js(&apos;function add(a,b)&#123;return a+b&#125;&apos;)</div><div class="line">&gt;&gt;&gt; add</div><div class="line">&apos;function add(a, b) &#123; [python code] &#125;&apos;</div><div class="line">&gt;&gt;&gt; add(1,2) + 3</div><div class="line">6</div><div class="line">&gt;&gt;&gt; add.constructor</div><div class="line">&apos;function Function() &#123; [python code] &#125;&apos;</div><div class="line">&gt;&gt;&gt; js2py.eval_js(&quot;Object.prototype.toString.call(Function(&apos;s&apos;, &apos;return s+arguments[1]&apos;)(new Date(), 7).__proto__)&quot;)</div><div class="line">&apos;[object String]&apos;</div></pre></td></tr></table></figure>
<h1 id="More-advanced-usage-example"><a href="#More-advanced-usage-example" class="headerlink" title="More advanced usage example"></a>More advanced usage example</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># Adding Python built-in sum to the JS context:</div><div class="line">&gt;&gt;&gt; context = js2py.EvalJs(&#123;&apos;python_sum&apos;: sum&#125;)  </div><div class="line">&gt;&gt;&gt; js_code = &apos;&apos;&apos;</div><div class="line">var a = 10</div><div class="line">function f(x) &#123;return x*x&#125;</div><div class="line">&apos;&apos;&apos;</div><div class="line">&gt;&gt;&gt; context.execute(js_code)</div><div class="line"># Get value of variable a:</div><div class="line">&gt;&gt;&gt; context.a</div><div class="line">10</div><div class="line"># context.f behaves just like js function so you can supply more than 1 argument. &apos;9&apos;*&apos;9&apos; in javascript is 81.</div><div class="line">&gt;&gt;&gt; context.f(&apos;9&apos;, 0)  </div><div class="line">81    </div><div class="line"># context.f has all attributes of normal JavaScript object</div><div class="line">&gt;&gt;&gt; context.f.toString()</div><div class="line">u&apos;function f(x) &#123; [python code] &#125;&apos;</div><div class="line">&gt;&gt;&gt; context.f.bind</div><div class="line">function bind(thisArg) &#123; [python code] &#125;</div><div class="line"># You can also add variables to the context:</div><div class="line">&gt;&gt;&gt; context.foo = [1,2,3]  # context.foo is now Js Array object and behaves just like javascript array!</div><div class="line">&gt;&gt;&gt; context.foo.push(4)  </div><div class="line">4</div><div class="line">&gt;&gt;&gt; context.foo.to_list() # convert to python list</div><div class="line">[1, 2, 3, 4]</div><div class="line"># You can use Python objects that you put inside the context!</div><div class="line">&gt;&gt;&gt; context.eval(&apos;python_sum(new Array(1, 2, 3))&apos;)</div><div class="line">6</div></pre></td></tr></table></figure>
<h1 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h1><ul>
<li>忽视了”strict mode”</li>
<li>不支持<code>with</code>语法</li>
<li><code>eval</code>的非直接调用会被当做直接调用</li>
</ul>
<h1 id="Other-Examples"><a href="#Other-Examples" class="headerlink" title="Other Examples"></a>Other Examples</h1><p>In Js2Py all JavaScript objects are a subclass of PyJs object. For example JS Number is represented by PyJsNumber class. js2py.eval_js and js2py.EvalJs automatically tries to convert PyJs type to builtin python type. So for example if you execute:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; js2py.eval_js(&apos;var a = &quot;hello&quot;; a&apos;)</div></pre></td></tr></table></figure>
<p>eval_js will return unicode type (u”hello”). However for complex types such conversion is impossible and JsObjectWrapper is returned. See the conversion table JsType -&gt; PyType:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Boolean -&gt; bool</div><div class="line">String -&gt; unicode (str in Python 3)</div><div class="line">Number -&gt; float (or int/long if whole number)</div><div class="line">undefined -&gt; None</div><div class="line">null -&gt; None</div><div class="line">OTHER -&gt; JsObjectWrapper</div></pre></td></tr></table></figure>
<p>JsObjectWrapper supports: getitem, getattr, setitem, setattr, repr and call. Moreover it has to_list and to_dict methods if you want to convert it to builtin python type.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; js = js2py.eval_js(&apos;d = &#123;a:1, b:2&#125;&apos;)</div><div class="line">&gt;&gt;&gt; js</div><div class="line">&#123;a: 1, b: 2&#125;  </div><div class="line">&gt;&gt;&gt; type(js)</div><div class="line">&lt;class &apos;js2py.base.JsObjectWrapper&apos;&gt;</div><div class="line">&gt;&gt;&gt; js.a</div><div class="line">1</div><div class="line">&gt;&gt;&gt; js[&apos;a&apos;]</div><div class="line">1</div><div class="line">&gt;&gt;&gt; js.b = 20</div><div class="line">&gt;&gt;&gt; js</div><div class="line">&#123;a: 1, b: 20&#125;  </div><div class="line">&gt;&gt;&gt; js[&apos;c&apos;] = 30</div><div class="line">&gt;&gt;&gt; js.to_dict()</div><div class="line">&#123;u&apos;a&apos;: 1, &apos;c&apos;: 30, u&apos;b&apos;: 20&#125;</div></pre></td></tr></table></figure>
<p>Also, of course you can use Js2Py to parse (tree is the same as in esprima.js) and translate JavaScript</p>
<h1 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; js2py.parse_js(&apos;var $ = 5&apos;)   </div><div class="line">&#123;&apos;body&apos;: [&#123;&apos;kind&apos;: &apos;var&apos;, &apos;declarations&apos;: [&#123;&apos;init&apos;: &#123;&apos;raw&apos;: None, &apos;type&apos;: u&apos;Literal&apos;, &apos;value&apos;: 5.0&#125;, &apos;type&apos;: u&apos;VariableDeclarator&apos;, &apos;id&apos;: &#123;&apos;type&apos;: u&apos;Identifier&apos;, &apos;name&apos;: u&apos;$&apos;&#125;&#125;], &apos;type&apos;: u&apos;VariableDeclaration&apos;&#125;], &apos;type&apos;: u&apos;Program&apos;&#125;</div></pre></td></tr></table></figure>
<h1 id="Translating"><a href="#Translating" class="headerlink" title="Translating"></a>Translating</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print js2py.translate_js(&apos;var $ = 5&apos;)</div><div class="line">import js2py.pyjs, sys</div><div class="line">for m in sys.modules.keys():</div><div class="line">    if m.startswith(&apos;js2py&apos;):</div><div class="line">        del sys.modules[m]</div><div class="line">del js2py.pyjs</div><div class="line">del js2py</div><div class="line">from js2py.pyjs import *</div><div class="line"># setting scope</div><div class="line">var = Scope( JS_BUILTINS )</div><div class="line">set_global_object(var)</div><div class="line"># Code follows:</div><div class="line">var.registers([u&apos;$&apos;])</div><div class="line">var.put(u&apos;$&apos;, Js(5.0))</div></pre></td></tr></table></figure>
<h1 id="pyimport-statement"><a href="#pyimport-statement" class="headerlink" title="pyimport statement"></a>pyimport statement</h1><p>Finally, Js2Py also supports importing any Python code from JavaScript using ‘pyimport’ statement:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x = &quot;&quot;&quot;pyimport urllib;</div><div class="line">           var result = urllib.urlopen(&apos;https://www.google.com/&apos;).read();</div><div class="line">           console.log(result.length)</div><div class="line">        &quot;&quot;&quot;</div><div class="line">&gt;&gt;&gt; js2py.eval_js(x)</div><div class="line">18211</div><div class="line">undefined</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[使用pytesser破解简单验证码]]></title>
      <url>http://lizonghang.github.io/2016/07/10/%E4%BD%BF%E7%94%A8pytesser%E7%A0%B4%E8%A7%A3%E7%AE%80%E5%8D%95%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>Tesseract是一款开源 OCR（Optical Character Recognition，光学字符识别）软件。所谓OCR是图像识别领域中一个子领域，该领域专注于对图片中的文字信息进行识别并转换成能被常规文本编辑器编辑的文本。</p>
<p>Tesseract 已经有30年历史，开始它是惠普实验室的一款专利软件，然后在 2005 年开源，自 2006 年后由 Google 赞助进行后续的开发和维护。在 1995 年 Tesseract 曾是世界前三的 OCR 引擎，而且在现在的免费 OCR 引擎中，其识别精度也仍然是出类拔萃的。因为其免费与较好的效果，许多的个人开发者以及一些较小的团队在使用着 Tesseract ，诸如验证码识别、车牌号识别等应用中，不难见到 Tesseract 的身影。</p>
<p>测试图片如下，文件名为test.png :<br><img src="/images/20140811163359656.png" alt=""></p>
<h1 id="安装与错误信息"><a href="#安装与错误信息" class="headerlink" title="安装与错误信息"></a>安装与错误信息</h1><h2 id="安装PIL"><a href="#安装PIL" class="headerlink" title="安装PIL"></a>安装PIL</h2><p>详见<a href="/2016/07/05/快速入门PIL/">快速入门PIL</a></p>
<h2 id="安装pytesseract"><a href="#安装pytesseract" class="headerlink" title="安装pytesseract"></a>安装pytesseract</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install pytesseract</div></pre></td></tr></table></figure>
<p>此时直接使用会出现错误，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; import pytesseract</div><div class="line">&gt;&gt;&gt; im = Image.open(&apos;test.png&apos;)</div><div class="line">&gt;&gt;&gt; print pytesseract.image_to_string(im)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;/usr/lib/python2.7/dist-packages/spyderlib/widgets/externalshell/sitecustomize.py&quot;, line 540, in runfile</div><div class="line">    execfile(filename, namespace)</div><div class="line">  File &quot;/home/chaitanya/pythonapp/localcopy.py&quot;, line 4, in &lt;module&gt;</div><div class="line">    print pytesseract.image_to_string(im)</div><div class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/pytesseract/pytesseract.py&quot;, line 142, in image_to_string</div><div class="line">    config=config)</div><div class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/pytesseract/pytesseract.py&quot;, line 75, in run_tesseract</div><div class="line">    stderr=subprocess.PIPE)</div><div class="line">  File &quot;/usr/lib/python2.7/subprocess.py&quot;, line 710, in __init__</div><div class="line">    errread, errwrite)</div><div class="line">  File &quot;/usr/lib/python2.7/subprocess.py&quot;, line 1327, in _execute_child</div><div class="line">    raise child_exception</div><div class="line">OSError: [Errno 2] No such file or directory</div></pre></td></tr></table></figure>
<p>原因是还没有安装tesseract-ocr</p>
<h2 id="安装tesseract-ocr"><a href="#安装tesseract-ocr" class="headerlink" title="安装tesseract-ocr"></a>安装tesseract-ocr</h2><p>Linux可使用<code>apt-get</code>直接安装:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install tesseract-ocr</div></pre></td></tr></table></figure>
<p>如果想用 Tesseract 对图像进行识别，还需要对应的语言文件。所谓的语言文件是 Tesseract 识别某种语言的文字图像时需要的一些资源，这些东西也可以通过包管理器获取。比如我们需要识别英语和简体中文，那么使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install tesseract-ocr-eng tesseract-ocr-chi-sim</div></pre></td></tr></table></figure>
<p>如果没有<code>apt-get</code>，需要的话可以使用编译安装的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://tesseract-ocr.googlecode.com/files/tesseract-ocr-3.02.02.tar.gz</div><div class="line">tar -xzvf tesseract-ocr-3.02.02.tar.gz</div></pre></td></tr></table></figure>
<p>编译需要<code>automake</code>、<code>autoconf</code>、<code>libtool</code>支持，如果有的话可以跳过该步骤，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install autoconf automake libtool</div></pre></td></tr></table></figure>
<p>然后进入文件夹 tesseract-ocr-3.02.02 编译安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure>
<p>Tesseract还依赖一些图像库，你可以选择性安装，也可不安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install ligjpeg62-dev libtiff4-dev libpng12-dev libleptonica-dev</div></pre></td></tr></table></figure>
<p>再运行测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; import pytesseract</div><div class="line">&gt;&gt;&gt; im = Image.open(&apos;test.png&apos;)</div><div class="line">&gt;&gt;&gt; print pytesseract.image_to_string(im)</div></pre></td></tr></table></figure>
<p>可能会出现’Leptonica not found’错误。如果出现该错误，下载安装Leptonica包即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://leptonica.googlecode.com/files/leptonica-1.69.tar.bz2</div></pre></td></tr></table></figure>
<h2 id="安装语言训练集"><a href="#安装语言训练集" class="headerlink" title="安装语言训练集"></a>安装语言训练集</h2><p>解压后进入目录执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure>
<p>如果没有出现上述错误，应该会出现<code>TesseractError</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print pytesseract.image_to_string(im)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pytesseract/pytesseract.py&quot;, line 164, in image_to_string</div><div class="line">    raise TesseractError(status, errors)</div><div class="line">pytesseract.pytesseract.TesseractError: (1, &apos;Error opening data file /usr/local/share/tessdata/eng.traineddata&apos;)</div></pre></td></tr></table></figure>
<p>这是由于没有下载语音训练集造成，你可以使用命令查看目前的语言训练集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tesseract --list-langs</div></pre></td></tr></table></figure>
<p>训练集放置于/usr/local/share/目录中的tessdata文件夹中，你需要手动下载训练集并添加到这个文件夹，添加后可以使用上述命令查看。你可以从<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="external">Github</a>获取到训练集。</p>
<p>再次尝试运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; import pytesseract</div><div class="line">&gt;&gt;&gt; im = Image.open(&apos;test.png&apos;)</div><div class="line">&gt;&gt;&gt; print pytesseract.image_to_string(im)</div><div class="line">hoke</div></pre></td></tr></table></figure>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>经测试，pytesser适用于比较规范的英文/数字，对于中文的识别能力较差，对于有干扰素的验证码图片性能较差，可以用来提取简单的英文/数字。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[随机数字图片验证码的原理、生成和破解]]></title>
      <url>http://lizonghang.github.io/2016/07/10/%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%AD%97%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E7%94%9F%E6%88%90%E5%92%8C%E7%A0%B4%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>验证码的功能一般是防止使用程序恶意注册、暴力破解或批量发帖而设置的。所谓验证码，就是将一串随机产生的数字或符号，生成一幅图片，图片里加上一些干扰象素（防止OCR），由用户肉眼识别其中的验证码信息，输入表单提交网站验证，验证成功后才能使用某项功能。学习验证码的破解/识别技术，不仅可以知道验证码的原理，而且可以让你知道怎样才能防止验证码被破解。</p>
<h1 id="常见验证码类型"><a href="#常见验证码类型" class="headerlink" title="常见验证码类型"></a>常见验证码类型</h1><p><img src="/images/authtype.png" alt=""></p>
<ol>
<li>图片背景和数字都使用相同的颜色，字符规整，字符位置统一</li>
<li>验证字符规整，颜色相同，排除干扰素容易，只要是非字符色素全部排除即可</li>
<li>处理背景色和干扰色一直变换，验证字符的颜色也在变化，各个字符的颜色也各不相同</li>
<li>在第三个基础上，在文字上加了两条直线干扰率，容易去掉</li>
</ol>
<h1 id="验证码识别步骤"><a href="#验证码识别步骤" class="headerlink" title="验证码识别步骤"></a>验证码识别步骤</h1><h2 id="取出干扰素"><a href="#取出干扰素" class="headerlink" title="取出干扰素"></a>取出干扰素</h2><p>干扰素的一个重要特征是不能影响验证码的显示效果，所以制作干扰素时它的RGB可能低于或高于某个特定值。比如例子中的图片，干扰素的RGB各项值小于125，依此很容易去掉干扰素。</p>
<h2 id="取出字模"><a href="#取出字模" class="headerlink" title="取出字模"></a>取出字模</h2><p>由于各个网站的验证码各不相同，最常见的方法是建立验证码的特征码库。取字模时，需要多收集几张图片，使这些图片中包括所有的字符。一般来说有0~9、a~z</p>
<h2 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h2><p>把图片上的验证字符上每个像素用一种数字表示1，其他部分用0表示。这样就可以计算每个数字字模，记录下这些字模当作key</p>
<h2 id="计算特征"><a href="#计算特征" class="headerlink" title="计算特征"></a>计算特征</h2><p>把要识别的图片进行二值化，得到图片特征</p>
<h2 id="对照样本"><a href="#对照样本" class="headerlink" title="对照样本"></a>对照样本</h2><p>把上一步图片特征码和验证码的字模进行对比，得到验证图片上的数字</p>
<h1 id="复杂验证码"><a href="#复杂验证码" class="headerlink" title="复杂验证码"></a>复杂验证码</h1><p>识别的目标验证码由字符和数字组成，验证码存在旋转，位置不固定，存在字符与字符之间的粘连，且验证码有更强的干扰素。以下图为例：</p>
<p><img src="/images/authexam.jpg" alt=""></p>
<h2 id="二值化-1"><a href="#二值化-1" class="headerlink" title="二值化"></a>二值化</h2><p>把验证码的部分用1表示，背景部分用0表示。识别方法为：打印出验证码图片的RGB，分辨出图片的R值大于120，G和B小于80的像素，依据这个规则把图片二值化。</p>
<p>常见验证码第三张图片中，验证码的图片每次背景色都不相同，且不是单色，各个验证码数字的颜色每次也各不相同。打印出其 RGB 值很容易就发现。无论验证数字颜色如何变化，该数字的 RGB 值总有一个值小于 125 ，所以通过判断<code> rgbarray[‘red’] &lt; 125 || rgbarray[‘green’] &lt; 125 || rgbarray[‘blue’] &lt; 125 </code>就很容易分辨出数字和背景。</p>
<p>这些规律的原因是，在制作验证码的干扰素时，为了使干扰素不影响数字的显示效果，必须使干扰素的 RGB 和数字的 RGB 相互独立，互不干扰。依照这个规律就容易实现二值化。</p>
<p>我们找到的 120 ， 80 ， 125 等阈值，可能和实际的 RGB 有出入，所以，有时二值化后，会有部分地方出现 1 ，对于验证码上固定位置显示数字，这种干扰没有太大意义。但是对于验证码位置不确定的图片来说，在我们切割字符时，很可能造成干扰。所以，在二值化后要进行去噪处理。</p>
<h2 id="去噪处理"><a href="#去噪处理" class="headerlink" title="去噪处理"></a>去噪处理</h2><p>去噪就是把孤立的有效值去掉。如果一个点为1，则判断这个点的周围一圈上的数字是否为1，若没有则认为是一个噪点，直接设置为0即可。</p>
<p><img src="/images/noise.jpg" alt=""></p>
<p>如图所示，红色方框部分的 1 为噪点，直接设置为 0 即可。有时候噪点可能是两个连续的 1 ，可以计算这个点 8 个方向上的值之和，判断和是否小于特定的阈值。</p>
<h2 id="切割字符"><a href="#切割字符" class="headerlink" title="切割字符"></a>切割字符</h2><p>切割方法有很多种，最简单的一种为竖直切割。先沿垂直方向切割为字符，然后再水平方向去掉多余的 0 。如下图所示</p>
<p><img src="/images/1336829447_7784.jpg" alt=""></p>
<p>第一步切割红线部分，第二步切割蓝线部分，就可以得到独立的字符了。但是像下面的情况：</p>
<p><img src="/images/1336829468_5425.jpg" alt=""></p>
<p>按上面的方法会把 dw 字符切割成一个字符，这是错误的切割，这里涉及到粘连字符的切割。</p>
<h2 id="粘连字符切割"><a href="#粘连字符切割" class="headerlink" title="粘连字符切割"></a>粘连字符切割</h2><p>制作验证码时，规则字符的粘连很容易分割开，如果字符本身有缩放，变形就很难处理。上述字符粘连是规则字符的粘连，完成分割操作后，不能马上确定分割的部分为一个字符，要进行验证。验证的关键是切割下来的字符的宽是否大于阈值。阈值的取舍标准是一个字符无论怎么旋转变形都不会大于这个阈值。若切割的块大于这个阈值，可以认为是一个粘连字符；如果大于两个阈值之和，认为是三个字符粘连，以此类推。如果发现粘连字符块，直接平分为两个或多个小块即可。为了更好的还原字符，一般采用平分±1对字符块部分进行适当的补充。</p>
<h2 id="匹配字符"><a href="#匹配字符" class="headerlink" title="匹配字符"></a>匹配字符</h2><p>最简单的方式是为所有的字符所有情况建立匹配库，目的是现有人工识别图片的验证码，处理后写入特征码库以便匹配。特征码库的图片数据越多，验证识别的准确性就越高。</p>
<h1 id="制作验证码的建议"><a href="#制作验证码的建议" class="headerlink" title="制作验证码的建议"></a>制作验证码的建议</h1><p>对于识别验证码的程序来说最难的部分是验证码字符的切割和特征码的建立。很多验证码加了很多干扰素和干扰线，不仅影响用户体验还达不到防止破解的很好的效果。若要使验证码难于被程序识别，需要注意：</p>
<ul>
<li>字符粘连，最后所有字符都有粘连的部分</li>
<li>不使用规则字符，验证码的各个部分使用不同比例的缩放或者旋转</li>
</ul>
<p>一般实现以上两点或这两点的变性，破解程序就很难识别。</p>
]]></content>
      
        <categories>
            
            <category> 算法/理论 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Python破解验证码]]></title>
      <url>http://lizonghang.github.io/2016/07/09/Python%E7%A0%B4%E8%A7%A3%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>本项目使用<strong>PIL库</strong>及<strong>向量空间搜索引擎理论</strong>实现验证码破解。先下载实验用文件便于解释图片解析的原理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ wget http://labfile.oss.aliyuncs.com/courses/364/python_captcha.zip</div><div class="line">$ unzip python_captcha.zip</div></pre></td></tr></table></figure></p>
<p>或直接访问 <a href="http://labfile.oss.aliyuncs.com/courses/364/python_captcha.zip" target="_blank" rel="external">http://labfile.oss.aliyuncs.com/courses/364/python_captcha.zip</a> 并解压。python_captcha目录下的内容有:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">python_captcha</div><div class="line">├── captcha.gif</div><div class="line">├── crack.py</div><div class="line">├── examples</div><div class="line">└── iconset</div><div class="line">    ├── 0~9</div><div class="line">    ├── a~z</div></pre></td></tr></table></figure></p>
<ul>
<li>captcha.gif - 试验用验证码图片</li>
<li>crack.py - 即将编写的实现验证码破解的程序</li>
<li>examples/ - 存放了其他可用于测试的验证码图片</li>
<li>iconset/ - 存放了训练集，即用于对比的单符号图片</li>
</ul>
<p>下图为试验用验证码图片:</p>
<p><img src="/images/captcha.gif" alt=""></p>
<h1 id="从文件中提取图片"><a href="#从文件中提取图片" class="headerlink" title="从文件中提取图片"></a>从文件中提取图片</h1><p>将图片转为8位P模式图片，输出其颜色直方图:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line">im = Image.open(&apos;captcha.gif&apos;).convert(&apos;P&apos;)</div><div class="line">print im.histogram()</div></pre></td></tr></table></figure>
<p>输出:</p>
<pre>
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 1, 2, 0, 1, 0, 0, 1, 0, 2, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 3, 1, 3, 3, 0, 0, 0, 0, 0, 0, 1, 0, 3, 2, 132, 1, 1, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 15, 0, 1, 0, 1, 0, 0, 8, 1, 0, 0, 0, 0, 1, 6, 0, 2, 0, 0, 0, 0, 18, 1, 1, 1, 1, 1, 2, 365, 115, 0, 1, 0, 0, 0, 135, 186, 0, 0, 1, 0, 0, 0, 116, 3, 0, 0, 0, 0, 0, 21, 1, 1, 0, 0, 0, 2, 10, 2, 0, 0, 0, 0, 2, 10, 0, 0, 0, 0, 1, 0, 625]
</pre>

<p>颜色直方图的每一位数字都代表了在图片中含有对应位颜色像素的数量。每个像素点可表现256种颜色。从输出中可发现白点最多，白色像素序号为255，即最后一位，有625个像素。红像素在序号200左右，通过排序可以得到有用的颜色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">his = im.histogram()</div><div class="line">values = &#123;&#125;</div><div class="line">for i in range(256):</div><div class="line">    values[i] = his[i] </div><div class="line">for index,count in sorted(values.items(), key=lambda d:d[1], reverse=True)[:10]:</div><div class="line">    print index,count</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">255 625</div><div class="line">212 365</div><div class="line">220 186</div><div class="line">219 135</div><div class="line">169 132</div><div class="line">227 116</div><div class="line">213 115</div><div class="line">234 21</div><div class="line">205 18</div><div class="line">184 15</div></pre></td></tr></table></figure>
<p>得到了图片中最多的10种颜色，其中index为220与227是需要的红色和灰色，通过这一信息构造黑白二值图片:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line">im = Image.open(&apos;captcha.gif&apos;).convert(&apos;P&apos;)</div><div class="line">im2 = Image.new(&apos;P&apos;, im.size, 255)</div><div class="line">for row in range(im.size[1]):</div><div class="line">    for col in range(im.size[0]):</div><div class="line">        pix = im.getpixel((col,row))</div><div class="line">        if pix == 220 or pix == 227:</div><div class="line">            im2.putpixel((col,row), 0)</div><div class="line">im2.show()</div></pre></td></tr></table></figure>
<p>得到黑白二值图片:</p>
<p><img src="/images/im2.gif" alt=""></p>
<h1 id="提取单个字符图片"><a href="#提取单个字符图片" class="headerlink" title="提取单个字符图片"></a>提取单个字符图片</h1><p>为了判断各个字符，需要将图片切割为单个字符的像素集合，对黑白二值图片进行纵向切割：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">inLetter = False</div><div class="line">foundLetter = False</div><div class="line">letterStart = 0</div><div class="line">letterEnd = 0</div><div class="line">letter_split = []</div><div class="line"></div><div class="line">for col in range(im2.size[0]):</div><div class="line">    for row in range(im2.size[1]):</div><div class="line">        pix = im2.getpixel((col,row))</div><div class="line">        if pix != 255:</div><div class="line">            inLetter = True</div><div class="line">    if foundLetter == False and inLetter == True:</div><div class="line">        foundLetter = True</div><div class="line">        letterStart = col</div><div class="line">    if foundLetter == True and inLetter == False:</div><div class="line">        foundLetter = False</div><div class="line">        letterEnd = col</div><div class="line">        letter_split.append((letterStart,letterEnd))</div><div class="line">    inLetter = False</div></pre></td></tr></table></figure>
<p>letter_split中记录了每个字符开始和结束的列序号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[(6, 14), (15, 25), (27, 35), (37, 46), (48, 56), (57, 67)]</div></pre></td></tr></table></figure>
<p>分割图片:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for letter in letter_split:</div><div class="line">    im_Letter = im2.crop((letter[0], 0, letter[1], im2.size[1]))</div><div class="line">    im_Letter.show()</div></pre></td></tr></table></figure>
<p>得到每个字符的图片。将这些图片与本地图片进行比较分析，匹配到相似度最高的字符。</p>
<h1 id="向量空间图形识别"><a href="#向量空间图形识别" class="headerlink" title="向量空间图形识别"></a>向量空间图形识别</h1><p>这里使用向量空间搜索引擎来做字符识别，它具有很多优点：</p>
<ul>
<li>不需要大量的训练迭代</li>
<li>不会训练过度</li>
<li>可以随时加入/移除错误的数据查看效果</li>
<li>很容易理解和编写成代码</li>
<li>提供分级结果，可以查看最接近的多个匹配</li>
<li>对于无法识别的东西只要加入到搜索引擎中就能识别</li>
</ul>
<p>但它分类的速度比神经网络慢很多，不能找到自己的方法解决问题。</p>
<p>原理可以参考<a href="/2016/07/07/向量空间搜索引擎基本理论/">向量空间搜索引擎</a></p>
<p>类VectorCompare实现向量空间:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import math</div><div class="line">class VectorCompare:</div><div class="line">    def magnitude(self, concordance):</div><div class="line">        total = 0</div><div class="line">        for word, count in concordance.iteritems():</div><div class="line">            total += count ** 2</div><div class="line">        return math.sqrt(total)</div><div class="line"></div><div class="line">    def relation(self, concordance1, concordance2):</div><div class="line">        relevance = 0</div><div class="line">        topvalue = 0</div><div class="line">        for word, count in concordance1.iteritems():</div><div class="line">            if concordance2.has_key(word):</div><div class="line">                topvalue += count * concordance2[word]</div><div class="line">        return topvalue / (self.magnitude(concordance1) * self.magnitude(concordance2))</div></pre></td></tr></table></figure>
<p>该类会比较两个字典并输出它们的相似度(0~1)</p>
<h1 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h1><p>还需要取大量的验证码提取出单个字符图片作为训练集合的工作，上文已经介绍。iconset目录下放的是训练集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">def buildvector(im):</div><div class="line">    d1 = &#123;&#125;</div><div class="line">    count = 0</div><div class="line">    for i in im.getdata():</div><div class="line">        d1[count] = i</div><div class="line">        count += 1</div><div class="line">    return d1</div><div class="line"></div><div class="line">v = VectorCompare()</div><div class="line">iconset = [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;]</div><div class="line"></div><div class="line"># 加载训练集</div><div class="line">imageset = []</div><div class="line">for letter in iconset:</div><div class="line">    for img in os.listdir(&apos;./iconset/%s/&apos; % letter):</div><div class="line">        temp = []</div><div class="line">        if img != &apos;Thumbs.db&apos; and img != &apos;.DS_Store&apos;:</div><div class="line">            temp.append(buildvector(Image.open(&apos;./iconset/%s/%s&apos; % (letter, img))))</div><div class="line">        imageset.append(&#123;letter: temp&#125;)</div><div class="line"></div><div class="line">count = 0</div><div class="line"># 切割验证码</div><div class="line">for letter in letter_split:</div><div class="line">    im_Letter = im2.crop((letter[0], 0, letter[1], im2.size[1]))</div><div class="line">    guess = []</div><div class="line">    # 将切割得到的验证码小片段与每个训练片段进行比较</div><div class="line">    for image in imageset:</div><div class="line">        for x,y in image.iteritems():</div><div class="line">            if len(y) != 0:</div><div class="line">                guess.append((v.relation(y[0], buildvector(im_Letter)), x))</div><div class="line">    guess.sort(reverse=True)</div><div class="line">    print guess[0]</div><div class="line">    count += 1</div></pre></td></tr></table></figure>
<h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># encoding: utf-8</div><div class="line">from PIL import Image</div><div class="line">import os</div><div class="line">import math</div><div class="line"></div><div class="line">class VectorCompare:</div><div class="line">    def magnitude(self, concordance):</div><div class="line">        total = 0</div><div class="line">        for word, count in concordance.iteritems():</div><div class="line">            total += count ** 2</div><div class="line">        return math.sqrt(total)</div><div class="line"></div><div class="line">    def relation(self, concordance1, concordance2):</div><div class="line">        relevance = 0</div><div class="line">        topvalue = 0</div><div class="line">        for word, count in concordance1.iteritems():</div><div class="line">            if concordance2.has_key(word):</div><div class="line">                topvalue += count * concordance2[word]</div><div class="line">        return topvalue / (self.magnitude(concordance1) * self.magnitude(concordance2))</div><div class="line"></div><div class="line"></div><div class="line">def buildvector(im):</div><div class="line">    d1 = &#123;&#125;</div><div class="line">    count = 0</div><div class="line">    for i in im.getdata():</div><div class="line">        d1[count] = i</div><div class="line">        count += 1</div><div class="line">    return d1</div><div class="line"></div><div class="line">v = VectorCompare()</div><div class="line">iconset = [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;]</div><div class="line">image_set = []</div><div class="line"></div><div class="line">for letter in iconset:</div><div class="line">    for img in os.listdir(&apos;./iconset/%s/&apos; % letter):</div><div class="line">        temp = []</div><div class="line">        if img != &quot;Thumbs.db&quot; and img != &apos;.DS_Store&apos;:</div><div class="line">            temp.append(buildvector(Image.open(&apos;./iconset/%s/%s&apos; % (letter, img))))</div><div class="line">        image_set.append(&#123;letter: temp&#125;)</div><div class="line"></div><div class="line">im = Image.open(&apos;captcha.gif&apos;).convert(&apos;P&apos;)</div><div class="line">im2 = Image.new(&apos;P&apos;, im.size, 255)</div><div class="line">temp = &#123;&#125;</div><div class="line"></div><div class="line">for row in range(im.size[1]):</div><div class="line">    for col in range(im.size[0]):</div><div class="line">        pix = im.getpixel((col,row))</div><div class="line">        temp[pix] = pix</div><div class="line">        if pix == 220 or pix == 227:</div><div class="line">            im2.putpixel((col,row), 0)</div><div class="line"></div><div class="line">inLetter = False</div><div class="line">foundLetter = False</div><div class="line">letterStart = 0</div><div class="line">letterEnd = 0</div><div class="line">letter_split = []</div><div class="line"></div><div class="line">for col in range(im2.size[0]):</div><div class="line">    for row in range(im2.size[1]):</div><div class="line">        pix = im2.getpixel((col,row))</div><div class="line">        if pix != 255:</div><div class="line">            inLetter = True</div><div class="line">    if foundLetter == False and inLetter == True:</div><div class="line">        foundLetter = True</div><div class="line">        letterStart = col</div><div class="line">    if foundLetter == True and inLetter == False:</div><div class="line">        foundLetter = False</div><div class="line">        letterEnd = col</div><div class="line">        letter_split.append((letterStart,letterEnd))</div><div class="line">    inLetter = False</div><div class="line"></div><div class="line">count = 0</div><div class="line">for letter in letter_split:</div><div class="line">    im_Letter = im2.crop((letter[0], 0, letter[1], im2.size[1]))</div><div class="line">    guess = []</div><div class="line">    for image in image_set:</div><div class="line">        for x,y in image.iteritems():</div><div class="line">            if len(y) != 0:</div><div class="line">                guess.append((v.relation(y[0], buildvector(im_Letter)), x))</div><div class="line">    guess.sort(reverse=True)</div><div class="line">    print guess[0]</div><div class="line">    count += 1</div></pre></td></tr></table></figure>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>运行程序查看是否正常工作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./crack.py</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(0.9637681159420289, &apos;7&apos;)</div><div class="line">(0.96234028545977, &apos;s&apos;)</div><div class="line">(0.9286884286888929, &apos;9&apos;)</div><div class="line">(0.9835037060984447, &apos;t&apos;)</div><div class="line">(0.9675116507250627, &apos;9&apos;)</div><div class="line">(0.9698971168877263, &apos;j&apos;)</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[向量空间搜索引擎基本理论]]></title>
      <url>http://lizonghang.github.io/2016/07/07/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/</url>
      <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>&emsp;&emsp;向量空间搜索引擎所运用的技术源自矩阵代数，它基于字符在文件中出现的频率来比较文件。<br>&emsp;&emsp;向量空间搜索引擎中第一个重要的元素是<code>项空间</code>的概念。简而言之，一个项空间由文件中出现的每个独立的词组成。<br>&emsp;&emsp;向量空间搜索引擎中第二个重要的元素是<code>项数</code>。项数就是文件中每个字符出现的次数。通常可由表的形式列出。<br>&emsp;&emsp;通过将项空间作为坐标空间，项数作为项空间中的坐标，我们可以为每个文件生成一个向量。以笛卡尔坐标系为例，点的刻画沿X,Y,Z轴。类似的，在我们的例子中一个项空间由三个独立项组成，我们把它们分别称作项1轴，项2轴，项3轴。（在向量空间搜索引擎理论中这些轴通常被称作<code>维数</code>。）通过计算文件中各项出现的次数，并沿各项轴画出坐标，就可确定出与文件所对应的项空间中的点。由这些点可生成该文件的向量。<br>&emsp;&emsp;一旦在项空间中画出该文件的向量，就可以计算向量的<code>大小</code>。把大小看做是原点（坐标（0，0，0）点）到当前文件点之间连线的距离。这样就可运用向量的长度通过计算夹角的余弦来比较不同的文件。例如，相同的文件夹角余弦为1，文件中含有类似项的夹角余弦会是正小数，文件中含有截然不同项的夹角余弦是0。</p>
<h1 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h1><p>&emsp;&emsp;假设我们有三个文件。每个文件分别是三个词：猫、狗和老鼠。这三个词就是项空间，那么我们可以说每个文件分别沿猫维、狗维和老鼠维上有坐标。这些坐标取决于每一项在文件中出现的次数。例如，以下表中的文件1就含有“猫-狗-老鼠”向量的坐标为（3，1，4）<br><img src="/images/table.png" alt="table"><br>&emsp;&emsp;用勾股定理来计算每个文件向量的大小，在该情况下向量维数高于二维，所以有以下公式<br><img src="/images/formula_1.png" alt="formula"><br>无论是多少维的向量，都可以用勾股定理来计算文件向量的大小。<br>&emsp;&emsp;即时对于不同的文件可能会有相同大小的文件向量。例如，对于两个文件向量分别为（1，2，3）和（3，2，1）的文件来说，它们的文件向量大小均为3.74165。这并不矛盾，文件的关联值（relevancy score）是基于要查询的询问项的维数，因此，即便是对于具有相同大小的文件向量的文件，它们的询问项不同。即是说项空间中的两条直线具有相同的长度，但可能不指向同一方向。</p>
<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><p>&emsp;&emsp;为查询文件的索引，我们把查询向量投影到向量空间上，并计算查询向量与文件集中向量之间的余弦夹角。例如，查询项为“老鼠”，那么“猫-狗-老鼠”向量就是（0，0，1）。查询向量大小为<br><img src="/images/formula_2.png" alt=""><br>注：一个简单方法是查看询问项是否属于项空间，如果是，那么||Q||总为1。但这只对单项询问有效。对于多个查询项，计算它们在项空间出现的次数，然后对次数取方根。由于查询项的值总大于1，||Q||将会是某个整数的方根。但前提是每项在询问项中只出现一次。由于本文将要讨论的次干问题，该假设未必是个好假设。<br>&emsp;&emsp;计算查询向量与一文件向量的余弦夹角公式为<br><img src="/images/formula_3.png" alt=""><br>依次计算三个文件向量与查询项向量夹角的余弦值，并将文件按余弦值递减排序<br><img src="/images/formula_4.png" alt=""><br>可以看出文件2是和查询项“老鼠”最相关，该结论可从上面的列表中快速验证。与文件1有些相关，文件3因不含“老鼠”这一项，与查询项完全无关。<br>&emsp;&emsp;一个简单的考虑方法是余弦值越接近1，文件与查询项越相关。如果余弦值为0，文件向量与查询向量正交且完全无关。</p>
<h1 id="文件集索引处理"><a href="#文件集索引处理" class="headerlink" title="文件集索引处理"></a>文件集索引处理</h1><p>&emsp;&emsp;文件集的索引处理对于被索引的文件是很特殊的。向量空间搜索技术可用于任何有一定结构的信息中，因此它对文字、图像、密码钥匙，甚至DNA同样有效。但是，用户必须对所处理的信息做适当的构建，并可将其优化以提高索引处理效率。以检索一个小网站为例。<br>&emsp;&emsp;首先每个HTML文件必须先做预处理，然后索引为文件集合的一部分。（集合只能整体索引。在索引后添加额外的文件会改变项文件的维数并且否定已存文件向量的大小。）<br>&emsp;&emsp;先拆解所有HTML文件的内容，诸如空格、回车键，直到只留有单个词组成的项为止。<br>&emsp;&emsp;然后把间歇字（stop word）从正文中移出。间歇字是那些在英文中常用但总体上不对正文产生任何语义的词，比如’the’,’and’,’of’,’or’。这些词和实际的语义无关，如不去掉会增加项空间的维数，从而加长处理时间。另外，像’quickly’这样的副词因和实际语义无关也可以去掉。<br>&emsp;&emsp;下一步词干化（stem）文件中剩余的项。词干化是将每项简化成词根的形式。例如，词’runner’，’running’,’runs’都将被简化成’run’。<em>Porter Stemming Algorithm</em>的目的就是词干化。这进一步简化了项空间并保持了语义。<br>&emsp;&emsp;完成这三步后我们期望留下保持原文件语义的最少项。现在可以开始通过建立项空间和计算每个文件向量的大小来索引文件集。<br><img src="/images/step.png" alt=""><br>注：要注意的是解析器如何分解信息将直接影响查询结果。例如，如果索引的是一本书，那么索引时间和查询结果将取决于如何对书进行分割，是按章、页还是段落。需要对数据进行一定的试验以找到最优的分割。</p>
<h1 id="向量空间搜索引擎的局限"><a href="#向量空间搜索引擎的局限" class="headerlink" title="向量空间搜索引擎的局限"></a>向量空间搜索引擎的局限</h1><p>&emsp;&emsp;首先，它需要海量计算，因此计算速度极慢。由于是浮点运算，因此需要很长的处理时间，从而导致表现失常。高性能的表现需要在内存中执行优化过的代码。期望随着处理器速度的提高使之不再成为障碍。<br>&emsp;&emsp;其次，动态的文集对每一次文件的添加都需要再索引。这是由于当每次在项空间中引进一个新项时，对应的新矩阵会增加一维，从而所有的文件都要进行再索引，使得文件向量与新维数相对应。这样做使得实时查询几乎不可能，这可能是使该技术没有被广泛使用的主要原因。<br>&emsp;&emsp;第三，为了能发觉有潜在语义索引（Latent Semantic Indexing）的文件之间的额外联系，我们需对文件集做额外的数学变换。LSI可使文件之间在语义层上找到彼此之间的额外联系。它超出了本文的讨论范围，但对向量空间的搜索技术的下一步研究具有重要意义，同时也为实时查询增加了新的障碍。</p>
]]></content>
      
        <categories>
            
            <category> 算法/理论 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[PIL中的概念]]></title>
      <url>http://lizonghang.github.io/2016/07/07/PIL%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h1 id="Bands-频段"><a href="#Bands-频段" class="headerlink" title="Bands(频段)"></a>Bands(频段)</h1><p>一张图片可以由一个或多个数据频段组成，PIL库支持在一张图片中存储多个频段，它们具有相同的尺寸和深度。要获取图像中频段的数量和名称，可使用<code>getbands()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; im = Image.open(&apos;lena.jpg&apos;)</div><div class="line">&gt;&gt;&gt; im.getbands()</div><div class="line">(&apos;R&apos;, &apos;G&apos;, &apos;B&apos;)</div></pre></td></tr></table></figure>
<h1 id="Mode-模式"><a href="#Mode-模式" class="headerlink" title="Mode(模式)"></a>Mode(模式)</h1><p>图像的模式定义了图片中像素的类型和深度。最新发行版支持下列标准模式：</p>
<ul>
<li>1        - 1bit像素，黑白，每个字节存储一个像素</li>
<li>L        - 8bit像素，灰度</li>
<li>P        - 8bit像素，用调色盘索引到其他模式</li>
<li>RGB    - 3x8bit像素，真彩</li>
<li>RGBA    - 4x8bit像素，真彩，带透明遮罩</li>
<li>CMYK    - 4x8bit像素，分色</li>
<li>YCbCr    - 3x8bit像素，彩色视频格式</li>
<li>I        - 32bit有符号整数像素</li>
<li>F        - 32bit浮点像素</li>
</ul>
<p>PIL同时对一些特殊的模式提供有限的支持，包括LA，RGBX，RGBa，但PIL不支持用户自定义的模式。如果要处理其他模式，可使用图像对象序列。</p>
<h1 id="Size-大小"><a href="#Size-大小" class="headerlink" title="Size(大小)"></a>Size(大小)</h1><p>可以通过<code>size</code>属性获取图像大小。这是一个二元元组，含有水平像素尺寸和竖直像素尺寸。</p>
<h1 id="Coordinate-System-坐标系统"><a href="#Coordinate-System-坐标系统" class="headerlink" title="Coordinate System(坐标系统)"></a>Coordinate System(坐标系统)</h1><p>PIL使用了笛卡尔的像素坐标系统，左上角为坐标原点。坐标通常以二元元组的形式传递给库使用。矩形需要表示为四元元组，左上角的坐标优先给出。比如，一个包含有800x600像素的图片可写作(0,0,800,600)。</p>
<h1 id="Palette-调色盘"><a href="#Palette-调色盘" class="headerlink" title="Palette(调色盘)"></a>Palette(调色盘)</h1><p>调色盘模式P使用调色盘来定义每个像素实际的颜色。</p>
<h1 id="Info-信息"><a href="#Info-信息" class="headerlink" title="Info(信息)"></a>Info(信息)</h1><p>你可以使用<code>info</code>属性给图片添加辅助信息。这是一个字典对象。当加载或保存图像文件时能够处理多少信息决定于文件格式处理器。大多数处理器加载图像时给<code>info</code>添加属性，但在存储图片时会忽略掉。</p>
<h1 id="Filters-过滤器"><a href="#Filters-过滤器" class="headerlink" title="Filters(过滤器)"></a>Filters(过滤器)</h1><p>对于输入多个像素输出单个像素的几何操作，PIL库提供了四种不同的重取样过滤器。</p>
<p><code>NEAREST</code> - 取出与输入图像最相近的像素，忽略其他输入像素</p>
<p><code>BILINEAR</code> - 在输入图像中2x2环境下使用线性内插。在当前PIL版本，过滤器采样时使用一个固定的输入环境</p>
<p><code>BICUBIC</code> - 在输入图像中的4x4环境使用三次内插。在当前PIL版本，过滤器采样时使用一个固定的输入环境</p>
<p><code>ANTIALIAS</code> - 使用一个高质量的重采样过滤器计算所有可能对输出有影响的像素来得到输出像素。在当前PIL版本，过滤器只能被用在<code>resize()</code>和<code>thumbnail()</code>方法。</p>
]]></content>
      
        <categories>
            
            <category> PIL </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[快速入门PIL]]></title>
      <url>http://lizonghang.github.io/2016/07/05/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8PIL/</url>
      <content type="html"><![CDATA[<h1 id="使用Image类"><a href="#使用Image类" class="headerlink" title="使用Image类"></a>使用Image类</h1><p>PIL中最重要的类是<code>Image</code>类，可以通过多种方法创建这个类的实例。可以从文件加载图像，或者处理其他图像，或者从scratch创建。</p>
<p>要从文件加载图像，可使用<code>Image</code>模块的<code>open()</code>函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; im = Image.open(&apos;lena.jpg&apos;)</div></pre></td></tr></table></figure>
<p>示例用的图片如下:</p>
<p><img src="/images/lena.jpg" alt="lena"></p>
<p>加载成功将返回一个<code>Image</code>对象。可以使用如下命令检查文件内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print im</div><div class="line">&lt;PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=500x750 at 0x10B9E3890&gt;</div><div class="line">&gt;&gt;&gt; print(im.format, im.size, im.mode)</div><div class="line">(&apos;JPEG&apos;, (500, 750), &apos;RGB&apos;)</div></pre></td></tr></table></figure>
<p><code>format</code>这个属性标识了图像来源。如果图像不是从文件读取那它的值为None。<code>size</code>属性是一个二元tuple，包含width和height(单位px)。<code>mode</code>属性定义了图像bands的数量和名称，以及像素类型和深度。常见的modes有“L”(luminance)表示灰度图像，“RGB”表示真彩色图像，“CMYK”表示出版图像。</p>
<p>如果文件打开错误，则返回<code>IOError</code>错误。</p>
<p>只要有了<code>Image</code>类的实例，就可以通过类的方法处理图像。比如下面的方法可以用来显示图像:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; im.show()</div></pre></td></tr></table></figure>
<pre>
注解：标准的<code>show()</code>效率不高，它需要保存图像到临时文件然后通过xv显示图像。
</pre>

<h1 id="读写图像"><a href="#读写图像" class="headerlink" title="读写图像"></a>读写图像</h1><p>PIL模块支持大量图片格式。使用在<code>Image</code>模块的<code>open()</code>函数从磁盘读取文件。不需要知道文件格式就能打开它，这个库能够根据文件内容自动确定文件格式。</p>
<p>要保存文件，使用<code>Image</code>类的<code>save()</code>方法。保存文件时文件名变得重要了。除非指定格式，否则这个库将会以文件名的扩展名作为格式保存。</p>
<h2 id="创建略缩图"><a href="#创建略缩图" class="headerlink" title="创建略缩图"></a>创建略缩图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; im = Image.open(&apos;lena.jpg&apos;)</div><div class="line">&gt;&gt;&gt; print im.size</div><div class="line">(500, 750)</div><div class="line">&gt;&gt;&gt; size = (250, 375)</div><div class="line">&gt;&gt;&gt; im.thumbnail(size)</div><div class="line">&gt;&gt;&gt; print im.size</div><div class="line">(250, 375)</div></pre></td></tr></table></figure>
<p>使用<code>thumbnail()</code>方法需要注意的是，指定的<code>size</code>应当比原尺寸小，且转换后的图片比例与原图片比例相同。</p>
<h2 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h2><p>继续执行下述步骤,将转换后的图片保存:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; im.save(&apos;lena_thumbnail.jpg&apos;, &apos;JPEG&apos;)</div></pre></td></tr></table></figure>
<h1 id="剪切、粘贴、合并图像"><a href="#剪切、粘贴、合并图像" class="headerlink" title="剪切、粘贴、合并图像"></a>剪切、粘贴、合并图像</h1><p><code>Image</code>类包含的方法允许操作图像部分选区，使用<code>Image.crop()</code>方法获取图像的一个子矩形选区。</p>
<h2 id="从图像中复制出一个矩形选区"><a href="#从图像中复制出一个矩形选区" class="headerlink" title="从图像中复制出一个矩形选区"></a>从图像中复制出一个矩形选区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print im.size</div><div class="line">(500, 750)</div><div class="line">&gt;&gt;&gt; box = (100, 100, 400, 400)</div><div class="line">&gt;&gt;&gt; region = im.crop(box)</div><div class="line">&gt;&gt;&gt; region.show()</div></pre></td></tr></table></figure>
<p>矩形选区有一个四元元组定义，分别表示左上、右下的坐标。这个库以左上角为坐标原点，单位是px，所以上述代码复制了一个 300x300 pixels 的矩形选区。这个选区现在可以被处理并且粘贴到原图。</p>
<p>剪下来的 300x300px 图片如下所示:</p>
<p><img src="/images/lena_cut.jpg" alt="lena_cut"></p>
<h2 id="处理复制的矩形选区并粘贴到原图"><a href="#处理复制的矩形选区并粘贴到原图" class="headerlink" title="处理复制的矩形选区并粘贴到原图"></a>处理复制的矩形选区并粘贴到原图</h2><p>继续上面的步骤:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; region = region.transpose(Image.ROTATE_180)</div><div class="line">&gt;&gt;&gt; im.paste(region, box)</div><div class="line">&gt;&gt;&gt; im.show()</div></pre></td></tr></table></figure>
<p>当粘贴矩形选区的时候必须保证尺寸一致。此外，矩形选区不能在图像外。然而不必保证矩形选区和原图的颜色模式一致，因为矩形选区会被自动转换颜色。</p>
<p>效果图如下:</p>
<p><img src="/images/lena_paste.jpg" alt="lena_paste"></p>
<h2 id="分离和合并颜色通道"><a href="#分离和合并颜色通道" class="headerlink" title="分离和合并颜色通道"></a>分离和合并颜色通道</h2><p>由于上面例子已经对im进行了改变，我们重新将im指向原图片:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; im = Image.open(&apos;lena.jpg&apos;)</div><div class="line">&gt;&gt;&gt; r, g, b = im.split()</div></pre></td></tr></table></figure>
<p>如果是单色通道的图片，使用<code>split()</code>之后会返回图片本身。你可以使用<code>r.show()</code>来查看分离颜色通道后的图片。</p>
<p><img src="/images/lena_split.jpg" alt="lena_split"></p>
<p>将分离的颜色合并为RGB可用<code>merge()</code>方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; img = Image.merge(&apos;RGB&apos;, (b, g, r))</div><div class="line">&gt;&gt;&gt; img.show()</div></pre></td></tr></table></figure>
<p>以b,g,r顺序合并成的图片如图所示:</p>
<p><img src="/images/lena_merge.jpg" alt="lena_merge"></p>
<h1 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h1><p><code>PIL.Image.Image</code>类包含了设置图像大小<code>resize()</code>和旋转图像<code>rotate()</code>的方法。<code>resize()</code>接收一个元组来指定新大小。<code>rotate()</code>接收一个逆时针的角度值。</p>
<h2 id="简单的几何变换"><a href="#简单的几何变换" class="headerlink" title="简单的几何变换"></a>简单的几何变换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; print im.size</div><div class="line">(500, 750)</div><div class="line">&gt;&gt;&gt; im_resize = im.resize((250, 250))</div><div class="line">&gt;&gt;&gt; im_resize.show()</div><div class="line">&gt;&gt;&gt; im_rotate = im.rotate(45)</div><div class="line">&gt;&gt;&gt; im_rotate.show()</div></pre></td></tr></table></figure>
<p><code>im_resize.show()</code>效果图如下:</p>
<p><img src="/images/lena_resize.jpg" alt="lena_resize"></p>
<p><code>im_rotate.show()</code>效果图如下:</p>
<p><img src="/images/lena_rotate.jpg" alt="lena_rotate"></p>
<h2 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h2><p>如果要将图片旋转90°的整数倍，可以使用<code>rotate()</code>方法或者<code>transpose()</code>方法。<code>transpose()</code>还可以将图片按照其竖直或水平边缘翻转，由于图片过多不一一展示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">out = im.transpose(Image.FLIP_LEFT_RIGHT)</div><div class="line">out = im.transpose(Image.FLIP_TOP_BOTTOM)</div><div class="line">out = im.transpose(Image.ROTATE_90)</div><div class="line">out = im.transpose(Image.ROTATE_180)</div><div class="line">out = im.transpose(Image.ROTATE_270)</div></pre></td></tr></table></figure>
<p>使用<code>transpose(ROTATE)</code>和<code>rotate()</code>是没有区别的。更普遍的方法是使用<code>transform()</code>方法。</p>
<h1 id="颜色变换"><a href="#颜色变换" class="headerlink" title="颜色变换"></a>颜色变换</h1><p>Python Imaging Library可以使用<code>convert()</code>方法来实现像素的变换。</p>
<h2 id="颜色模式转换"><a href="#颜色模式转换" class="headerlink" title="颜色模式转换"></a>颜色模式转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; im.convert(&apos;L&apos;).show()</div></pre></td></tr></table></figure>
<p>PIL库支持各种不同模式之间的转换，比如“L”和“RGB”模式。为了转成其他的模式，需要用一张中间模式图像，典型的为RGB图片。</p>
<h1 id="颜色增强"><a href="#颜色增强" class="headerlink" title="颜色增强"></a>颜色增强</h1><p>PIL库提供了许多方法和模块可以用来增强图像</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p><code>ImageFilter</code>模块包含了许多预定义的增强过滤器，通过<code>filter</code>方法调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import ImageFilter</div><div class="line">&gt;&gt;&gt; out = im.filter(ImageFilter.DETAIL)</div></pre></td></tr></table></figure>
<h2 id="点操作"><a href="#点操作" class="headerlink" title="点操作"></a>点操作</h2><p><code>point()</code>方法能够用来实现图片像素值的转换(比如图像对比度处理)。在大多数情况下，<code>point()</code>方法接收一个函数体作为参数，每一个像素都根据此函数处理:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; out = im.point(lambda i: i * 1.2)</div></pre></td></tr></table></figure>
<p>效果图如下，相比原图有增强:</p>
<p><img src="/images/lena_point.jpg" alt="lena_point"></p>
<p>处理个别bands:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># split the image into individual bands</div><div class="line">source = im.split()</div><div class="line"></div><div class="line">R, G, B = 0, 1, 2</div><div class="line"></div><div class="line"># select regions where red is less than 100</div><div class="line">mask = source[R].point(lambda i: i &lt; 100 and 255)</div><div class="line"></div><div class="line"># process the green band</div><div class="line">out = source[G].point(lambda i: i * 0.7)</div><div class="line"></div><div class="line"># paste the processed band back, but only where red was &lt; 100</div><div class="line">source[G].paste(out, None, mask)</div><div class="line"></div><div class="line"># build a new multiband image</div><div class="line">im = Image.merge(im.mode, source)</div></pre></td></tr></table></figure>
<p>效果和原图差异不大，就不上图了。需要注意的是这个语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">imout = im.point(lambda i: expression and 255)</div></pre></td></tr></table></figure>
<p>如果expression的值为false/0，则and之后的不再检查，直接返回0。如果expression的值为true/非0，判断and之后的表达式，并返回最后一个检查的值，语句返回255。</p>
<h2 id="增强"><a href="#增强" class="headerlink" title="增强"></a>增强</h2><p>要使用更多先进的图片增强功能，可以使用模块<code>ImageEnhance</code>中的类。你可以通过它调整对比度、亮度、颜色平衡度和尖锐度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from PIL import ImageEnhance</div><div class="line"></div><div class="line">enh = ImageEnhance.Contrast(im)</div><div class="line">enh.enhance(0.5).show(&quot;50% less contrast&quot;)</div></pre></td></tr></table></figure>
<p>对比度降低50%后效果如下:</p>
<p><img src="/images/lena_contrast.jpg" alt="lena_contrast"></p>
<h1 id="多帧图像序列"><a href="#多帧图像序列" class="headerlink" title="多帧图像序列"></a>多帧图像序列</h1><p>PIL支持图像序列(动画格式)。支持的序列格式包括FLI/FLC,GIF等。TIFF文件也能包含许多帧。打开一个序列文件时，PIL自动装载序列的第一帧。你可以使用函数来移动帧。参考图片如下:</p>
<p><img src="/images/niko.gif" alt="niko"></p>
<h2 id="读取序列"><a href="#读取序列" class="headerlink" title="读取序列"></a>读取序列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line"></div><div class="line">im = Image.open(&quot;niko.gif&quot;)</div><div class="line">im.seek(0) # 跳到第一帧</div><div class="line"></div><div class="line">try:</div><div class="line">    while 1:</div><div class="line">        im.seek(im.tell()+1) # 跳到下一帧，tell()方法返回目前的帧序号</div><div class="line">        im.show()</div><div class="line">except EOFError:</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>以前的PIL库只允许seek到下一帧，如果要倒回去需要重新打开。而现在的PIL库你可以seek到任意帧。</p>
<h2 id="序列迭代类"><a href="#序列迭代类" class="headerlink" title="序列迭代类"></a>序列迭代类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line"></div><div class="line">class ImageSequence:</div><div class="line">    def __init__(self, im):</div><div class="line">        self.im = im</div><div class="line">    def __getitem__(self, ix):</div><div class="line">        try:</div><div class="line">            if ix:</div><div class="line">                self.im.seek(ix)</div><div class="line">            return self.im</div><div class="line">        except EOFError:</div><div class="line">            raise IndexError</div><div class="line"></div><div class="line">im = Image.open(&apos;niko.gif&apos;)</div><div class="line">for frame in ImageSequence(im):</div><div class="line">    frame.show()</div></pre></td></tr></table></figure>
<h1 id="更多关于读取图像"><a href="#更多关于读取图像" class="headerlink" title="更多关于读取图像"></a>更多关于读取图像</h1><p><code>Image.open()</code>方法是用来打开一个图片文件的。大多数情况下可以简单的将图像文件名作参数传入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">im = Image.open(&apos;lena.jpg&apos;)</div></pre></td></tr></table></figure>
<p>正常返回结果是一个<code>PIL.Image.Image</code>实例。否则会抛出<code>IOError</code>错误。</p>
<p>你可以传入一个类文件代替文件名。这个类文件必须实现<code>read()</code>，<code>seek()</code>，<code>tell()</code>方法，并且以二进制模式打开。</p>
<h2 id="从文件读取"><a href="#从文件读取" class="headerlink" title="从文件读取"></a>从文件读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; fp = open(&apos;lena.jpg&apos;, &apos;rb&apos;)</div><div class="line">&gt;&gt;&gt; im = Image.open(fp)</div></pre></td></tr></table></figure>
<h2 id="从string读取"><a href="#从string读取" class="headerlink" title="从string读取"></a>从string读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import urllib2</div><div class="line">&gt;&gt;&gt; import StringIO</div><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; headers = &#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36&apos;&#125;</div><div class="line">&gt;&gt;&gt; req = urllib2.Request(&apos;http://tupian.enterdesk.com/2014/mxy/06/19/1/8.jpg&apos;, headers=headers)</div><div class="line">&gt;&gt;&gt; buffer = urllib2.urlopen(req).read()</div><div class="line">&gt;&gt;&gt; im = Image.open(StringIO.StringIO(buffer))</div><div class="line">&gt;&gt;&gt; im.show()</div></pre></td></tr></table></figure>
<p>使用的示例图片如下:</p>
<p><img src="/images/string_pic.jpg" alt=""></p>
<h2 id="从压缩包读取"><a href="#从压缩包读取" class="headerlink" title="从压缩包读取"></a>从压缩包读取</h2><p>为示范，先将一些文件例如”lena.jpg”和”niko.gif”打包，压缩包名假设为”Imaging.tar”。从压缩包中读取”lena.jpg”可使用<code>TarIO.TarIO()</code>方法获取图片，并交由<code>Image.open()</code>处理。(Linux/Unix系统下可以简单使用<code>tar -cvf Imaging.tar lena.jpg niko.gif </code>打包为tar压缩格式)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image, TarIO</div><div class="line">&gt;&gt;&gt; fp = TarIO.TarIO(&apos;Imaging.tar&apos;, &apos;lena.jpg&apos;)</div><div class="line">&gt;&gt;&gt; im = Image.open(fp)</div></pre></td></tr></table></figure>
<p>注意：对zip压缩包进行操作时可能会出现解码错误。</p>
<h1 id="控制解码器"><a href="#控制解码器" class="headerlink" title="控制解码器"></a>控制解码器</h1><p>部分解码器支持在读取图片文件的时候对图像进行处理，常用于创建略缩图时加速解码速度(当速度比质量重要时)和传输给单色激光打印机时()。<code>draft()</code>方法可以在图像尚未加载完时对其进行处理，所以给定的模式和大小尽可能的匹配。这是通过重新配置图像解码器完成的。</p>
<h2 id="在草稿模式读取"><a href="#在草稿模式读取" class="headerlink" title="在草稿模式读取"></a>在草稿模式读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; im = Image.open(file)</div><div class="line">&gt;&gt;&gt; print(&quot;original =&quot;, im.mode, im.size)</div><div class="line">&gt;&gt;&gt; im.draft(&quot;L&quot;, (100, 100))</div><div class="line">&gt;&gt;&gt; print(&quot;draft =&quot;, im.mode, im.size)</div></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">original= RGB (500, 750)</div><div class="line">draft= L (125, 188)</div></pre></td></tr></table></figure>
<p>注意得到的图片可能不会完全的匹配给定的模式和大小。为了保证图像不比给定的大小大，使用<code>im.thumbnail()</code>方法来代替。</p>
]]></content>
      
        <categories>
            
            <category> PIL </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Scrapy采集天气数据]]></title>
      <url>http://lizonghang.github.io/2016/07/05/Scrapy%E9%87%87%E9%9B%86%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>很多网站都提供了浏览者本地的天气信息，这些信息大多是利用某些网站提供的天气API获取的，也有利用爬虫采集的。本文介绍如何用Scrapy来采集天气信息。天气信息来源为<a href="http://weather.sina.com.cn/" target="_blank" rel="external">新浪天气频道</a>。本文提取“国内”栏目的天气信息。</p>
<p>Scrapy是Python开发的一个快速,高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。用途广泛，可以用于数据挖掘、监测和自动化测试。</p>
<p>如果你还没有安装Scrapy，请参考官方的<a href="http://doc.scrapy.org/en/latest/intro/install.html" target="_blank" rel="external">安装向导</a>或在网上查找安装方法。</p>
<h1 id="创建Scrapy项目"><a href="#创建Scrapy项目" class="headerlink" title="创建Scrapy项目"></a>创建Scrapy项目</h1><p>在开始爬取之前，需要创建一个scrapy项目。进入需要存储代码的目录，执行命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ scrapy startproject weather</div></pre></td></tr></table></figure>
<p>正常初始化的文件内容应该是这样的:</p>
<p><img src="/images/weather_tree.png" alt="weather-dir"></p>
<h1 id="定义Item"><a href="#定义Item" class="headerlink" title="定义Item"></a>定义Item</h1><p>Item是保存爬取到的数据的容器，使用方法和Python字典相似，并且提供了额外的保护机制来避免拼写错误导致的未定义字段错误。</p>
<p>首先需要根据从<code><a href="http://weather.sina.com.cn/china/" target="_blank" rel="external">http://weather.sina.com.cn/china/</a></code>中获取到的数据对item进行建模。需要的内容如图:</p>
<p><img src="/images/item.png" alt="item"></p>
<p>编辑weather/items.py文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*-</div><div class="line">import scrapy</div><div class="line"></div><div class="line">class WeatherItem(scrapy.Item):</div><div class="line">    county = scrapy.Field() # 县/区</div><div class="line">    weather_day = scrapy.Field() # 白天天气</div><div class="line">    wind_day = scrapy.Field() # 白天风向</div><div class="line">    temperate_max = scrapy.Field() # 最高温度</div><div class="line">    weather_night = scrapy.Field() # 夜间天气</div><div class="line">    wind_night = scrapy.Field() # 夜间风向</div><div class="line">    temperate_min = scrapy.Field() # 最低温度</div></pre></td></tr></table></figure>
<h1 id="编写Spider"><a href="#编写Spider" class="headerlink" title="编写Spider"></a>编写Spider</h1><p>Spider是用户编写的用于从单个或多个网页中爬取数据的类。为了创建一个Spider，必须继承scrapy.Spider类，且定义以下三个属性:</p>
<ul>
<li>name - 用于区别Spider。该名字必须是唯一的，不可以给不同的Spider使用相同的名字。</li>
<li>start_urls - 包含了Spider在启动时爬取的url列表。是Spider第一轮爬取的链接。后续的URL则从初始URL获取到的数据中提取。</li>
<li>parse(self, response) - 被调用时，每个初始URL完成下载后生成的Response对象将会作为唯一的参数传递给该函数。该方法负责解析返回的数据，提取数据以及生成需要进一步处理的URL的Request对象。</li>
</ul>
<p>首先分析一下需要爬取的数据的位置和网页源代码:</p>
<p><img src="/images/province.png" alt="province"></p>
<p><img src="/images/province_code.png" alt="code"></p>
<p>我们可以看到，全国城市都位于一个<code>class=”wd_piC”</code>的<code>div</code>中的<code>a</code>标签中，于是我们可以使用如下代码来提取各省份的链接。保存于weather/spiders目录下的localweather.py文件中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def parse(self, response):</div><div class="line">    selector = scrapy.Selector(response)</div><div class="line">    for num in selector.xpath(&apos;//div[@class=&quot;wd_piC&quot;]&apos;):</div><div class="line">        for province in num.xpath(&apos;a&apos;):</div><div class="line">            self.provinces.append(province.xpath(&apos;@href&apos;).extract()[0])</div><div class="line">    yield Request(self.provinces.pop(), callback=self.getCountyWeather)</div></pre></td></tr></table></figure>
<p>上述操作将所有省份的链接提取出来，存储到一个叫<code>provinces</code>的列表中，然后从中取出一个链接，进行下一次爬取。在编写回调函数getCountyWeather之前，先查看数据的位置和网页源代码:</p>
<p><img src="/images/county.png" alt="county"></p>
<p><img src="/images/county_code.png" alt="code"></p>
<p>我们需要的信息在多个<code>class=”wd_cm_table”</code>的<code>table</code>标签中，每条信息又在其中的多个<code>tr</code>标签中，最后标签<code>td</code>中含有我们需要的信息。</p>
<p>用于获取这些信息的方法getCountyWeather()代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">def getCountyWeather(self, response):</div><div class="line">    item = WeatherItem()</div><div class="line">    selector = scrapy.Selector(response)</div><div class="line">    for table in selector.xpath(&apos;//table[@class=&quot;wd_cm_table&quot;]&apos;):</div><div class="line">        for each_row in table.xpath(&apos;tr&apos;):</div><div class="line">            tds = each_row.xpath(&apos;td&apos;)</div><div class="line">            item[&apos;county&apos;] = tds[0].xpath(&apos;a/text()&apos;).extract()[0]</div><div class="line">            item[&apos;weather_day&apos;] = tds[1].xpath(&apos;p/text()&apos;).extract()[0]</div><div class="line">            item[&apos;wind_day&apos;] = tds[2].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">            item[&apos;temperate_max&apos;] = tds[3].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">            item[&apos;weather_night&apos;] = tds[4].xpath(&apos;p/text()&apos;).extract()[0]</div><div class="line">            item[&apos;wind_night&apos;] = tds[5].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">            item[&apos;temperate_min&apos;] = tds[6].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">            yield item</div><div class="line">    if len(self.provinces) &gt; 0:</div><div class="line">        yield Request(self.provinces.pop(), callback=self.getCountyWeather)</div><div class="line">    else:</div><div class="line">        print &apos;The Spider Has Finished Its Work! Wish To Meet U Later!&apos;</div></pre></td></tr></table></figure>
<h1 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h1><p>localweather.py中的全部代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># encoding: utf-8</div><div class="line">import scrapy</div><div class="line">from scrapy.http import Request</div><div class="line">from weather.items import WeatherItem</div><div class="line"></div><div class="line"></div><div class="line">class WeatherSpider(scrapy.Spider):</div><div class="line">    name = &apos;WeatherSpider&apos;</div><div class="line">    allowed_domains = [&apos;sina.com.cn&apos;]</div><div class="line">    start_urls = [&apos;http://weather.sina.com.cn/china/&apos;]</div><div class="line">    provinces = []</div><div class="line"></div><div class="line">    def parse(self, response):</div><div class="line">        selector = scrapy.Selector(response)</div><div class="line">        for num in selector.xpath(&apos;//div[@class=&quot;wd_piC&quot;]&apos;):</div><div class="line">            for province in num.xpath(&apos;a&apos;):</div><div class="line">                self.provinces.append(province.xpath(&apos;@href&apos;).extract()[0])</div><div class="line">        yield Request(self.provinces.pop(), callback=self.getCountyWeather)</div><div class="line"></div><div class="line">    def getCountyWeather(self, response):</div><div class="line">        item = WeatherItem()</div><div class="line">        selector = scrapy.Selector(response)</div><div class="line">        for table in selector.xpath(&apos;//table[@class=&quot;wd_cm_table&quot;]&apos;):</div><div class="line">            for each_row in table.xpath(&apos;tr&apos;):</div><div class="line">                tds = each_row.xpath(&apos;td&apos;)</div><div class="line">                item[&apos;county&apos;] = tds[0].xpath(&apos;a/text()&apos;).extract()[0]</div><div class="line">                item[&apos;weather_day&apos;] = tds[1].xpath(&apos;p/text()&apos;).extract()[0]</div><div class="line">                item[&apos;wind_day&apos;] = tds[2].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">                item[&apos;temperate_max&apos;] = tds[3].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">                item[&apos;weather_night&apos;] = tds[4].xpath(&apos;p/text()&apos;).extract()[0]</div><div class="line">                item[&apos;wind_night&apos;] = tds[5].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">                item[&apos;temperate_min&apos;] = tds[6].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">                yield item</div><div class="line">        if len(self.provinces) &gt; 0:</div><div class="line">            yield Request(self.provinces.pop(), callback=self.getCountyWeather)</div><div class="line">        else:</div><div class="line">            print &apos;The Spider Has Finished Its Work! Wish To Meet U Later!&apos;</div></pre></td></tr></table></figure>
<h1 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h1><p>存储到Item中的数据可以导出为JSON/JSON lines/CSV/XML格式的文件。以导出为CSV文件为例，其他的请参考<a href="http://doc.scrapy.org/en/1.1/topics/feed-exports.html" target="_blank" rel="external">官方说明</a>。需要修改weather/settings.py中的配置，在配置最后添加代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FEED_URI = u&apos;~/Desktop/Weather.csv&apos; # 存储csv文件的目录，可任意修改</div><div class="line">FEED_FORMAT = &apos;CSV&apos; # 存储格式为csv，可修改为json等其他格式</div></pre></td></tr></table></figure>
<p>随后，在项目的scrapt.cfg文件同级目录下使用命令，运行爬虫:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ scrapy crawl WeatherSpider</div></pre></td></tr></table></figure>
<p>等待运行结束，得到一个csv文件如下所示，显示为乱码，这是由于编码问题造成的:</p>
<p><img src="/images/csverr.png" alt="csv"></p>
<p>将csv文件用Sublime Text打开，点击File-&gt;Save with Encoding-&gt;UTF-8 with BOM，再用Excel打开，即可恢复正常。该文件中包含了全国所有城市的天气情况。</p>
<p><img src="/images/csv1.png" alt="csv"></p>
<p>然而，csv文件中的顺序并不是按照Items.py中指定的顺序来的，可作如下修改:</p>
<p>第一步:在scrapy的spider同层目录下，新建CsvItemExporter.py文件夹，内容如下(文件名可修改):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from scrapy.conf import settings</div><div class="line">from scrapy.contrib.exporter import CsvItemExporter</div><div class="line"></div><div class="line">class ProjectCsvItemExporter(CsvItemExporter):</div><div class="line">    def __init__(self, *args, **kwargs):</div><div class="line">        kwargs[&apos;delimiter&apos;] = settings.get(&apos;CSV_DELIMITER&apos;, &apos;,&apos;)</div><div class="line">        if settings.get(&apos;FIELDS_TO_EXPORT&apos;, []):</div><div class="line">            kwargs[&apos;fields_to_export&apos;] = settings.get(&apos;FIELDS_TO_EXPORT&apos;, [])</div><div class="line"></div><div class="line">        super(ProjectCsvItemExporter, self).__init__(*args, **kwargs)</div></pre></td></tr></table></figure>
<p>第二步:在settings.py文件末新增如下内容，指定item的field顺序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">FEED_EXPORTERS = &#123;</div><div class="line">    # 项目名.文件名.类名</div><div class="line">    &apos;csv&apos;: &apos;weather.CsvItemExporter.ProjectCsvItemExporter&apos;, </div><div class="line">&#125;</div><div class="line"></div><div class="line"># 导出字段顺序</div><div class="line">FIELDS_TO_EXPORT = [</div><div class="line">    &apos;county&apos;,</div><div class="line">    &apos;weather_day&apos;,</div><div class="line">    &apos;wind_day&apos;,</div><div class="line">    &apos;temperate_max&apos;,</div><div class="line">    &apos;weather_night&apos;,</div><div class="line">    &apos;wind_night&apos;,</div><div class="line">    &apos;temperate_min&apos;,</div><div class="line">]</div></pre></td></tr></table></figure>
<p>第三步:再次运行爬虫，获取的csv文件内容如下所示:</p>
<p><img src="/images/csv2.png" alt="csv"></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>关于为Item指定中文名的问题作者暂时还未找到类似django model中verbose_name参数的解决方法，若有需要可在程序末对csv文件进行文件IO处理，替换第一行。或者取代scrapy的文件导出，自行将数据导出到csv文件。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[添加Google统计]]></title>
      <url>http://lizonghang.github.io/2016/07/03/%E6%B7%BB%E5%8A%A0Google%E7%BB%9F%E8%AE%A1/</url>
      <content type="html"><![CDATA[<p>步骤一:</p>
<p>注册Google账户，登陆后访问<a href="https://analytics.google.com" target="_blank" rel="external">Google Analytics</a>，按照提示填写网站信息开通GA服务，获取统计ID。</p>
<p>步骤二:</p>
<p>编辑主题配置文件，找到字段google_analytics，删除注释并填写统计ID:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">google_analytics: your-analytics-id</div></pre></td></tr></table></figure>
<p>步骤三:</p>
<p>进入GA数据查看页查看会话数、用户数、浏览量、平均会话时长、跳出率等信息</p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[设置侧边栏社交链接]]></title>
      <url>http://lizonghang.github.io/2016/07/03/%E8%AE%BE%E7%BD%AE%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%A4%BE%E4%BA%A4%E9%93%BE%E6%8E%A5/</url>
      <content type="html"><![CDATA[<p>编辑主题配置文件_config.yml，找到字段social，删除注释并添加社交站点名称与地址，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Social links</div><div class="line">social:</div><div class="line">  github: https://github.com/your-user-name</div><div class="line">  twitter: https://twitter.com/your-user-name</div><div class="line">  weibo: http://weibo.com/your-user-name</div><div class="line">  douban: http://douban.com/people/your-user-name</div><div class="line">  zhihu: http://www.zhihu.com/people/your-user-name</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[创建about页面]]></title>
      <url>http://lizonghang.github.io/2016/07/03/%E5%88%9B%E5%BB%BAabout%E9%A1%B5%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>创建“关于我”页面</p>
<p>新建一个about页面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new page &apos;about&apos;</div></pre></td></tr></table></figure>
<p>修改主题配置文件，将menu下的about:/about/注释取消即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /</div><div class="line">  archives: /archives</div><div class="line">  tags: /tags</div><div class="line">  about: /about</div></pre></td></tr></table></figure>
<p>更改menu中项目的顺序可更改在菜单中显示的顺序。</p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[创建分类页面]]></title>
      <url>http://lizonghang.github.io/2016/07/03/%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>为Hexo添加分类页面的index.html，并在其菜单中显示各分类的链接</p>
<p>第一步:新建一个页面，命名为categories:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new page categories</div></pre></td></tr></table></figure>
<p>第二步:编辑新建的md文件，将页面类型设置为”categories”，主题将自动为这个页面显示所有的分类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">title: 分类</div><div class="line">date: 2014-12-22 12:39:04</div><div class="line">type: &quot;categories&quot;</div><div class="line">---</div></pre></td></tr></table></figure>
<p>注意: 如果有启动多说或Disqus评论，默认的页面也会带有评论。如果需要关闭可以将字段comments设置为false:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">title: 分类</div><div class="line">date: 2014-12-22 12:39:04</div><div class="line">type: &quot;categories&quot;</div><div class="line">comments: false</div><div class="line">---</div></pre></td></tr></table></figure>
<p>第三步:编辑主题配置文件_config.yml，将menu中的categories:/categories注释去掉:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /</div><div class="line">  categories: /categories</div><div class="line">  archives: /archives</div><div class="line">  tags: /tags</div></pre></td></tr></table></figure>
<p>第四步:清空缓存、生成静态文件、发布/预览:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div><div class="line">$ hexo generate</div><div class="line">$ hexo deploy	# 发布</div><div class="line">$ hexo server	# 打开本地服务器在页面上预览</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Hexo搭建Github Page]]></title>
      <url>http://lizonghang.github.io/2016/06/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAGithub-Page/</url>
      <content type="html"><![CDATA[<h1 id="创建Github-io"><a href="#创建Github-io" class="headerlink" title="创建Github.io"></a>创建Github.io</h1><p>本文默认的前提为你会使用Git，如不会使用Git或没有Github账号，请参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的Git教程</a></p>
<p>要在github上搭建github pages，需要在你的github下新建一个名为[username].github.io的仓库，其中username是你的用户名(或组织名称)。注意: 如果username与你的用户名不同将无法成功。</p>
<p>在电脑自定义的位置新建一个文件夹如github.io，然后进入github.io文件夹执行git初始化命令并克隆github.io仓库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git init</div><div class="line">$ git clone https://github.com/username/username.github.io</div></pre></td></tr></table></figure>
<p>进入项目文件夹并增加一个index.html文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd username.github.io</div><div class="line">$ echo &quot;Hello World&quot; &gt; index.html</div></pre></td></tr></table></figure>
<p>将你的github.com/username/username.github.io设置一个名称，假设为blog:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote add blog git@github.com:username/username.github.io.git</div></pre></td></tr></table></figure>
<p>执行add,commit操作并push到你的blog仓库，注意，请确认你是否push到了正确的仓库:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git add -A</div><div class="line">$ git commit -m &quot;Initial Commit&quot;</div><div class="line">$ git push blog master</div></pre></td></tr></table></figure>
<p>如果出现错误，不能push，请尝试先进行pull，再进行push操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull blog master</div></pre></td></tr></table></figure>
<p>当你的username.github.io仓库中存在index.html时，访问你的博客页面，如username.github.io，可以看到页面上出现“Hello World”，你就拥有了一个自己的github博客。</p>
<h1 id="使用Hexo作博客模板"><a href="#使用Hexo作博客模板" class="headerlink" title="使用Hexo作博客模板"></a>使用Hexo作博客模板</h1><p>当然不是每个人都有时间去写博客页面或管理自己的博客，此时即可借助Hexo来帮你管理和生成你的博客。</p>
<p>在安装Hexo之前，请确保你的电脑中安装有node.js，否则可能出现错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">init env: node: No such file or directory</div></pre></td></tr></table></figure>
<p>若电脑中没有node.js，前往<a href="https://nodejs.org/en/" target="_blank" rel="external">nodejs的官方网站</a>下载，本人使用的是<a href="https://nodejs.org/dist/v4.4.7/node-v4.4.7.pkg" target="_blank" rel="external">v4.4.7 LTS版本</a>。下载完成后，运行安装程序即可完成安装，安装node.js后也安装好了npm。</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo npm install -g hexo</div></pre></td></tr></table></figure>
<h2 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init</div></pre></td></tr></table></figure>
<p>这个命令会初始化博客目录，执行命令时在你想要创建的目录下执行，此时该目录下会生成以下文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">   ├── .deploy</div><div class="line">   ├── public</div><div class="line">   ├── scaffolds</div><div class="line">   ├── scripts</div><div class="line">   ├── source</div><div class="line">   |   ├── _drafts</div><div class="line">   |   └── _posts</div><div class="line">   ├── themes</div><div class="line">   ├── _config.yml</div><div class="line">   └── package.json</div></pre></td></tr></table></figure>
<p>文件说明:</p>
<ul>
<li>.deploy：执行hexo deploy命令部署到GitHub上的内容目录</li>
<li>public：执行hexo generate命令，输出的静态网页内容目录</li>
<li>scaffolds：layout模板文件目录，其中的md文件可以添加编辑</li>
<li>scripts：扩展脚本目录，这里可以自定义一些javascript脚本</li>
<li>source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。</li>
<li>_drafts：草稿文章</li>
<li>_posts：发布文章</li>
<li>themes：主题文件目录</li>
<li>_config.yml：全局配置文件，大多数的设置都在这里</li>
<li>package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮</li>
</ul>
<p>你可以尝试使用运行hexo服务器并<a href="127.0.0.1:4000" target="_blank" rel="external">在浏览器中打开</a>来检查Hexo是否正常工作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<h2 id="将Hexo的模板应用到github-io"><a href="#将Hexo的模板应用到github-io" class="headerlink" title="将Hexo的模板应用到github.io"></a>将Hexo的模板应用到github.io</h2><p>在hexo中有两个_config.yml文件，一个位于hexo的根目录下，我们称之为全局配置文件，另一个位于/themes/landscape/_config.yml，称之为主题配置文件。</p>
<p>打开全局配置文件_config.yml，你需要注意的配置有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">title: title    #博客名</div><div class="line">subtitle: subtitle  #博客副标题</div><div class="line">description:          #网站描述, 用于爬虫抓取的关键词</div><div class="line">author: author    #作者名称</div><div class="line">email: email  #作者邮箱</div><div class="line">language: zh-CN       #网页编码,中文</div><div class="line">root: /			# 一定要从/开始，否则与github.io不能同步路径</div><div class="line">deploy:</div><div class="line">  type: github    #部署类型Github</div><div class="line">  repository: git@github.com:username/username.github.io.git </div><div class="line">  branch: master   #部署分支,一般使用master主分支</div></pre></td></tr></table></figure>
<p>保存设置后执行命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<p>随后将hexo下的模板文件同步到github:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo deploy</div></pre></td></tr></table></figure>
<p>稍等片刻，打开你的username.github.io，应当可以看到hexo的模板页面。</p>
<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h2><p>使用如下命令后在hexo根目录中/source/_posts/目录下新增一个new-article.md文本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new &apos;new-article&apos;</div></pre></td></tr></table></figure>
<p>编辑该文件，以markdown格式书写自己的博文。关于markdown的使用方法请参考<a href="http://www.appinn.com/markdown/" target="_blank" rel="external">Markdown语法说明(简体中文版)</a>。编辑时，可启动hexo本地服务器实时查看<a href="127.0.0.1:4000" target="_blank" rel="external">页面效果</a>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>编辑完成后，使用如下命令发布到github上:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo clean		# 清理原有文件，以防与新文件冲突</div><div class="line">$ hexo generate		# 生成静态站点文件</div><div class="line">$ hexo deploy		# 发布到github pages上</div></pre></td></tr></table></figure>
<p>完成操作后，稍等十秒(github pages更新有延迟)，刷新github pages页面查看页面效果</p>
<h2 id="删除文章"><a href="#删除文章" class="headerlink" title="删除文章"></a>删除文章</h2><p>直接删除本地hexo目录下/source/_posts/中的md文件，再执行清理、生成静态站点文件、发布操作即可。命令参考”新增文章”。</p>
<h1 id="更换模板"><a href="#更换模板" class="headerlink" title="更换模板"></a>更换模板</h1><p>官方默认的主题为landscape主题，主题存放于themes文件夹中，可以更改全局配置文件来更换为需要的主题。</p>
<h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h2><p>官方提供了许多<a href="https://hexo.io/themes/" target="_blank" rel="external">主题</a>，可自行选择喜欢的主题并下载。以我使用的是<a href="https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="external">next</a>主题为例。首先需要将主题文件下载下来(在Downloads分类下)，解压后存放于themes目录下，并将文件夹名称简化为next。</p>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>打开全局配置文件，找到theme字段，将其更改为next，<a href="127.0.0.1:4000" target="_blank" rel="external">验证主题</a>是否启动:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo s --debug</div></pre></td></tr></table></figure>
<h3 id="选择-Scheme"><a href="#选择-Scheme" class="headerlink" title="选择 Scheme"></a>选择 Scheme</h3><p>NexT通过Scheme提供主题中的主题。Mist是NexT的第一款Scheme。启用Mist仅需在主题配置文件中将 #scheme: Mist 前面的#注释去掉即可。</p>
<h3 id="语言设置"><a href="#语言设置" class="headerlink" title="语言设置"></a>语言设置</h3><p>编辑全局配置文件，将 language 设置成需要的语言。例如选用正体中文，则配置为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">language: zh-Hans</div></pre></td></tr></table></figure>
<p>可用的语言如以下表格所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>语言</th>
<th>代码</th>
<th>设定值</th>
</tr>
</thead>
<tbody>
<tr>
<td>English</td>
<td>en</td>
<td>language: en</td>
</tr>
<tr>
<td>简体中文</td>
<td>zh-Hans</td>
<td>language: zh-Hans</td>
</tr>
<tr>
<td>French</td>
<td>fr-FR</td>
<td>language: fr-FR</td>
</tr>
<tr>
<td>正体中文</td>
<td>zh-hk/zh-tw</td>
<td>language: zh-hk</td>
</tr>
<tr>
<td>Russian</td>
<td>ru</td>
<td>language: ru</td>
</tr>
<tr>
<td>German</td>
<td>de</td>
<td>language: de</td>
</tr>
</tbody>
</table>
</div>
<h3 id="菜单配置"><a href="#菜单配置" class="headerlink" title="菜单配置"></a>菜单配置</h3><p>菜单配置在主题配置文件的menu。若站点运行在子目录中，请将链接前缀的/去掉。默认支持的菜单项有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>键值</th>
<th>设定值</th>
<th>comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>home</td>
<td>home:/</td>
<td>主页</td>
</tr>
<tr>
<td>archives</td>
<td>archives: /archives</td>
<td>归档页</td>
</tr>
<tr>
<td>categories</td>
<td>categories: /categories</td>
<td>分类页（需手动创建）</td>
</tr>
<tr>
<td>tags</td>
<td>tags: /tags</td>
<td>标签页（需手动创建）</td>
</tr>
<tr>
<td>about</td>
<td>about: /about</td>
<td>关于页面 （需手动创建）</td>
</tr>
<tr>
<td>commonweal</td>
<td>commonweal: /404.html</td>
<td>公益 404 （需手动创建）</td>
</tr>
</tbody>
</table>
</div>
<p>菜单配置示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /</div><div class="line">  archives: /archives</div><div class="line">  #about: /about</div><div class="line">  #categories: /categories</div><div class="line">  tags: /tags</div><div class="line">  #commonweal: /404.html</div></pre></td></tr></table></figure>
<h3 id="侧栏设置"><a href="#侧栏设置" class="headerlink" title="侧栏设置"></a>侧栏设置</h3><p>默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示。可以通过修改主题配置文件中的 sidebar 字段来控制侧栏的行为。</p>
<p>支持的选项有：</p>
<p>post - 默认行为，在文章页面（拥有目录列表）时显示<br>always - 在所有页面中都显示<br>hide - 在所有页面中都隐藏（可以手动展开）</p>
<p>侧栏示例配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sidebar: post</div></pre></td></tr></table></figure>
<h3 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h3><p>编辑主题配置文件，新增字段 avatar，值设置成头像的链接地址。</p>
<p>其中，头像的链接地址可以是完整网络图片url，或站内文件。其中站内文件的url与图片放置位置如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/uploads/avatar.jpg - 需要将头像图片放置在站点的source/uploads/（可能需要新建uploads目录）</div><div class="line">/images/avatar.jpg - 需要将头像图片放置在主题的source/images/目录下|</div></pre></td></tr></table></figure>
<p>头像配置示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">avatar: https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460</div></pre></td></tr></table></figure>
<h3 id="作者名称"><a href="#作者名称" class="headerlink" title="作者名称"></a>作者名称</h3><p>编辑全局配置文件，设置 author 为作者的昵称。</p>
<h3 id="站点描述设置"><a href="#站点描述设置" class="headerlink" title="站点描述设置"></a>站点描述设置</h3><p>编辑全局配置文件，设置 description 字段为你的站点描述。</p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
