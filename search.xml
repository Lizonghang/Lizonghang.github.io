<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[神经动力学]]></title>
      <url>http://lizonghang.github.io/2018/04/20/%E7%A5%9E%E7%BB%8F%E5%8A%A8%E5%8A%9B%E5%AD%A6/</url>
      <content type="html"><![CDATA[<p>神经网络视为非线性动力系统，并特别强调其稳定性问题，称为<strong>神经动力学(neurodynamics)</strong>。在非线性动态系统背景下，稳定性通常意味着Lyapunov稳定性，而非BIBO稳定性，因为神经元结构之中的饱和非线性激活单元使得这样的非线性系统都是BIBO稳定的。</p>
<h1 id="动态系统"><a href="#动态系统" class="headerlink" title="动态系统"></a>动态系统</h1><p>令系统状态向量x(t)=[x<sub>1</sub>(t),x<sub>2</sub>(t),···,x<sub>N</sub>(t)]，其中连续时间t是独立变量，N为系统的阶，那么非线性动态系统的一大类动力学特征就可以用一阶微分方程组的形式给出</p>
<center><img src="/img/1FD606074979A9C419117A7637D68FC1.jpg" height="50px"></center>]]></content>
      
        <categories>
            
            <category> ML/DL </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[GD/Momentum/Adagrad/RMSprop/Adam]]></title>
      <url>http://lizonghang.github.io/2018/04/20/GD-Momentum-Adagrad-RMSprop-Adam/</url>
      <content type="html"><![CDATA[<h1 id="带动量的GD算法"><a href="#带动量的GD算法" class="headerlink" title="带动量的GD算法"></a>带动量的GD算法</h1><h2 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h2><p>经典GD算法的缺点是其更新方向完全依赖于batch计算的loss，因而十分不稳定。Momentum算法借用物理中动量的概念，模拟物体运动时的惯性，即更新时在一定程度上保持之前的更新方向，同时利用batch的梯度调整更新方向。从而能在一定程度上增加训练稳定性，使学习更快，并且具备一定摆脱局部最优的能力。</p>
<center><img src="/img/1FBD345FD7B079F41CE0A5A7472E31A4.jpg" width="150px"></center>

<p>其中v<sub>t</sub>是当前梯度，v<sub>t-1</sub>是历史梯度，γ是衰减率，α是学习率，J(θ)是损失函数。</p>
<p>类似的改进还有Nesterov Momentum。</p>
<h1 id="自适应学习率的GD算法"><a href="#自适应学习率的GD算法" class="headerlink" title="自适应学习率的GD算法"></a>自适应学习率的GD算法</h1><h2 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h2><p>上述算法中，对每一个参数θ<sub>i</sub>的训练都使用了相同的学习率α。在Adagrad中设置全局学习率α后，每次通过全局学习率逐参数除以历史梯度的平方和的平方根，使得每个参数的学习率不同。</p>
<p>在参数空间中较平缓的方向累和平方根小，因而获得较大的学习率；相反，若在参数空间中较陡峭的方向，则获得较小的学习率。</p>
<center><img src="/img/8AA715BCD0669CE76EA09BE3EB735EBA.jpg" width="200px"></center>

<p>其中δ是一个极小的常数，大约设为10<sup>-8</sup>~10<sup>-7</sup>。</p>
<h2 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h2><p>RMSprop是Hinton提出的一种自适应学习率的算法。相比Adagrad，RMSprop不累加梯度的平方，而是估计梯度二阶矩的期望E[g<sub>t</sub><sup>2</sup>]，可缓解Adagrad中学习率下降快的问题。</p>
<center><img src="/img/790C70C2B929C9F27C71CA768DADF994.jpg" width="200px"></center>

<h2 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h2><p>Adam (Adaptive Moment Estimation)也是一种自适应学习率的方法，它利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率。</p>
<p>Adam的主要优点在于：经过偏置校正后，每一次迭代学习率都有一个确定范围，是的参数比较平稳。</p>
<center><img src="/img/F7F9DBC256D77D2DEF3F8553FB6B6F80.jpg" width="200px"></center>

<p>m<sub>t</sub>和v<sub>t</sub>是对梯度的一阶矩估计和二阶矩估计，可看作对E[g<sub>t</sub>]和E[g<sub>t</sub><sup>2</sup>]的近似；m<sub>t</sub><sup>hat</sup>和v<sub>t</sub><sup>hat</sup>是对m<sub>t</sub>和v<sub>t</sub>的校正，可近似为对期望的无偏估计。推荐参数β<sub>1</sub>=0.9，β<sub>2</sub>=0.999，δ=10<sup>-8</sup>。</p>
]]></content>
      
        <categories>
            
            <category> ML/DL </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[快速幂]]></title>
      <url>http://lizonghang.github.io/2018/04/17/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      <content type="html"><![CDATA[<p>快速幂是求底数的n次幂的快速算法，其<strong>时间复杂度为O(log<sub>2</sub>n)</strong>，相比简单的n次累积的时间复杂度O(n)更低。</p>
<p><strong>快速幂求a<sup>n</sup></strong></p>
<p>以a<sup>n</sup>为例，假设n=11：</p>
<p>n可表示为二进制形式，即：1011<sub>(2)</sub></p>
<div align="center"><img src="/img/42AC57F4-5D28-4384-908E-87F9973BF2AB.png" width="250px"></div>

<p>由上式可见，只需要len(1011<sub>(2)</sub>) = ⌈log<sub>2</sub>11⌉ = 4个乘项即可求得a<sup>11</sup>，则计算a<sup>n</sup>的时间复杂度为O(log<sub>2</sub>n)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">long pow(int a, int n)&#123;</div><div class="line">    long r=1;</div><div class="line">    while (n) &#123;</div><div class="line">        if (n &amp; 1) r *= a;</div><div class="line">        a *= a;</div><div class="line">        n &gt;&gt;= 1;</div><div class="line">    &#125;</div><div class="line">    return r;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：不合理的输入可能会导致溢出。</p>
<p><strong>快速幂求a<sup>b</sup> % n</strong></p>
<p>若先求出c = a<sup>b</sup>，再求 c % n，可能会在求解过程中溢出。</p>
<p>给出公式：(a × b) % m = [(a % m) × (b % m)] % m</p>
<p>结合快速幂算法，在每次做乘法操作时取模，可有效降低时间复杂度以及避免数值溢出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">int pow_mod(int a, int b, int n)&#123;</div><div class="line">    int r = 1;</div><div class="line">    while (b) &#123;</div><div class="line">        if (b &amp; 1) &#123;</div><div class="line">            r %= n;</div><div class="line">            a %= n;</div><div class="line">            r *= a;</div><div class="line">        &#125;</div><div class="line">        a %= n;</div><div class="line">        a *= a;</div><div class="line">        b &gt;&gt;= 1;</div><div class="line">    &#125;</div><div class="line">    r %= n;</div><div class="line">    return r;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 算法/理论 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[facenet]]></title>
      <url>http://lizonghang.github.io/2018/04/13/facenet/</url>
      <content type="html"><![CDATA[<p>FaceNet: <a href="https://arxiv.org/pdf/1503.03832.pdf" target="_blank" rel="external">https://arxiv.org/pdf/1503.03832.pdf</a></p>
<h1 id="FaceNet流程总览"><a href="#FaceNet流程总览" class="headerlink" title="FaceNet流程总览"></a>FaceNet流程总览</h1><p><img src="/img/A55C2C378E4BB29A9B613C70587620F1.jpg" alt=""></p>
<p>FaceNet的总体流程为：输入图像通过由Inception-ResNet v2作为Feature Encoder的模型产生128-d的输出向量，通过L2 regularization后得到128-d Face Embedding vectors，选择有效的Anchor-Positive Pairs和Anchor-Negative Pairs计算得到Triplet Loss，并利用SGD对Feature Encoder的网络参数进行更新，最终训练得到的是输入人脸图像到人脸的128-d编码的脸部特征向量的脸部特征编码器(而不是人脸分类器)，MAP(X<sub>im</sub>)→128-d embedding，最终利用NN(最近邻)计算128-d embedding相似度(文中采用欧式距离作为相似度)得到人脸的身份信息，若相似度超过某个阈值，则认为是未知用户。</p>
<p>FaceNet的Feature Encoder采用了VGG-like model和Inception-ResNet v2 model，Inception-ResNet v2相比VGG-like model主要有两点好处：</p>
<ul>
<li>20x fewer parameters(140M→7M) and fewer FLOPS(1.6B→0.5B~1.6B);</li>
<li>State-of-the-art performance on validation rate (87.9%±1.9→89.4%±1.6).</li>
</ul>
<h1 id="Triplet-Loss"><a href="#Triplet-Loss" class="headerlink" title="Triplet Loss"></a>Triplet Loss</h1><p><img src="/img/BD4972A9-6A71-4091-8BA1-2049AB5C668B.jpeg" alt=""></p>
<p>假设给定人脸A的两张图片Anchor、Positive，人脸B的一张图片Negative，令d表示相似度计算函数(值越小表示相似度越高，为方便说明，后续采用欧式距离描述相似度)。训练目标为，令Anchor和Positive的距离小于Anchor和Negative的距离，即：</p>
<p><img src="/img/999C9296-694D-4D5E-9DBD-7B908AE829BF.png" alt=""></p>
<p>然而，考虑一个无效的Feature Encoder，它将所有图像都映射到某个向量在极小区域范围内的embedding(不同但基本相同)，就能够较好的满足上述条件，且得到的损失几乎为零。为了避免这种情况，额外加入margin α拉大AP(Anchor-Positive Pair)和AN(Anchor-Negative Pair)之间的差距，即：</p>
<div align="center"><img src="/img/079E5673-CF5E-473D-B542-FA3723B8948B.png" width="300px"></div>

<p>取batch size = N的批量图像，对上述式子变形，得到三元组损失函数(Triplet Loss)：</p>
<div align="center"><img src="/img/0F40CF02-B9DA-4449-A76E-09BDFE4C7970.png" width="400px"></div>

<p>其中x<sub>i</sub>表示输入图像，f(·)表示Feature Encoder的映射函数，+表示L=max(L, 0)。</p>
<p>将Triplet Loss作为损失函数反向传播并梯度下降更新，最终训练得到好的Feature Encoder。</p>
<h1 id="如何选择AP-amp-AN-pairs"><a href="#如何选择AP-amp-AN-pairs" class="headerlink" title="如何选择AP&amp;AN pairs"></a>如何选择AP&amp;AN pairs</h1><p>问题：随机采样AP&amp;AN pairs时，训练一段时间后容易产生L≈0的epoch，这些APN对对于模型训练是无贡献的，直接导致了训练的低效。</p>
<p>解决思路：选择“难训练”的AP&amp;AN pairs，应用SGD进行更新。“难训练”是指，AP pair的距离大，而AN pair的距离小，从而产生较大的L。</p>
<p>解决方法：</p>
<ul>
<li>Generate triplets offline. Every n steps, using the most recent network checkpoint and computing the argmin(d(A,N)) and argmax(d(A,P)) on a subset of the data.</li>
<li>Generate triplets online. Select the hard AP&amp;AN pairs from within a mini-batch.</li>
</ul>
<h1 id="最近邻识别-NN"><a href="#最近邻识别-NN" class="headerlink" title="最近邻识别(NN)"></a>最近邻识别(NN)</h1><p>人脸数据集是自己收集的证件照图像库吗？不。在Face Recognition中有两个模型，一个是Feature Encoder的Inception-ResNet v2模型，另一个是真正用于分类的NN模型。</p>
<p>用于训练Inception-ResNet v2的数据集是LFW等公开的人脸识别数据集，训练好Face Encoder后，将证件照图像库中每张图片进行face embedding后存于数据库中，用于分类任务。</p>
<p><strong>NOTE</strong>：FaceNet对输入图像使用<a href="https://kpzhang93.github.io/MTCNN_face_detection_alignment/paper/spl.pdf" target="_blank" rel="external">MTCNN</a>进行人脸检测与截取，保证了输入到Face Encoder的人脸图像都是较为统一的。但没有对人脸角度或光照等问题进行处理。</p>
<p><img src="/img/403034BB-7187-4F57-AF10-9EE91AAB503E.png" alt=""></p>
<p><strong>NOTE</strong>：请忽视图中红色点与蓝色点的颜色，每个点代表一个人的一张证件照，每个人也只需录入一张证件照(当然若有多张证件照有利于分类精度的提高)，此类任务也称one-shot学习。</p>
<p>当获取到需要识别的人脸图像X时，将X进行face embedding后计算其与数据库中的所有编码的距离，将距离最小的作为识别结果。定义一个超参数τ，若最小距离d<sub>min</sub> &gt; τ，则认为X是未知人员，实验中需根据具体情况调整τ的值。</p>
<h1 id="类似的应用"><a href="#类似的应用" class="headerlink" title="类似的应用"></a>类似的应用</h1><p>除Face Recognition外，Face Validation和Face Cluster也使用了类似的方法，区别仅在于：</p>
<ul>
<li>Face Validation将NN替换为简单的计算当前人脸与要求验证的目标身份存于数据库中的人脸的相似度，若小于某个阈值，则验证通过；</li>
<li>Face Cluster将NN替换为KMeans等聚类算法。</li>
</ul>
<h1 id="DeepFace简介"><a href="#DeepFace简介" class="headerlink" title="DeepFace简介"></a>DeepFace简介</h1><p>DeepFace: <a href="https://www.cs.toronto.edu/~ranzato/publications/taigman_cvpr14.pdf" target="_blank" rel="external">https://www.cs.toronto.edu/~ranzato/publications/taigman_cvpr14.pdf</a></p>
<p>DeepFace在FaceNet的基础上对输入人脸图像进行了3D建模与角度调整，但DeepFace发布于FaceNet之前。其大致流程为：</p>
<p><img src="/img/2DEB07B0-CB77-4B6F-B00F-96B1E327155F.png" alt=""></p>
<ul>
<li>Detect and Crop (a→b);</li>
<li>Align to 3D model (b→d) and adjust the orientation (d→g);</li>
<li>Represent (Face Embedding)</li>
<li>Classify (NN)</li>
</ul>
<p>例：先对人脸进行3D建模与角度调整，再进行Face Embedding与Classify：</p>
<p><img src="/img/BF8B5B2F-885B-4626-AC74-51AA0CB74A77.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> ML/DL </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[DP-Knapsack]]></title>
      <url>http://lizonghang.github.io/2018/04/12/DP-knapsack/</url>
      <content type="html"><![CDATA[<p><strong>We are given 7 items and a knapsack. Each item i has weight of w<sub>i</sub> &gt; 0 kilograms and value of v<sub>i</sub> &gt; 0 dollars (given in table). The capacity of the knapsack is 14 kilograms. Then how to fill the knapsack to maximize the total value?</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Items</th>
<th style="text-align:center">Weight</th>
<th style="text-align:center">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">7</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
</div>
<p>transition function:</p>
<div align="center"><img src="/img/415FAC24-C7EA-491F-9F4A-5B67D72E596A.png" width="500px"></div>

<p>Algorithm:</p>
<p><img src="/img/AB820F36642686661EE9A10A8EC04EEB.jpg" alt=""></p>
<p>Implementation by Python:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line"></div><div class="line">N = 7</div><div class="line">C = 14</div><div class="line">W = [3, 4, 2, 2, 7, 5, 6]</div><div class="line">V = [2, 3, 3, 1, 6, 3, 5]</div><div class="line"></div><div class="line">assert N == len(W)</div><div class="line">assert N == len(V)</div><div class="line"></div><div class="line">M = np.zeros((N+1, C+1), dtype=int)</div><div class="line"></div><div class="line">for i in range(1, N+1):</div><div class="line">    for w in range(1, C+1):</div><div class="line">        if W[i-1] &gt; w:</div><div class="line">            M[i, w] = M[i-1, w]</div><div class="line">        else:</div><div class="line">            M[i, w] = max(M[i-1, w], V[i-1]+M[i-1, w-W[i-1]])</div><div class="line"></div><div class="line">print &apos;Maximum total value:&apos;, M[N][C]</div><div class="line"></div><div class="line">print &apos;Choose:&apos;,</div><div class="line">i = N</div><div class="line">j = C</div><div class="line">while i &gt; 0 and j &gt; 0:</div><div class="line">    if M[i-1, j] != M[i, j]:</div><div class="line">        print i,</div><div class="line">        j -= W[i-1]</div><div class="line">        i -= 1</div><div class="line">    else:</div><div class="line">        i -= 1</div></pre></td></tr></table></figure>
<p>State Transition Table:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12</th>
<th style="text-align:center">13</th>
<th style="text-align:center">14</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center"><label style="color: red">2</label></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center"><label style="color: red">3</label></td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center"><label style="color: red">3</label></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center"><label style="color: red">6</label></td>
<td style="text-align:center">6</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center"><label style="color: red">6</label></td>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center"><label style="color: red">5</label></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
<td style="text-align:center">12</td>
<td style="text-align:center"><label style="color: red">12</label></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
<td style="text-align:center">12</td>
<td style="text-align:center"><label style="color: red">12</label></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
<td style="text-align:center">12</td>
<td style="text-align:center"><label style="color: red">12</label></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      
        <categories>
            
            <category> 算法/理论 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[DP-Least Coin Change]]></title>
      <url>http://lizonghang.github.io/2018/04/12/DP-Least%20Coin%20Change/</url>
      <content type="html"><![CDATA[<p><strong>Given currency denominations VALUE={1, 10, 21, 34, 70, 100, 350, 1225, 1500}, devise a method to pay amount x to customer using fewest number of coins.</strong></p>
<p>transition function:</p>
<div align="center"><img src="/img/305FAC24-C7EA-491F-9F4A-5B67D72E596A.png" width="200px" height="80px"></div>

<p>Algorithm:</p>
<p><img src="/img/dp-coin.jpg" alt=""></p>
<p>Implementation by Python:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">VALUES = [1, 10, 21, 34, 70, 100, 350, 1225, 1500]</div><div class="line">n = len(VALUES)</div><div class="line">x = 140</div><div class="line"></div><div class="line">F = [0]*(x+1)</div><div class="line">record = [0]*(x+1)</div><div class="line"></div><div class="line">for i in range(1, x+1):</div><div class="line">    max_VALUES = i</div><div class="line">    value = 0</div><div class="line">    for j in range(n):</div><div class="line">        if i &gt;= VALUES[j]:</div><div class="line">            if F[i-VALUES[j]]+1 &lt;= max_VALUES and (i==VALUES[j] or record[i-VALUES[j]]!=0):</div><div class="line">                max_VALUES = F[i-VALUES[j]]+1</div><div class="line">                value = VALUES[j]</div><div class="line">    F[i] = max_VALUES</div><div class="line">    record[i] = value</div><div class="line"></div><div class="line">while x:</div><div class="line">    print record[x]</div><div class="line">    x -= record[x]</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法/理论 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark Network]]></title>
      <url>http://lizonghang.github.io/2018/04/10/Spark-Network/</url>
      <content type="html"><![CDATA[<p>文章来源：<a href="https://blog.csdn.net/struggle3014/article/details/79794031" target="_blank" rel="external">https://blog.csdn.net/struggle3014/article/details/79794031</a></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>网络是分布式系统中最基本的一环，其设计的好坏直接影响到整个分布式系统的稳定性及可用性，为此，Spark专门独立出基础网络模块spark-network，为上层RPC、Shuffle数据传输、RDD Block同步以及资源文件传输等提供可靠的网络服务。<strong>从Spark-2.0起，所有的网络功能都是通过netty来实现。</strong></p>
<h2 id="消息抽象"><a href="#消息抽象" class="headerlink" title="消息抽象"></a>消息抽象</h2><p>Spark中定义三种类型的消息：RPC消息、ChunkFetch消息、Stream消息。Message是这些消息的抽象接口，它定义了三个关键接口，分别得到消息类型、消息体以及判断消息体是否编码在header中。</p>
<h3 id="RPC消息"><a href="#RPC消息" class="headerlink" title="RPC消息"></a>RPC消息</h3><p>RPC消息用于抽象所有spark中涉及到RPC操作时需要传输的消息，通常这类消息很小，一般都是控制类消息。RPC消息包括RpcRequest、OneWayMessage、RpcResponse、RpcFailure四种消息。</p>
<ul>
<li>RpcRequest：封装RPC请求消息，这类RPC请求需要得到一个RPC响应，RpcRequest除了消息体外还包括一个requestId字段，用于唯一标识一个RPC请求。RpcResponse是RPC调用正常返回的响应消息，RpcFailure是RPC调用异常返回的响应消息，它们除了消息体外也包括requestId字段，该字段用于对应RpcRequest。</li>
<li>OneWayMessage：这类RPC请求不需要响应，所以只包含消息体。</li>
</ul>
<h3 id="ChunkFetch消息"><a href="#ChunkFetch消息" class="headerlink" title="ChunkFetch消息"></a>ChunkFetch消息</h3><p>ChunkFetch消息用于抽象所有spark中涉及到数据拉取操作时需要传输的消息，它用于shuffle数据以及RDD Block数据传输。在shuffle阶段，reduce task会去拉取map task结果中的对应partition数据，这需要发起一个ChunkFetch；另外，当RDD被缓存后，如果节点上没有所需的RDD Block，则会发起一个ChunkFetch拉取其他节点上的RDD Block。ChunkFetch消息包括ChunkFetchRequest、ChunkFetchSuccess以及ChunkFetchFailure三种消息。</p>
<ul>
<li>ChunkFetchRequest：封装ChunkFetch请求消息，其只包括StreamChunkId字段，没有消息体，StreamChunkId包括streamId和chunkIndex两个字段，streamId标识这次chunk fetch，chunkIndex标识fetch的数据块，通常一次fetch可能会fetch多个chunk。</li>
<li>ChunkFetchSuccess是成功Fetch后的响应消息，ChunkFetchFailure是Fetch失败的响应消息，它们包含了Fetch的消息体外，还包括StreamChunkId，以及对应ChunkFetchRequest。</li>
</ul>
<h3 id="Stream消息"><a href="#Stream消息" class="headerlink" title="Stream消息"></a>Stream消息</h3><p>Stream消息主要用于driver到executor传输jar、file文件等，executor需要获取相关jar包或file文件时，会发起一个StreamRequest消息给driver，driver会返回一个StreamResponse，executor根据响应中的字节数来进一步去截获后续数据内容。Stream消息包括StreamRequest、StreamResponse、StreamFailure三种消息。</p>
<ul>
<li>StreamRequest：Stream请求消息，只包含一个streamId标识请求。</li>
<li>StreamResponse：Stream成功响应消息，包含streamId以及响应的字节数，并后面跟数据内容，实际使用时，客户端会根据响应中的字节数进一步获取实际内容。</li>
<li>StreamFailure表示Stream失败的响应消息，包含streamId以及异常信息。</li>
</ul>
<h2 id="网络抽象"><a href="#网络抽象" class="headerlink" title="网络抽象"></a>网络抽象</h2><p>无论是服务器还是客户端都会关联一个channel(socket)，channel上会绑定一个pipeline，pipeline绑定若干个handler，用来专门用来处理和业务有关的东西，handler有DownHandler和UpHandler两种，DownHandler用来处理发包，UpHandler用来处理收包。</p>
<p>Spark底层网络实现总体流程如下图所示：</p>
<p><img src="/images/spark-network-basic.png" alt=""></p>
<p>客户端发送请求消息，经过Encoder(一种DownHandler)编码，加上包头信息，再通过网络发给服务端，服务端收到消息后，首先经过TransportFrameDecoder(一种UpHandler)处理粘包拆包，得到消息类型和消息体，然后经过Decoder解析消息类型，得到一个个具体的请求消息，最后由TransportChannelHandler处理具体的请求消息，并根据具体的消息类型判断是否返回一个响应。类似地，响应消息传给客户端也是先经过Encoder编码，客户端先通过TransportFrameDecoder、Decoder解包消息，再通过TransportChannelHandler处理具体的响应消息。</p>
<h2 id="Handler定义"><a href="#Handler定义" class="headerlink" title="Handler定义"></a>Handler定义</h2><p>一个message从被发送到被接收需要经过”MessageEncoder → TransportLayer → TransportFrameDecoder → MessageDecoder → TransportChannelHandler”，下面按照这一过程详细阐述各handler的作用。</p>
<p>一个message进入网络前，需要经过MessageEncoder编码，加上包头信息，以便后续收包时正确粘包拆包。头信息主要是包括三部分：</p>
<ul>
<li>帧长度</li>
<li>消息类型</li>
<li>除消息体外的消息元数据，例如RpcRequest消息的元数据信息包括requestId和消息长度body size。</li>
</ul>
<p><img src="/images/spark-network-messagewithheader.png" alt=""></p>
<p>经过上述编码后，一个个Message被编码成一个个MessageWithHeader发送到网络中，接收端收到数据后，首先通过TransportFrameDecoder和MessageDecoder来解码出一个个具体的Message，这里就涉及到粘包拆包问题，这也是为什么在编码阶段在头部加上frame length的原因。</p>
<p>TransportFrameDecoder在解码过程中，首先读取8字节的frame length(Long型)，用frame length减去8就是除frame length外其他部分的长度，即为message type、message meta、message body三部分的长度，循环读取直到这个长度，把读到的Bytebuf交给MessagerDecoder。</p>
<p>MessagerDecoder首先解析出message type，根据message type去反序列化(实例化)出具体的Message，例如message type如果是RpcRequest，那么则继续解析requestId和body size，根据body size解析后续字节得到body，并构造出RpcRequest对象。反序列化得到的message对象会交给TransportChannelHandler。</p>
<p>TransportChannelHandler里封装了TransportRequestHandler和TransportResponseHandler，分别处理RequestMessage和ResponseMessage，在服务端，TransportChannelHandler一般处理RequestMessage，在客户端，TransportChannelHandler一般处理ResponseMessage。</p>
<p><img src="/images/spark-network-handler.png" alt=""></p>
<h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><h3 id="RPC消息处理"><a href="#RPC消息处理" class="headerlink" title="RPC消息处理"></a>RPC消息处理</h3><p>客户端发送一个RPC请求消息(RpcRequest或OneWayMessage)，经过编码到网络，解码到服务端的TransportChannelHandler，RPC请求会被交给TransportRequestHandler处理，而TransportRequestHandler中包括了一个RpcHandler专门用来处理RPC请求消息，RpcHandler中有两个关键receive接口，带callback和不带callback参数分别处理RpcRequest和OneWayMessage。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public abstract class RpcHandler &#123;</div><div class="line"></div><div class="line">    public abstract void receive(</div><div class="line">        TransportClient client,</div><div class="line">        ByteBuffer message,</div><div class="line">        RpcResponseCallback callback</div><div class="line">    );</div><div class="line"></div><div class="line">    public void receive(TransportClient client, ByteBuffer message) &#123;</div><div class="line">        receive(client, message, ONE_WAY_CALLBACK);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当收到RpcRequest时，处理后会在callback中发送响应消息，成功则发送RpcResponse，失败则发送RpcFailure。当收到OneWayMessage时，处理后不发送反馈。</p>
<p>类似地，服务端发送RPC响应消息(RpcResponse或RpcFailure)，也经过编码到网络，解码到客户端的TransportChannelHandler，RPC响应会被交给TransportResponseHandler处理，在客户端发送RpcRequest的时候，会注册一个RpcResponseCallback，通过requestId来标识，这样在收到响应消息的时候，根据响应消息中的requestId就可以取出对应的RpcResponseCallback对响应消息进行处理。</p>
<h3 id="ChunkFetch消息处理"><a href="#ChunkFetch消息处理" class="headerlink" title="ChunkFetch消息处理"></a>ChunkFetch消息处理</h3><p>对于ChunkFetch请求，客户端一般需要首先发送一个RPC请求，告诉服务端需要拉取哪些数据，服务端收到这个RPC请求后，会为客户端准备好需要的数据。RPC请求会通过RpcHandler来处理，当RpcHandler接收到ChunkFetch的RPC请求消息时，则会为客户端准备好它需要的数据，这些即将要被fetch的数据是通过一个StreamManager来管理的，所以RpcHandler中有一个接口专门获取StreamManager，StreamManager为后续到来的ChunkFetchRequest服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public abstract class RpcHandler &#123;</div><div class="line">     ...</div><div class="line"></div><div class="line">     public abstract StreamManager getStreamManager();</div><div class="line"></div><div class="line">     ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RPC请求成功后，服务端表示数据准备好，客户端发送ChunkFetchRequest消息，服务端收到该消息后，最后会交给TransportRequestHandler处理，TransportRequestHandler则根据请求消息中的StreamChunkId，从前面准备好的StreamManager中拿到对应的数据，封装成ChunkFetchSuccess返回给客户端，如果出错或找不到对应的数据，则返回ChunkFetchFailure。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public abstract class StreamManager &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    public abstract ManagedBuffer getChunk(long streamId, int chunkIndex);</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>响应消息到达客户端后，最后会被交给TransportResponseHandler处理，在客户端发送ChunkFetchRequest的时候，会注册一个ChunkReceivedCallback，通过StreamChunkId来标识，这样在收到响应消息的时候，根据响应消息中的StreamChunkId就可以取出对应的ChunkReceivedCallback对响应消息进行处理。</p>
<h3 id="Stream消息处理"><a href="#Stream消息处理" class="headerlink" title="Stream消息处理"></a>Stream消息处理</h3><p>Stream类似于ChunkFetch，主要用于文件服务。客户端一般也需要首先发送一个RPC请求，告诉服务端需要打开一个stream，服务端收到这个RPC请求后，会为客户端打开所需的文件流。</p>
<p>RPC请求成功后，服务端表示数据准备好，客户端发送StreamRequest消息，服务端收到该消息后，最后会交给TransportRequestHandler处理，TransportRequestHandler则根据请求消息中的streamId，从准备好的StreamManager中打开对应的文件流，同时返回StreamResponse给客户端，如果出错或找不到对应的流，则返回ChunkFetchFailure。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public abstract class StreamManager &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    public ManagedBuffer openStream(String streamId)；</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>响应消息到达客户端后，最后会被交给TransportResponseHandler处理，在客户端发送StreamRequest的时候，会注册一个StreamCallback，同时维护一个StreamCallback的队列，这样在收到响应消息的时候，就会从队列中取出StreamCallback去处理截获的数据。注意这里说的是截获的数据，这块有点不一样的是，收到响应消息后，会根据响应消息中数据大小，在TransportFrameDecoder对象中设置截获器Interceptor对象，TransportFrameDecoder在接收数据的时候会被这个截获器Interceptor截取它想要的数据。</p>
]]></content>
      
        <categories>
            
            <category> Hadoop/Spark </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[卓有成效的管理者]]></title>
      <url>http://lizonghang.github.io/2018/02/03/%E5%8D%93%E6%9C%89%E6%88%90%E6%95%88%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85/</url>
      <content type="html"><![CDATA[<h1 id="五项思想习惯"><a href="#五项思想习惯" class="headerlink" title="五项思想习惯"></a>五项思想习惯</h1><ol>
<li><strong>善用时间：</strong>有效的管理者应知道时间用在什么地方。他们可控的时间有限，通过有系统地工作来善用这有限的时间。</li>
<li><strong>重视成果：</strong>有效的管理者重视对外界的贡献。他们并非为工作而工作，而是为成果而工作。他们不会一接到工作就一头钻进去，更不会一开头就探究工作的技术和手段，他们会首先自问“别人期望我做出什么成果？”。</li>
<li><strong>取长避短：</strong>有效的管理者善于利用长处，包括自己的长处、上司的长处、同事的长处和下属的长处。他们还善于抓住有利的形势，做他们想做的事。他们不会把工作建立在自己的短处上，也绝不会去做自己做不了的事。</li>
<li><strong>要事第一：</strong>有效的管理者集中精力于少数重要的领域，在这少数重要的领域中，如果能有优秀的绩效就可以产生卓越的成果。他们会按照工作的轻重缓急设定优先次序，而且坚守优先次序。他们知道：要事第一。重要的事先做，不重要的事放一放，否则可能会一事无成。</li>
<li><strong>谨慎决策：</strong>有效的管理者必须善于做有效的决策。他们知道有效的决策事关处事的条例和秩序问题，也就是如何按正确的次序采取正确的步骤。他们知道一项有效的决策，总是在“不同意见讨论”的基础上做出的判断，它绝不会是“一致意见”的产物。他们知道快速的决策多为错误的决策，真正不可或缺的决策数量并不多，但一定是根本性的决策。他们需要的是正确的战略，而不是令人眼花缭乱的战术。</li>
</ol>
<h1 id="掌握自己的时间"><a href="#掌握自己的时间" class="headerlink" title="掌握自己的时间"></a>掌握自己的时间</h1><p>有效的管理者并不是一开始就着手工作，他们往往会从时间安排上着手。他们并不以计划为起点，认识清楚自己的时间用在什么地方才是起点。然后他们管理自己的时间，减少非生产性工作所占用的时间。最后，再将“可自由运用的时间”由零星集中成大块连续性的时段。这三个步骤是管理者有效性的基础：</p>
<ul>
<li>记录时间</li>
<li>管理时间</li>
<li>统一安排可自由支配的时间</li>
</ul>
<p>即时是只想获得最低程度的有效性，管理者的绝大部分任务也需要相当多的整块时间。如果每一次所花的时间少于这个极限，事情就做不好，所花的时间就是浪费，再做就得从头开始。</p>
<blockquote>
<p>举例来说，写一份报告大概得花5~8小时才能完成初稿。如果说每次花15分钟，每天2次，一共做两星期，虽然总时间达到了7小时，但恐怕结果还是一张白纸。但如果能够关起门来，连续做五六个小时，一份相当不错的初稿就应该差不多了。有了这份初稿，他才能做零星的补充，才能逐句逐段地润色、修改和整理。科学工作也与此相似。起码需要5~12小时的整块时间，才能把仪器调整妥当，做成一次实验。如果中间被打断，恐怕就得重新开始。</p>
</blockquote>
<p>每一位知识工作者，尤其是每一位管理者，要想有效就必须能将时间做整块的运用。如果将时间分隔开来零星使用，纵然总时间相同，结果时间也肯定不够。尤其是与他人一起工作时，这一点更为重要。与他人只接触三两分钟，是决不会产生什么结果的。要想与他人做有效的沟通，总得花上足够的时间。</p>
<blockquote>
<p>一位经理人员如果以为他与下属讨论一项计划、一项方针，或是一项工作表现，只需15分钟就够了，那他一定是自欺欺人。如果真想影响别人，那至少需要一个小时以上。如果想和别人建立良好的人际关系，就需要更多的时间。</p>
</blockquote>
<p>知识工作者只能自己制定工作方向，所以他必须了解别人期望他做出的贡献是什么，原因是什么，对必须使用其知识成果的人的工作情况，他也要有足够的了解。因此，知识工作者需要资料，需要讨论，还需要指导他人，这都是极为费时的。而且，他不但需要占用他上级的时间，也同样需要占用他周围同事的时间。</p>
<p>人际关系和工作关系的协调很费时间，然而任何组织都少不了这种协调。人数越多，协调相互关系所需的时间越长，而真正用于工作的时间便相对地减少了。身为管理者，也因此更应该知道自己的时间用在什么地方，并且妥善运用剩下来可自由支配的少量时间。同时，组织的人数越多，有关人事的决策也肯定越多。对人事的问题决定得太快，很容易铸成错误。人事决策往往需要大量的时间，因为决策所涉及到的一些问题，只有在反复考虑多次之后才能看清楚。</p>
<h2 id="实时的记录时间"><a href="#实时的记录时间" class="headerlink" title="实时的记录时间"></a>实时的记录时间</h2><p>要了解时间是怎样耗用的，从而据以管理时间，我们必须先记录时间。</p>
<blockquote>
<p>许多管理者都备有一本小册子记录时间，也有人请秘书代为记录。重要的是，必须在处理某一工作的当时立即加以记录，而不能事后凭记忆补记。</p>
</blockquote>
<p>许多有效的管理者都经常保持这样一份时间记录，每月定期拿出来检讨。至少，有效的管理者往往以连续三四个星期为一个时段，每天记录，一年内记录两三个时段。有了时间耗用的记录样本，他们便能自行检讨了。半年之后，他们都会发现自己的时间耗用得很乱，浪费在种种无谓的小事上。经过练习，他们在时间的利用上必有进步。但是管理时间必须持之以恒，才能避免再回到浪费的状态上去。</p>
<h2 id="系统的时间管理"><a href="#系统的时间管理" class="headerlink" title="系统的时间管理"></a>系统的时间管理</h2><p>先要将非生产性和浪费时间的活动找出来，尽可能将这类活动从时间表上排除出去。要做到这一步，可以试问自己下列几个问题。</p>
<ol>
<li>“这件事如果不做，会有什么后果？”。”如果认为“不会有任何影响”，那么这件事便该立刻取消。</li>
<li>“时间记录上的哪些活动或事务可以由别人代为参加而又不影响效果？”</li>
<li>“我是否在浪费别人的时间？”。诚恳地问自己的下属：“我常做哪些浪费你的时间而又不产生效果的事情？”。</li>
</ol>
<blockquote>
<p>例1：一个天天有应酬的总经理，天天在做一些他觉得难以割舍的事，比如应邀演讲、参加宴会、担任委员和列席指导之类，不知占去多少时间，而这些工作他本身并不感兴趣。其实，对付这类事情，只要审度一下对于组织有无贡献，对于他本人有无贡献，对于对方的组织有无贡献，如果都没有，只要谢绝就可以了。这个总经理在经过一番检讨后，发现其中至少1/3的宴请根本没有参加的必要。甚至主人发来邀请，只不过是出于礼貌而已，并不真心希望他出席。而且还有1/3的宴会只要有公司的高级管理人员到场即可，并非每次都要他亲自参加不可。</p>
<p>例2：“授权”这个名词的意义应该是把可由别人做的事情交付给别人，这样才能做真正应由自己做的事。例如，研究所为了发布研究成果的新闻，得由主持该项目的高级研究员来撰写新闻稿。研究所里很多人都知道该项研究的经过，新闻稿如果由别人写，写出来一定文笔流畅、通俗易懂，而高级研究员只能写出一些高深的数学公式。总而言之，管理者所作的工作，确实有许许多多可由别人去做，而且也应该由别人去做。</p>
<p>例3：某一大企业机构的财务经理，深感会议浪费了太多时间。通常不管讨论的是什么，他都通知财务部各单位主管全体前来开会。其结果是会议每次都拖得很长。出席会议的每一位主管，为了表示自己对问题的关切，都得表示意见，而表示的意见却大多与问题无关，会议时间自然拖长了。直到有一次这位财务经理诚恳地问了大家，才知道大家也都认为会议太浪费时间了。可是，他又想到：每一个人在组织中都至为重要，都应该了解情况，开会时如果少几个人，他又担心会使未被邀请的人觉得他们被忽视。现在这位财务经理终于找到一个两全的办法了。开会前，他先普遍分发一份开会通知：“兹订于周三下午3时，于四楼会议室，邀请赵钱孙李四位开会讨论下年度资本预算问题。如哪些需了解这个问题或愿参与讨论，亦请届时出席。如果无法出席，我们将于会后呈送记录，供各位参考并希望提供宝贵意见。”过去每次会议都要12人参加，花费整个下午，而现在只要4人出席，一小时就可以结束，并且没有一个人有被忽视的感觉。</p>
</blockquote>
<p>许多管理者都意识到了哪些事情会浪费他们的时间，然而他们却不敢面对这个问题。他们怕因小失大，造成错误。事实上，一位管理者大刀阔斧减少不必要的工作，绝对无损于有效性。能够大量削减不必要的和非生产性的工作，则工作就进行得快得多了。</p>
<blockquote>
<p>第二次世界大战期间，罗斯福总统的机要顾问霍普金斯先生当时已体衰力竭，每隔一天才能办公几小时。因此，他不能不把一切事务撇开，仅处理真正重要的工作。但这丝毫无损于他的有效性。他完成的工作，当年美国政府无人能出其右。</p>
</blockquote>
<p>时间浪费有时也是由于管理不善和机构有缺陷引起的，身为主管者也应予以同等的重视。管理不善不仅会浪费大家的时间，更重要的是会浪费主管自己的时间。所以，我们要清除浪费时间的活动。</p>
<p>1.找出由于缺乏制度或远见而产生时间浪费的因素。现象是机构中一而再再而三出现同样的“危机”。这类危机可以预先防止，或可设计成一种例行作业，即专家们从过去的危机中学会的一套有系统和有步骤的处理方式。</p>
<p>2.人员过多造成时间浪费。人员太多，以至于很多时间花费在协调人员之间的关系，而没有花在工作上。</p>
<p>判断人数是否过多有一个靠得住的标准，如果一个高级管理人员，尤其是经理，不得不将他工作时间的1/10花在处理“人际关系问题”上，花在处理纠纷和摩擦上，花在处理争执和合作等等问题上，那么这个单位就嫌人数过多了。人数过多，难免彼此侵犯，也难免成为绩效的阻碍。在精干的组织里，人的活动空间较大，不至于互相冲突，工作时也不用每次都向别人说明。</p>
<p>多用几个人，总是以“有此需要”为借口。“我们实在少不了一位热力学专家，少不了一位专利法律顾问，少不了一位学经济的人才。”但在增加了一位专家后，实在不大用得上他，也许根本用不上他。然而任用理由很多，例如：“养兵千日，用在一时”呀，“他总得熟悉我们的业务”呀，“总得一开始和我们共处”呀，用一个人，应该是每天的工作都需要用他。偶尔才有需要的专家，必要时才需要向他请教的专家，就不该正式聘用。要知道在有问题时花顾问费向他请教，远比正式聘用便宜得多。何况把这样的专家留在组织里，对整个团体的有效性肯定有不良的影响，用了他反而将成为组织的祸害。</p>
<p>3.组织不健全，其表现就是会议太多。</p>
<p>会议应该是不得已的例外，不能视为常规。一个人人都随时开会的组织，必是一个谁都不能做事的组织。原则上，一位管理者的时间绝不能让开会占用太多。会议太多，表示职位结构不当，也表示单位设置不当。会议太多，表示本应由一个职位或一个单位做的工作，分散到几个职位或几个单位去了。同时表示职责混乱，以及未能将信息传送给需要信息的人员。</p>
<p>4.信息功能不健全或信息的表达方式不当。</p>
<blockquote>
<p>例1：某一医院的院长，多年来一直为应付院内医生们的电话而苦恼。医生们打电话给他，要求他为病人安排一个床位。住院部都说是没有床位了，但这位院长几乎每次都可以找到空床位。原因是在病人出院时，住院部不能立刻接到通知。当然，有没有床位，各病房的护士长随时都清楚，主办出院结账手续的出纳台也能随时知道。住院部的人是在每天清早5点办理“床位调查”工作，而通常病人大多是在上午医生查房后才办出院手续。其实像这样的问题，只要各病房护士长在填写出院通知单给出纳台时，多填一份副本送住院部就解决了。</p>
<p>例2：制造部门常遭遇的一项困扰，是生产数字无法直接供生产作业部门使用。例如产量，报表中往往只列出会计部门所需的“平均产量”。可是直接作业人员需要的却不是平均数字，而是范围和大小，包括产品的组合、产量的变动和每批生产的时间等等。所以，他们需要这类资料时，不是每天都得花费几小时来推算，就只有在本单位内设置一个自己的秘密统计组了。当然这种资料在会计部门一定都有的，可是通常谁也不想去告诉会计部门，说自己需要的是怎样的信息。</p>
</blockquote>
<h2 id="统一安排可自由支配的时间"><a href="#统一安排可自由支配的时间" class="headerlink" title="统一安排可自由支配的时间"></a>统一安排可自由支配的时间</h2><p>管理者在做过了时间记录和分析后，就了解了有多少时间可以自由支配，又有多少时间可以用在确有贡献的大事上。但一个管理者无论删掉了多少浪费时间的活动，其自由时间仍不会太多。如果时间分割成零星的很多段，等于没有时间。因此，有效的管理者知道他必须集中他的自由时间。</p>
<p>对于如何集中自由时间，各人有各人的办法。有些高层人员在一星期内留一天在家工作。许多杂志主编和主持研究的科学家，就常采用此法。还有人将会议、审核、问题分析等例行工作，规定排在一星期内的两天中办理，而将其他日子的整个上午保留下来，用于处理真正重大的事务。还有人每天排定一段时间在家办公。</p>
<blockquote>
<p>某银行总裁，召开业务会议、约请高级职员讨论和接待重要客户之类的工作，都排在星期一和星期五。星期二、三、四的下午，则不排固定的工作，用来处理其它事务，例如研究突发的人事问题、约见回国的国外分行经理、接待重要客户，或前往华盛顿出差之类。但是在这三天的上午，他会事先排定时间表来处理重要事项，并以90分钟为一个单元。</p>
</blockquote>
<p>集中时间的方法在其次，真正重要的是时间如何用。许多人把次要的工作集中起来办理，因而匀出一段整块时间来。但这样的方法并无多大作用，因为几天或几星期后，他已经集中的自由时间又会被新的问题、新的紧急事件、新的麻烦瓜分得无影无踪了。</p>
<p>有效的管理者第一步应先估计究竟有多少自由时间真正是他自己的时间，然后保留出相当分量的一段连续性的整块时间来。一旦发现还有别的事情在“蚕食”他保留的时间，便立刻再仔细分析他的时间记录，再将其中比较次要的工作重新过滤一次。</p>
<p>一切卓有成效的管理者都懂得：对时间的控制与管理不能一劳永逸。他们要持续不断地做时间记录，定期对这些记录进行分析，还必须根据自己可以支配的时间的多少，给一些重要的活动定下必须完成的期限。</p>
<blockquote>
<p>有一位极有成效的主管，身边经常带着两张这样的完成期限表。一张是有关紧急事件的，一张是做起来自己并无兴趣但却非做不可的。每次在发现完成时间比预定期限落后时，他就警觉到可支配时间已经有溜走的迹象了。</p>
</blockquote>
<h1 id="我能贡献什么"><a href="#我能贡献什么" class="headerlink" title="我能贡献什么"></a>我能贡献什么</h1><p>重视贡献是有效性的关键。所谓有效性，表现在以下三个方面：</p>
<ol>
<li>自己的工作，包括工作内容、工作水准及其影响；</li>
<li>自己与他人的关系，包括对上司、对同事和对下属；</li>
<li>各项管理手段的运用，例如会议或报告等。</li>
</ol>
<p>可是大多数管理者重视勤奋，而忽略成果。他们耿耿于怀的是：所服务的组织和上司是否亏待了他们，是否该为他们做些什么。他们抱怨自己没有职权，结果是做事没有效果。一个人如果只知道埋头苦干，如果老是强调自己的职权，不论其职位有多高，也只能算是别人的“下属”。然而一个重视贡献的人，一个注意对成果负责的人，即时他位卑职小，也算是“高层管理人员”，因为他能对整个机构的经营绩效负责。</p>
<h2 id="管理者的贡献"><a href="#管理者的贡献" class="headerlink" title="管理者的贡献"></a>管理者的贡献</h2><p>重视贡献，才能使管理者的注意力不为其本身的专长所限，不为其本身的技术所限，不为其本身所属的部门所限，才能看到整体的绩效，同时也才能使他更加重视外部世界。只有外部世界才是产生成果的地方。因此，他会考虑自己的技能、专长、作用，以及所属单位与整个组织及组织目标的关系。只有这样，他才会凡事都想到顾客、服务对象和病人。事实上一个组织之所以存在，不论其产品是商品、是政府的服务，还是健康医疗服务，最终目的总是为了顾客、为了服务对象，或为了病人。因此，重视贡献的人，其所作所为可能与其他人截然不同。</p>
<blockquote>
<p>美国某一颇具规模的公立科学研究所，该研究所的出版部主任退休了，这位主任本身既不是科学家，也不擅长笔墨，因此，他主持出版的各种书刊常受到批评，说是缺乏学术水准。后来改由一位科学家来继任，从此该所出版的书刊面貌为之一新，具有高度学术水准了。然而，一向阅读该所书刊的科学团体却从此停止订阅了。一位教授发现了原因：“你们前任出版部主任，出版的书刊都是‘为’我们而写的，而现在的新主人，却把我们当成了写的对象。”</p>
<p>前任主任常自问：“我能为本所贡献些什么？”，他认为：“我应该引发外界年轻科学家对本所研究工作的兴趣，吸引他们来参加本所的工作”。因此，他特别强调研究所内的重大事件、重大决策，甚至于内部的争执。这样的做法屡次引起所长的不满，而且造成了正面冲突，然而他始终坚持这一原则。他说：“我们出版品是否成功，不在于‘我们’爱不爱看，而在于有多少年轻而素质良好的科学家，因读过我们的书刊而愿意前来应征工作。”</p>
</blockquote>
<p>一般机构对成效的要求往往表现在三个方面，管理者若想做点贡献，就必须在这三个方面下功夫：</p>
<p>1.直接成果</p>
<p>直接成果通常最显而易见，也是最重要的。在企业机构，销售和利润就是直接成果；在医院，对病人的护理和治疗就是直接成果。然而，如果连管理者自己都弄不清楚应有什么直接成果，那就别想有任何成果了。</p>
<blockquote>
<p>以英国的国营航空公司为例来说明。政府将这些航空公司作为企业来管理，同时又认为它们是执行国家政策和维护英联邦团结的工具。然而，它们实际上又一直是英国航空工业生存与发展的资金来源。三种不同的直接成果混淆在一起，结果是哪一种成果都没有得到。</p>
</blockquote>
<p>2.树立新的价值观及对这些价值观的重新确认；</p>
<p>一个组织必须有自己的主张和想法，否则就难免解体、混乱和瘫痪。以一个企业机构来说，其价值观的承诺也许是指建立技术权威，也许是指为社会大众寻求最好的商品和服务，并以最低的价格和最高的质量来供应。</p>
<p>3.培养与开发明天所需要的人才。</p>
<p>人都免不了一死，纵然他有再大的贡献，其贡献也因此有一定的限度。而一个组织正是克服这种限度的工具。一个组织必须今天准备明天的接班人，其人力资源必须更新，必须经常提高水准。下一代的人是站在他们前辈的肩头，再开创新的高峰，并在此基础上为他们的下一代准备更高的基准线。一个组织如果仅能维持今天的视野、今天的优点和今天的成就，它就一定会丧失适应力，并且在变幻无常的明天难以生存下去。</p>
<p>一位管理者能重视贡献，是人才发展最大的动力，因为人可以随外加的要求调整自己。重视贡献的管理者还可以帮助那些与他共事的人将眼光放得更远，这样也就提高了他们的工作水准。</p>
<blockquote>
<p>某医院新任院长在召开第一次院务会议时，以为一件棘手的事情经过讨论，已经获得可以使大家都满意的解决办法了。但这时有人提出：“这办法能使白莉安护士满意吗？”，这个问题一提出，会议中又掀起了热烈的辩论，直到另一个更为积极的解决办法研究出来。</p>
<p>后来新任院长才知道，白莉安曾是该院一位资深护士。她并没有什么特殊才能，但是每次院中有关病人护理的事情要决定时，白莉安小姐都要问：“我们对病人是否已尽了最大努力？”。凡是白小姐主管的病房中的病人，都痊愈得特别快。因此，多年以来，这家医院人人都知道了所谓“白莉安原则”，即凡事都必须先自问：“为贯彻本院的宗旨，我们真是做出了最大的贡献吗？”。</p>
<p>虽然白莉安小姐早在十年前退休了，但她所制定的标准却一直流传至今，为院中上下所信守。</p>
</blockquote>
<p>管理者的失败因素很多。常见的原因应该是他本人在出任一项新的职位时，不能或不愿为适应新职位的需要而改变。自以为过去做得成功了，因此满足于自己老一套的工作方法，结果必然遭到失败。职位有了改变，他所贡献的成果也一定改变，而且新职位所要求的上述三种绩效之间的相对比重也会改变。管理者如果不明白这层道理，仍然墨守他过去的处事方式，即时他过去是以对的方法做对的事情，现在也必将是“以错的方法做错的事情”。</p>
<h2 id="使专业人员的工作卓有成效"><a href="#使专业人员的工作卓有成效" class="headerlink" title="使专业人员的工作卓有成效"></a>使专业人员的工作卓有成效</h2><p>知识工作者不生产实物，他生产的是构想、信息和观念。知识工作者通常是一位专业人员。原则上，只有当他掌握了某种专门知识后，他的工作才能卓有成效。也就是说，他必须有所专长。但是，所谓专长，本身就是片面的、孤立的。一个专业人员的产出必须与其他人的产出结合在一起，才能产生成果。</p>
<p>但这意思并不是说专业人员应变成“通才”，而是说专业人员必须使他本人有效，必须使他的专长有效。他必须考虑到他的产出供什么人使用，也必须了解用户应该知道些什么才能有效使用他的产出，从而产生成果。</p>
<blockquote>
<p>今天有一种普遍的论调，说我们的社会可以分为“科学家”和“门外汉”两类，因此希望门外汉都应该多少具备一点科学家的常识，了解些科学术语及科学工具。殊不知我们的社会即使真能截然划分为两类人，那也是一个世纪以前的社会。事实上，在现代组织中，可以说每一个人都是专业人员，各有其专精的知识、工具、观念和术语。而现在科学的门类也越分越细，同是物理学家，可能互相不懂工作内容。</p>
<p>生物化学家固然是科学家，成本会计师又何尝不是。每个人都各有其专业领域和理想，各有其概念，各有其语言。同样地，市场研究人员、计算机编程人员，甚至政府机构的预算人员、医院的精神科医师，也都是科学家。这些人要想使自己的工作卓有成效，就必须先让别人能了解自己。</p>
</blockquote>
<p>这意思是说，知识分子有责任让别人了解自己。有些专业人员认为，普通人应该并且可以做出努力来理解他们，甚至认为他们只要能够和同行的少数专业人员沟通就够了，这真是傲慢的自大。即时是在大学或研究所，这样的态度也会使专业人员的工作变成无用，使专业人员的知识学问变成卖弄玄虚的手段。一个人如果想成为管理者，换句话说，如果愿以贡献为目标，就必须使自己的“产品”——即他的知识能为别人所用。</p>
<p>卓有成效的管理者总想了解别人需要什么、发现了什么以及能理解些什么。他们会向机构内部人员（包括他们的上司、下属，特别是其他部门的同事）提出这样的问题：“为便于你为机构作出贡献，你需要我做些什么贡献？需要我在什么时候，以哪种形式，用什么方式来提供这些贡献？”</p>
<blockquote>
<p>如果一位成本会计人员能问这样的问题，就会发现对他来说一目了然的数据，对需要这些数字的经理人来说却是完全陌生的东西。他也会发现，有些数字在他看来很重要，然而经营部门却用不上。他还可能发现，有不少资料是别人每天都需要的，但是他的报表中却没有。</p>
<p>制药工厂的生物化学家如果问了这样的问题，也会发现他的研究报告应该采用临床医师熟悉的语言，而不能采用生物化学的语言。生物化学家的研究是否能发展成为一种新药，是要经过临床试验才能决定的。</p>
<p>政务机构的科学家如果能重视贡献，也会懂得必须将科学发展的趋势及其可能的影响向政策决定人说明。他应打破科学家们的一般禁忌——即猜测一项科学调查的结果。</p>
</blockquote>
<p>所谓“通才”，应该也是一位专家，是一位能将其所专的一个小领域与其他广大知识领域联系的专家。有少数人也许可以精通几门知识，但这并不意味着他们便是通才，他们不过是精通几门知识的专家而已。一位专家只要能肩负贡献的责任，就一定能使他所专精的知识配合整体。他尽管不一定能将几门知识整合为一，但他一定知道应该了解别人的需要、别人的方向、别人的限度和别人的理解，以使别人能够应用他的成果。</p>
<h2 id="正确的人际关系"><a href="#正确的人际关系" class="headerlink" title="正确的人际关系"></a>正确的人际关系</h2><p>在一个组织中，自认为有管理天赋的管理者，往往并没有良好的人际关系。而在自己的工作上和人际关系上都比较重视贡献的管理者，往往都有良好的人际关系，他的工作也因此富有成效。有效的人际关系有下列四项基本要求：</p>
<ol>
<li>互相沟通</li>
<li>团队合作</li>
<li>自我发展</li>
<li>培养他人</li>
</ol>
<h3 id="互相沟通"><a href="#互相沟通" class="headerlink" title="互相沟通"></a>互相沟通</h3><p>如果我们一直把沟通当成是上对下的事，是主管对下属的事，仅靠上对下的单向关系，沟通永远不可能成功。上级对下属越想说得严厉，下属就越听不进去。下属要听的是自己想听的，而不是对方所说的。</p>
<p>一位在工作中以贡献为重的管理者，通常期望其下属也能以贡献为重。因此他肯定常常问他的下属：“我们的组织和我，应该期望你有怎样的贡献呢？我们该期望你做些什么？如果才能使你的知识和能力得到最大的发挥？”，有了这样的检讨，才有沟通的可能性，也才容易成功。</p>
<p>下属经过思考提出他认为可以做出的贡献之后，主管才有权利和责任对他所提出的建议是否可行做出判断。</p>
<blockquote>
<p>我们都有这样的经验：由下属自己设定的目标，往往会出乎主管的意料之外。换言之，主管和下属看问题的角度往往极不相同。下属越是能干，就越愿意自己承担责任，他们的所见所闻，所看到的客观现实、机会和需要，也越与他们的主管不同。下属的结论和主管的期望往往是明显对立的。</p>
</blockquote>
<p>出现这种分歧时，主管和下属双方究竟谁对，通常并不值得重视，因为上下双方已经建立了有效的沟通。</p>
<h3 id="团队合作"><a href="#团队合作" class="headerlink" title="团队合作"></a>团队合作</h3><p>强调贡献有助于横向的沟通，因此能够促成团队合作。“谁需要我的产出，并使它产生效益？”，这个问题能帮助我们看到与管理者责任范围无关的一些人的重要性。这种认识，正是一个知识型组织的现实：在一个知识型组织中，主要有赖于知识不同和技术不同的专业人员组成的团队，工作才能有效。各路英雄的合作，贵在自动自发，贵在能依循情势的逻辑和任务的需要，而非仅依赖正式的组织结构。</p>
<blockquote>
<p>例如在一所医院中（医院也许是最复杂的一种现代知识型组织），所有的护士、营养师、X光医师、药剂师、病理医师以及其他各方面的专家，都必须共同合作。他们面对同一位病人，但是谁也不觉得受了谁的管理和指挥。然而，他们必须为同一个共同目的而工作，而且必须符合总的行动计划，即主治医生的治疗处方。但是从组织结构的立场来说，他们各有各的上级主管。而在医疗工作上，他们各自尽其所长，以专家的身份各尽其责。同时，对一位病人的任何特殊情况及特殊需要，每一个人都必须相互告知。否则，他们的努力很可能只会适得其反。</p>
<p>在一个医院里，如果人人都已将重视贡献养成了一种近乎天性的习惯，则他们的配合和协作肯定不会有困难。反之，如果没有这种精神，则纵然有最完善的制度、有各式各样的委员会、有会议、有通告、有命令，也仍然不可能有这样的横向沟通，也不可能自然形成一个以正确的任务为中心的工作团队。</p>
</blockquote>
<p>今天的机构发生的组织问题，绝非传统的观念和理论所能解决。知识工作者必须专精于他的本行，必须对自己的能力和工作素质负责。从正式组织形态来看，他们“隶属”于某一专业职能部门——例如医院中的生物化学部、护理部等。从人事管理立场来看，他们的培训、档案、奖惩、升迁等等，也是由专业部门来管理的。但是他们在实际工作的时候，却必须是团队中的一位负责任的成员。他们的团队由全然不同领域的知识工作者组成，以当时承担的特定任务为中心。</p>
<p>当然，强调贡献并不一定必能解决组织问题，但至少能提高对任务和沟通的认识，而使一个尚未臻于理想的组织也能发挥实效。</p>
<blockquote>
<p>如何“沟通信息”一直是一个难以解决的问题。在过去，一切信息都靠人来处理和传送，故往往因沟通而失真。即信息在沟通过程中受到各人的看法、印象、意见、判断和偏见的影响。自从电脑问世以来，沟通过程不再带上各人的见解，所有的信息都变成纯信息了。在今天，我们的问题是如何建立最低限度的必要沟通，以使我们能相互了解，能认识彼此的需要、目标、感受和处事方式。而纯信息能告诉我们什么呢？唯有靠人与人之间的直接接触，通过语言或文字，才能达到沟通的目的。</p>
</blockquote>
<p>信息处理自动化程度越高，我们越需要去创造机会进行有效的沟通。</p>
<h3 id="自我发展"><a href="#自我发展" class="headerlink" title="自我发展"></a>自我发展</h3><p>自问：我对组织能有什么最大的贡献？这就等于是说：“我需要怎样的自我发展，我应该学习什么知识和技能，才有助于我对组织作出贡献？我应该将我的哪些优点用在我的工作上？我应为自己设定怎样的标准？”。</p>
<p>关于自我发展，我们可以断言：一般人都是根据自己设定的目标和要求成长起来的，知识工作者更是如此。他们自己认为应有怎样的成就，就会有怎样的成长。如果他们对自己的要求不严，就只能原地踏步，不会有任何发展。反之，如果对自己要求很高，他们就一定能成长为杰出的人物。</p>
<h3 id="培养他人"><a href="#培养他人" class="headerlink" title="培养他人"></a>培养他人</h3><p>重视贡献的管理者必然会同时启发他人寻求自我发展。这样的管理者设定的标准，一定不是他个人认定的标准，而是以任务需求为基础的标准。而且他设定的标准，一般来说要求很高，是高度的期望，是远大的目标，是具有重大冲击力的工作。</p>
<h2 id="有效的会议"><a href="#有效的会议" class="headerlink" title="有效的会议"></a>有效的会议</h2><p>管理者总不免要参加讨论会、协调会和简报会等各种会议。会议正是管理者每日使用的管理工具。当然，这些工作也占去了管理者的时间。即使最擅于分析其时间和管理时间的人，仍不免花费大量时间于会议和报告上。</p>
<p>卓有成效的管理者知道他们能从会议中得到什么，也知道会议的目的是什么。他会自问：“我们为什么要召开这次会议？是为了某项决策？是为了宣布什么？还是为了澄清我们应该做些什么？”，他会在事前想清楚会议目的，想清楚要求什么报告，以及想清楚简报的用意。他坚持开会必须真正有所贡献。</p>
<blockquote>
<p>有效的管理者在会议开始时，会先说明会议的目的和要求达成的贡献。同时，他还要设法让会议紧紧围绕着主题。他绝不会使会议成为一次摆龙门阵的机会，任大家随便发言。当然，如果会议的目的是激发大家的思想和创见，他也不会仅让某一个人滔滔不绝。他会刺激每一位与会人员的发言兴趣。但是在会议结束之前，他会回到开场所介绍的主题，使会议获得的结论与主题相符。</p>
</blockquote>
<p>还有其他一些使会议开得有效的办法。简单但是最易被人忽视的一条规则是：你可以主持会议，听取重要的发言，也可以是与大家共同讨论。但你不能既主持会议，又高谈阔论。</p>
<h1 id="如何发挥人的长处"><a href="#如何发挥人的长处" class="headerlink" title="如何发挥人的长处"></a>如何发挥人的长处</h1><p>有效的管理者能使人发挥其长处。他知道只抓住缺点和短处是干不成任何事的，为实现目标，必须用人所长——用其同事之所长、用其上级之所长和用其本身之所长。充分发挥人的长处才是组织存在的唯一目的。任何人都必定有很多缺点和短处，有些缺点和短处是短期难以改变的，但我们可以设法使其不发生作用。管理者的任务，就是要充分运用每一个人的长处，共同完成任务。</p>
<h2 id="要用人所长"><a href="#要用人所长" class="headerlink" title="要用人所长"></a>要用人所长</h2><p>管理者要运用人的长处，面临的第一关即在于择人。有效的管理者择人任事和升迁，都以一个人能做些什么为基础。所以，他的用人决策，不在于如何克服人的短处，而在于如何发挥人的长处。</p>
<blockquote>
<p>美国南北战争时，林肯总统任命格兰特将军为总司令。当时有人告诉他格兰特嗜酒贪杯，难当大任。林肯却说：“如果我知道他喜欢什么酒，我倒应该送他几桶，让大家共享。”林肯总统并不是不知道酗酒可能误事，但他更知道在北军诸将领中，只有格兰特能够运筹帷幄，决胜千里。后来的事实，证明了格兰特将军的受命正是南北战争的转折点。这也说明了林肯的用人政策是求其人能发挥所长，而不求其人是个“完人”。</p>
<p>林肯之所以懂得这些用人之道，也是经过了一番周折的。在这之前，他曾先后选用了三四位将领，选用标准都是他们必须无重大缺点。但结果是，虽然北军拥有人力物力的绝对优势，在1861年至1864年间却没有取得任何进展。反之，南方的李将军手下，从杰克逊起，几乎没有一位将领不是满身都是大小缺点。但李将军并不在意，因为他知道他所用的人，每一位都各有所长。而李将军正是善用他们的长处，使他们充分发挥。所以，在那段时期，林肯麾下每一位“无缺点”的将领都被李将军手下拥有“一技之长”的将领击败了。</p>
</blockquote>
<p>不管是谁，如果他在任用一个人时只想避免短处，那他所领导的组织最终必然是平平庸庸的。所谓“样样皆通”，实际上可能是一无是处。才干越高的人，其缺点也往往越多。有高峰必有深谷，谁也不可能是十项全能。与人类现有博大的知识、经验、能力的汇集总和相比，任何伟大的天才都不及格。世界上实在没有真正全能的人，最多只是有在某方面特别有能力的人。</p>
<p>一位管理者如果仅能见人之短而不能识人之长，因而刻意避其所短，而非着眼于发挥其所长，则这位管理者本身就是一位弱者。他会觉得别人的才干可能构成对他本身的威胁。有效的管理者知道他们之所以用人，是用人来做事，而不是用人来投主管之所好。有效的管理者从来不问：“他能跟我合得来吗？”，他们问的是：“他贡献了什么？”，他们从来不问：“他不能做什么？”，他们问的是：“他能做些什么？”。所以在用人时，他们用的都是在某一方面有所长的人，而不是在各方面都过得去的人。</p>
<p>重视一个人的长处，也就是要对他的工作绩效提出要求。如果管理者不在用人之前先问自己“他能做些什么”，那可以肯定他的下属绝难有贡献，这就等于他已经事先对下属的不称职采取了宽容的态度。真正“苛求的上司”（实际上懂得用人的上司大部分都是“苛求”的上司）总是先发掘一个人最擅长做什么，再来“苛求”他做些什么。</p>
<p>组织有特殊的手段，既可以使人的长处得到发挥，有可以使人的短处所带来的不利影响减少到最低程度。一位优秀的税务会计师，自行执业时可能因拙于待人而遇到挫折。但是在一个组织中，他可以自设一间办公室，不与其他人直接接触；一位小企业家精通财务，但可能因不懂产销而受困，而在较大规模的企业中，一位仅懂财务的人却可能极具生产性。</p>
<p>有效的管理者了解他自己的任务，在于如何使某人充分发挥其税务会计的才干，而不斤斤计较他不善于与人打交道。因此，他不会冒然指派这个人出任经理的职位。要与人打交道，完全可以找别人，而第一流的税务会计师更是不可多得的人才。所以，这个人能够做什么，才是组织器重他的原因。而他不能做什么，则仅是他的限制而已。</p>
<p>坚持“因事用人”而非“因人设事”。先有职位再物色人选来出任，往往会引人走入歧途，物色的对象，往往只是一位“仅合乎最低要求”的人选，其结果自然难免都是平平庸庸的人选了；但“因人设事”比原有的错误还糟，组织中任何一个职位的变更都会造成一连串的连锁反应，组织中的职位都是相互联系、相互依存的，牵一发而动全身，我们不能为了替某人安插一个职位，而使组织中的每一个人都受到牵连。此外，因人设事必将产生恩怨派系，组织绝对不能出现这种情况，人事的决策要凭公平和公正，否则就会赶走好人或破坏了好人的干劲。</p>
<blockquote>
<p>但有时确实有因人设事的必要。以斯隆先生为例，他一向不主张因人设事，但当他面对凯特林这位天才发明家时，他忍不住为其设置了一个工程技术部门，这就是通用汽车公司早期的工程建设部。罗斯福总统当年任用体衰力竭的霍普金斯，也打破了各种常规。不过，这种例外总是极为罕见的，它只适用于有特殊的才能，从事非同一般的工作，并取得杰出成就的人。</p>
</blockquote>
<p>那么，卓有成效的管理者究竟应该怎样用人，才不致陷入因人设事的陷阱呢？大致来说有四个原则：</p>
<p>1.卓有成效的管理者不会将职位设计成“常人”不可能胜任的职位。一个职位，如果先后由三人担任都失败了，就肯定是一个常人无法胜任的职位，这个职位就必须重新设计。</p>
<p>但是这样的职位却很常见。有些职位设定了，看起来非常合理，但却找不到合适的人选。为什么会有这样的职位呢？通常是因为先前有了一位非常人物，所以才按照这一人物的特殊天分和气质定下了职位条件。然而哪里去找这样的人？一个人也许能有多方面的知识或技能，但气质难以改变。如果一个职位要求特殊气质的人才能胜任，便注定了是不可能胜任的职位。</p>
<blockquote>
<p>例1：在营销学科教书中，常说销售管理应包括广告和促销，应隶属于同一位营销主管。然而一些知名的消费品生产厂家的经验说明，设置一个总揽全部营销业务的职位，根本是行不通的。如果行得通，那么出任这一职位的人，一方面要有高度的第一线销售能力——如何有效推动“物”；一方面又要有高度的广告和促销能力——如何有效推动“人”。这就要求做这项工作的人有各种不同的性格特点。这样的人是很难找的。</p>
<p>例2：在今天的跨国大企业中，设置了专营国际业务的副总裁的职位。起初这一职位还能找到理想人选，但是等到国外分公司的产销业务成长到相当程度时，这个职位就成为坑人的职位了。要解决这个问题，应按产品类别来调整组织，或按市场的社会和经济背景来调整组织。例如：国际部副总裁不妨分设三位，分别管高度发达国家、发展中国家和不发达国家的业务。一些化学工业公司走的就是这条路。</p>
</blockquote>
<p>有效的管理者的第一项任务就是要将自己管辖下的职位都设计得合情合理。一旦发现某职位设计不当，就要重新设计，而不会去设法寻找天才来担任，他知道组织的好坏不是由天才来验证的。只有“让平凡人都能做出不平凡的事”的组织，才是好的组织。</p>
<p>2.职位的要求要严格，而涵盖要广。</p>
<p>对于初级的知识工作的职位，这一原则尤其适用。尽管一位新人的能力不高，但他出任一项职位后，应该使他能有发展的机会。一位知识工作者在初任某一职位时，其职位的标准，应能作为他日后发展的引导，应能成为他衡量自己、评估贡献的依据。知识工作者在尚未担任一项成熟的职位之前，通常没有表现才能的机会。在学校念书最多只能显示他将来的可能成就，而实际的成就只有在实际工作中才能表现。对一位知识工作者，其同事及其上级主管最需要了解的，便是他实际上究竟能做些什么。</p>
<p>知识工作者职位的设计，还应该能够使人及早发现自己是否适合该职位。测试知识工作者是否适合某一职位，只有靠实际的工作绩效才能印证。一个人在年轻时，要调动工作并不难，但是若某人在同一组织干了十年以上，再想动就难了，尤其是那些工作缺乏成效的人。所以一位年轻的知识工作者，应该趁早做自我检讨：“就我的能力来看，我在这个组织中担任这个工作，是不是最适合？”</p>
<p>但是，如果他初任的职位涵盖太小，工作太简单，同时这职位又正是不需要经验，不能考验他能做什么的，那么他根本就无法做这样的自我检讨了。</p>
<blockquote>
<p>每次对年轻的知识工作者进行调查，例如军队里的医生、研究机构的化学家、工厂中的会计人员和工程师，以及医院的护士等等。所有的调查几乎都得到同样的结论：凡是能充分发挥其长处，而且最受到挑战的人，他的工作肯定最起劲，也肯定最能有所成就。而对工作不满的人，大都是抱怨：“他们没有让我充分发挥所长！”。</p>
</blockquote>
<p>年轻的知识工作者的职位涵盖范围太窄，不足以向他的能力挑战，其结果不是他自请离职，便是很快地变成了“老油条”。我们常听到许多主管感慨地说：想不到满怀壮志的年轻人会一个接一个消沉下去。其实这只能怪这些主管，是他们自己冻结了年轻人的热情，他们将职位设计得涵盖范围太窄了。</p>
<p>3.卓有成效的管理者在用人时，会先考虑某人能做什么，而不是先考虑职位的要求是什么。换言之，有效的管理者在决定将某人安置于某职位之前，会先仔细考虑这个人的条件，对其有个正确的评价，而且他考虑时绝不会只局限于这个职位。</p>
<p>尽管每一个大型组织都有一套评估考核人才的程序，但事实上这套程序很少被真正采用。情况通常是这样的：年年考评，年年归档，而在真要做某项人事决策时，谁也不会专门为此去翻阅档案，人人都将考评表视为无用的废纸。此外还有面谈考评的制度：由主管与其下属面对面讨论。可是这种面谈考评也因主管感到难堪而没有真正实行过，然而面谈考评却正是整个考评制度的重心所在。</p>
<p>今天大多数组织制定的考评办法，其实是源于医生对病人的评估。而医生重视的是病人的毛病，而不是病人的优点。</p>
<blockquote>
<p>日本主持管理发展研讨会，参加人都是日本大企业的高层人员。当时日本没有考评制度，他们认为：“你们的考评制度，目的只是发现一个人的错误和弱点。而在日本，不能因为某人有缺点而把他开除或降级，于是自然对考评制度没有兴趣了。我们更想知道的是这个人有什么优点，他能做些什么。而你们的考评制度根本不重视这一点”。虽然日本终身雇用的办法并不是理想的，但其“见人之所长、用人之所长”的精神值得我们学习。</p>
</blockquote>
<p>如果一位主管专找下属的缺点——例如我们的考评制度，就必将破坏主管与下属之间的团结，甚至会造成双方无法合作，所以，管理者不运用考评制度是有理由的：考评制度是一种错误的工具，用错了地方，也弄错了目标。</p>
<p>有效的管理者通常有自己一套与众不同的考评方式。第一步列出对某人过去职务和现任职务所期望的贡献，再把某人的实际绩效记录与这项期望贡献相对照，然后检讨下面四个问题：</p>
<ol>
<li>哪方面的工作他确实做得很好？</li>
<li>哪方面的工作他可能会做得更好？</li>
<li>为了充分发挥他的长处，他还应该再学习或获得哪些知识？</li>
<li>我愿意让我的子女在他的指导下工作吗？理由是什么？</li>
</ol>
<p>第四点暗示了其个人品格，正直的品格本身不一定能成就什么，但一个人如果缺乏正直和诚实，则足以败事。有这种缺点的人没有资格做管理者。</p>
<p>4.卓有成效的管理者知道在用人之所长的同时，必须容忍人之所短。</p>
<blockquote>
<p>如果需要的是一位确能履险如夷、担当重任的人物，我们就必须接受像狄斯雷利或罗斯福那样的人物，而不必去介意他们的态度缺少谦恭。</p>
</blockquote>
<p>有效的管理者会问：“这个人在某方面是否确有长处？他的长处是否确为某一任务所需？这个人如果担当这项任务，是否确能表现得与众不同？”，如果答案为“是”，就不必犹豫，延用此人。</p>
<p>只有经得起绩效考验的人才是可以提升的人。对一个没有突出表现的人，尤其是一个没有突出表现的主管，应该无情的调职，这是管理者的责任。任他留下来，必将影响全体人员，而且对于整个组织也是不公平的。对他的下属则尤为不公平，因为主管无能，则不免剥夺了下属发挥其长处的机会。</p>
<blockquote>
<p>日本的终身雇用和西方国家的文官制度，都不主张撤换已被证实不胜任的人，这是个严重的错误，我们没有必要再犯这样的错误。</p>
<p>第二次世界大战时，马歇尔将军也曾说过：一位将军如果没有特优表现，就必须立即调职。但常有人说：“主管调职，我们找不出继任人选了”。而马歇尔将军表示：“我们重视的只是这位主管不能胜任工作，至于如何去物色继任人选，那是另一回事。”</p>
<p>但马歇尔将军还认为，将一位不称职人员调职，与其说是反映了对这个人的看法，倒不如说是对任命他的人有看法。他说：“某人不称职，只是不称于‘此’职，并不表示他不能胜任别的职务。所以，选派某人出任这个职务，是我的错误，我应该负责再给他找到适合的工作。”</p>
<p>马歇尔将军任命一个人出任某个新职，从来不考虑此人在原单位“如何重要，如何缺少不了”。他的答复都是：“调他出任新职，是工作的需要，是为了他本身，也是为了部队”。</p>
</blockquote>
<p>任何一项人事任命都是一个赌注，但是，只要能抓住某人的长处是什么，至少是合理的赌注。主管对下属的工作负有责任，也掌握了下属前途发展的权力。用人之所长，不仅是有效性的要素，也是主管对下属的道义责任，是主管对其与自己职位和地位的责任。专注于人之所短，不仅是愚不可及，更是有亏职守。用人之所长是卓有成效的管理者必须具备的一种素质，是一个组织工作是否有效的关键，也是知识工作者和社会不可或缺的素质。</p>
<h2 id="如何管理上司"><a href="#如何管理上司" class="headerlink" title="如何管理上司"></a>如何管理上司</h2><p>如果上级主管的能力不够，没有升迁，下属通常是无法爬升上去的。如果有一天上司因成绩不佳调职了，继任者也往往是来自别的部门，很少在本单位中选人提升。而且新上司到任时，也总是带来他自己的亲信。反之，凡是成功而升迁得快的主管，其下属也是最容易成功的。因此，运用上司的长处，也是下属工作卓有成效的关键。只有如此，身为下属者才能将精力集中在自身的贡献上，完成自己想做的工作，取得希望取得的成就。</p>
<p>要使上司能发挥其所长，不能靠惟命是从，应该从正确的事情着手，并以上司能够接受的方式向其提出建议。上司也是人，肯定有其长处，也有其短处。若能在上司的长处上下功夫，协助他做好想做的工作，便能使上司有效，下属也才能有效。反之，如果下属总强调上司的短处，那就像上司强调下属的短处一样，结果将一无所成。所以，有效的管理者常问：“我的上司究竟能做些什么？他曾有过什么成就？要使他发挥他的长处，他还需要知道些什么？他需要我完成什么？”，至于上司不能作些什么，那就不必细究了。</p>
<p>人大致可以分为两种类型：“读者型”和“听者型”（例外类型不考虑）。我们面对“读者型”的人侃侃而谈，那是徒费口舌，因为他只能在读过之后才能“听”得进去；我们面对听者型的人递送一册厚厚的报告书，那是徒费笔墨，因为他只能“听”了之后才能掌握要点。有人只能阅读浓缩为一页的报告；有人需要了解整个理论推演的过程，所以他要的是厚厚的报告全文或是大串数字；有人喜欢及早了解情况；有人非要等到研究成熟之后才愿意听你的报告。</p>
<p>要了解上司的长处并发挥其长处，需要了解上司属于哪种类型，即“如何提出建议”。向上司提出建议时，应考虑的不光是轻重是非，更重要的是陈述的先后顺序。如果上司长于政治能力，那么我们提出的报告就应以政治方面的问题居先，这样才能使上司易于掌握问题的重心，从而易于发挥其所长。</p>
<h2 id="充分发挥自己的长处"><a href="#充分发挥自己的长处" class="headerlink" title="充分发挥自己的长处"></a>充分发挥自己的长处</h2><p>有效的管理者都能了解自己的类型，配合自己的习惯而行动。</p>
<blockquote>
<p>我们知道自己是在上午还是在晚上最有精神；当自己撰拟一份文稿时，是习惯于先写好草稿再来修改，还是习惯于一字一句推敲后完成全文；当发表演说时，是先准备好全文讲稿，还是只准备一份纲要，或是无需准备就能讲得头头是道；自己是适宜参加一个工作小组，还是一个人单独做事更出色。</p>
<p>有人做事，需要先有一个详细的计划，经过周密的通盘思考之后才能动手。但也有人一开始就做，最多只要先拟订几个要点。有人做事要靠人催逼，有人凡事都心急。有人属于“读者型”，有人属于“听者型”。自己的工作能力和习惯自己最清楚。</p>
</blockquote>
<p>重要的是，有效的管理者会顺应自己的个性特点，不会勉强自己。他注意的是自己的绩效，自己的成果，从而发展出自己的工作方式来。他会问：“哪一类工作别人做起来要费九牛二虎之力，我做起来确是轻而易举？”。</p>
<blockquote>
<p>有人能够很快写出一份报告书，有人却觉得难之又难；有人觉得起草报告容易，但分析报告，并针对报告来做决策却十分困难。这样的人更适合担任幕僚，因为幕僚只需要将材料综合起来，把问题罗列出来，他不适合担任决策者。</p>
<p>有人适宜单独行动，从头到尾一手包办；有人擅长谈判，特别是进行情绪激烈的谈判，例如劳资合约之类的谈判。在这方面，往往需要预测劳方的对策，有人料事如神，有人却常判断错误。</p>
</blockquote>
<p>在讨论一个人的长处和短处时，人们很少考虑到上述这些情况。他们想到的通常只是针对一门学问的知识，或一种艺术才能。但是，人的性情却往往是事情成败的重大关键。我们要求有效，就要以了解自己能做些什么为基础，然后以最适合自己的方式做下去。</p>
<p>在一个组织中，有效性的每一面都是“机会的开发，问题的消失”。有效的管理者把每一个人都视为可以开发的机会，包括他本人在内。任何一个团体，其行事标准都取决于领导人的表现，所以，有效的管理者会把自己的表率作用建立在充分发挥所长上。</p>
<blockquote>
<p>运动场上每出现一个新纪录，这个新纪录必成为全世界的运动员努力的新标准。多年来，谁也没有打破4分钟跑1英里的记录。但后来罗杰·班尼斯特打破了记录。于是，世界上每个田径俱乐部里的一般运动员的成绩都接近了这个记录，而新的领头羊则纷纷突破这个记录。</p>
</blockquote>
<p>领导人和一般人之间总有一段差距。领导人的绩效高了，一般人也竞相争高。有效的管理者要找出有条件做出突出贡献，并能起带头作用的人才，赋予他们领导人的地位，把他们安置到能“制订标准”并能创造成绩的位置上。</p>
<h1 id="要事优先"><a href="#要事优先" class="headerlink" title="要事优先"></a>要事优先</h1><p>卓有成效如果有什么秘诀的话，那就是善于集中精力。卓有成效的管理者总是把重要的事情放在前面先做，而且一次只做好一件事，这就是加快工作速度的最佳方法。越能集中我们的时间、努力和资源，我们所能完成的工作也就越多。</p>
<blockquote>
<p>一位制药公司的总裁，他初上任时，公司规模极小，业务也仅限于国内。当他在职11年后退休时，该公司已成为世界性的大公司了。这位先生在职十多年，做出了三项重大决策，同时把公司发展成实力强大、人才雄厚的世界性企业。他之所以能取得如此成就，就是因为他能每次专心只做好一件事。</p>
</blockquote>
<p>有些人一事无成，而实际上他们却做得很吃力。第一，他们低估了完成一件任务所需的时间。他们总以为万事顺利，却总不免有出乎意料之外的情况发生。其实，意料之外就应该在我们的意料之中，有效的管理者对时间需求的估计宁可有余，而不可不足。第二，不有效的管理者总喜欢赶工，而赶工的结果总不免使进度更加落后。有效的管理者不愿赛跑，他们按部就班，稳定前进。第三，不有效的管理者喜欢同时着手几件要事，结果对每一件事，他们都无法获得足够的最低整块时间。只要任何一件事受阻，全部事情也都跟着受阻了。</p>
<p>有效的管理者知道他们必须要完成许多工作，但他们坚持把重要的事情放在前面先做，并且在一段时间内只集中努力做好一件事。</p>
<h2 id="摆脱昨天"><a href="#摆脱昨天" class="headerlink" title="摆脱昨天"></a>摆脱昨天</h2><p>管理者专心一志的第一项原则是要摆脱已经不再有价值的过去，但是管理者不可能完全摆脱过去，因为今天是昨天所做决策和所采取行动的结果，昨天的决策和行动，不论当时看起来如何睿智，都有可能形成今天的困难和危机，甚至被证明是愚蠢的行动。每一位管理者必须不停地花费时间、精力和才智，来弥补及跳出昨天的行动和决策。事实上他在这方面所耗的时间，应该比任何任务所耗的时间都多。</p>
<p>但是我们可以把昨天遗留下来的、不能再产生成果的工作尽量减少。</p>
<p>过去的成功和活动往往演变成“经营管理上的自我主义的资产”，并且是神圣不可侵犯的。但是，这些过去的成功和活动最需要无情的检讨，否则组织的血液都流失到这种自我之中了。而且这种“经营管理上的自我主义的资产”往往占用了组织中最能干的人才，却还说那是“值得的”。</p>
<blockquote>
<p>政府机构的计划和措施，如其他机构一样，过一段时间就会跟不上形势变化的需要。这些计划和措施不但被认为是永恒的原则，还会演变成法令规章，谁也动他不得，成为一部分人的既得利益，并且得到政府立法部门有关人员的支持。</p>
<p>今天的美国至少有半数的联邦政府机构，不是仍然拘泥于根本不必要的规章（例如“洲际商业委员会”最初成立的目的本在防止私营铁路的垄断，而铁路垄断的可能性在30年前就不存在了），就是把精力放在满足政治家的私愿上（绝大部分农业法案便属此类）。</p>
<p>约翰逊总统在1965年至1966年间，曾对政府的每一个机构及其计划做过一项研究。这项研究效仿国防部长麦克纳马拉的“计划检讨”制度：删除过时的和无效的计划。不过，如果我们仍旧抱着传统观念，认为一切计划如果无法证明其确属无效，就应继续存在，那么这项研究难以产生结果。我们应有的观念是：任何计划如果无法证明其确属有效及需要，便该立即放弃。</p>
</blockquote>
<p>自己的公司是否在进行种种研究，其实只是用来掩饰自己缺乏果断？自己的公司是否拥有各方面的人才，其实只是为了表示你们“有”各种研究和“有”各种关系？自己的公司是否沉湎于昨天的过时产品，浪费自己的主要智囊人物的时间，也扼杀了明天的产品？</p>
<p>一位希望自己有效，也希望其组织有效的管理者，必然会自我检视一切的方案、活动和任务。他会问：“这件事现在还有继续做的价值吗？”，如果认为没有价值了，他便立即停手，而将时间精力转移到其他只要做得好，便能使自己更为有效的任务上，也能促使他的组织更为成功。</p>
<p>尤其重要的是：有效的管理者打算做一项新的业务，一定先删除一项原有的业务。这对控制组织的“膨胀”是非常必要的。“膨胀”如不加以控制，组织就会变得涣散，难以管理。社会组织恰如生物有机体，必须保持小而精的状态。只要能够推陈出新，即使是最暮气沉沉的机构，也能获得生机。</p>
<h2 id="先后次序的考虑"><a href="#先后次序的考虑" class="headerlink" title="先后次序的考虑"></a>先后次序的考虑</h2><p>四条可帮助确定优先次序的原则：</p>
<ol>
<li>重将来而不重过去；</li>
<li>重视机会，不能只看到困难；</li>
<li>选择自己的方向，而不盲从；</li>
<li>目标要高，要有新意，不能只求安全和方便。</li>
</ol>
<p>优先与延缓的问题不是一成不变的，根据实际情况的变化，经常需要对这种先后次序进行重新考虑和修正。</p>
<p>一位有效的管理者，会把主要精力集中在当前正在进行的工作上，而不会再去兼办其他工作。完成一件事后，他会根据情况的变化，再决定下一步的优先事项。</p>
<h1 id="决策的要素"><a href="#决策的要素" class="headerlink" title="决策的要素"></a>决策的要素</h1><p>只有管理者才需要做决策。管理者之所以为管理者，正是由于他拥有特殊的地位和知识，所以人们期望他能做出对整个组织、绩效和成果具有特殊影响的决策。</p>
<p>卓有成效的管理员会做出有效的决策。他们的决策，是一套系统化的程序，有明确的要素和一定的步骤。有效的决策具有以下五点特征：</p>
<ol>
<li>要确实了解问题的性质，如果问题是经常性的，那就只能通过一项建立规则或原则的策略才能解决。</li>
<li>要确实找出解决问题时必须满足的界限。</li>
<li>仔细思考解决问题的正确方案是什么，以及这些方案必须满足哪些条件，然后再考虑必要的妥协、适应及让步事项，以期该决策能被接受。</li>
<li>决策方案要同时兼顾执行措施，让决策变成可以被贯彻的行动。</li>
<li>在执行的过程中重视反馈，以印证决策的正确性及有效性。</li>
</ol>
<h2 id="了解问题的性质"><a href="#了解问题的性质" class="headerlink" title="了解问题的性质"></a>了解问题的性质</h2><p>有效的决策人首先需要辨明问题的性质：是一再发生的经常性问题，还是偶然的例外？或某一问题是否为另一个一再发生的问题的原因？或是否确属特殊事件，需以特殊办法解决？若是经常性的问题，就应该建立原理原则来根治；而偶然发生的例外，则应该按情况做个别的处置。</p>
<p>按问题的发生情况一般可以分成四类：</p>
<p>第一类是真正经常性的问题。发生的个别问题只是一种表面现象。</p>
<blockquote>
<p>工厂中的生产管制及工程单位所处理的这类问题极多，然而分析起来，这类问题绝大部分只是一种表面现象，是一些反映基本情况的表面现象。但是，生产部门的工程师往往很难看透这一层。他们每个月都会碰到类似的问题，如输送蒸汽或流体的管子接头坏了。这样的问题，只有经过较长时间的分析之后，才能显示其为“经常”的性质。这时他们才能发现究竟是否由于问题或压力过高，超过设备的负荷，需将接头重新设计。但是在得到这一结论前，生产部门往往早已花了不少修理管子接头的时间了。</p>
</blockquote>
<p>第二类问题虽然是在某一特殊情况下偶然发生，但在实质上仍然是一项经常性问题。</p>
<blockquote>
<p>例如某公司接受另一公司的建议，两家合并为一。对这家公司来说，接受这种建议只能是一次性的，是一种特殊的问题。但这一问题却具有“经常”的性质，企业界随时可能出现这种问题，因此在考虑是否接受时，应以某些原则为基础，必须参考他人的经验。</p>
</blockquote>
<p>第三类问题是真正偶然的特殊事件。</p>
<blockquote>
<p>例如小行星撞地球、火山喷发之类，这一类事件发生的概率极小。</p>
</blockquote>
<p>第四类问题是首次出现的经常性事件。</p>
<p>真正偶然性的例外事件少之又少，但一旦发生时我们必须自问：这究竟是一次“真正偶发事件”还是另一种“经常事件”的首次出现？</p>
<blockquote>
<p>1965年11月间，美国的整个东北部地区，从圣劳伦斯到华盛顿一带发生了一次全面停电。又例如20世纪60年代初期，因孕妇服用“沙立度胺”而产生畸形婴儿。这些事件是“经常事件的首次出现”。</p>
</blockquote>
<p>除了第三类“真正偶发的特殊事件”之外，其余三类都需要一种“经常性的解决方法”。换言之，需要制订一种规则、一种政策或一种原则，问题再度发生时，就可根据原则去处理了。只有第三类事件才必须个别对付，没有原理原则可循。</p>
<p>有效的决策人常花费不少时间来确定问题的属性，如果类别判断出错，其决策必为错误的决策：</p>
<p>1.第一种常犯的错误，是误将“经常问题”视为一连串的“偶发问题”，没有了解问题症结所在的基础，其结果自然是失败与无效。<br>2.第二种常犯的错误，是误将真正的新问题视为旧病复发，因而仍旧应用旧原则。</p>
<blockquote>
<p>美国东北部的停电即为一例。当初的停电本来只限于纽约和加拿大安大略一带，后来范围越来越广，扩展到整个东北部。纽约市的电力工程师起初运用了只适用于正常负荷情况的“旧原则”来处理。后来他们经过详细检查，发现了非比寻常的现象，才知道不能用平常方法，而必须用非常方法来解决。</p>
</blockquote>
<p>3.第三种常犯的错误，是对某些根本性问题的界定似是而非。</p>
<blockquote>
<p>自从第二次世界大战结束以来，美国军方常感到他们留不住高素质的医务人员。军方曾屡次研究这一问题，提出了很多建议。但所有的研究工作都是以一项听来头头是道的假定为基础的——认为问题在于待遇不够，殊不知真正的原因在于军医的传统制度。美国的军医组织一向重视普通医师，然而今天的潮流已经是分科精细，重视专科医师了。照军方的系统，军医在人事晋升的阶梯上只能爬到行政方面去，最后导致与医学研究脱节。年轻一代的医务人员感到他们在军中服务的结果最后不是升官就是永远做普通医生，对于他们的所学所长不免是一种浪费。他们真正的需要是能有发展医学才干，成为一位专科医师的机会。</p>
</blockquote>
<p>4.最后一种错误是只看到问题的部分，而没有看清全貌。</p>
<blockquote>
<p>1966年，美国汽车工业忽然受到攻击。社会各界纷纷指责美国的汽车不安全，而业界本身竟一时惊惶失措。但是，事实上美国汽车业界不但重视车辆本身的安全，而且注意到公路工程和驾驶人员的训练。社会上说车辆肇祸的原因，一在于道路不良，一在于驾驶不慎，这种说法极为动听。凡是与车辆安全有关的机构，从公路警察到驾驶学校，都以安全第一为共同的目标。而且这项安全运动确实已收到了效果。重视行车安全的公路，车祸数字显然较少；受过安全训练的驾驶人员，其肇事事件也同样很少。但是，事实上的证据是：以每1000辆汽车或者以每行驶1000公里来计算的肇事比率，虽然一直不断下降，但车祸总数及车祸损害程度，仍在继续上升。</p>
<p>很久以来我们都知道，在所有肇事事件中，酒醉驾驶或极少数有“行车肇事倾向”的驾驶人员所引发的车祸，往往占车祸数的3/4左右；而这种车祸，确实不是驾驶学校所能负责，也不是公路不良所造成的。很久以来我们也知道，努力的重点，其实在于应针对那些非交通安全法规和训练所能控制的车祸。就是说，除了公路安全和驾驶训练以外，还得同时在技术方面设法，使得万一发生车祸，伤亡情况可以减轻。汽车制造业界应该做的，是在技术方面不但使车辆在“正常驾驶”下能确保安全，而且在“不正常驾驶”下也能够提高车辆的安全性。但美国汽车制造业界竟没有看到这一层。</p>
</blockquote>
<p>一位有效的决策者碰到问题，总是先假定该问题为“经常性质”。他总是先假定该问题是一种表面现象，另有根本性的问题存在。他要找出真正的问题，不会只满足于解决表面现象这类的问题。即使问题确实是偶发性的，有经验的决策者也会先怀疑这是不是另一项新的经常问题的首次出现。</p>
<p>有效的决策者所做的决策一般不会太多，但这并不是因为做一项原则性的大决策需要很长时间，而是他既然已经设计了一套规则和政策来解决经常事件，就可以运用有关的规则来解决绝大多数的问题。一位管理者如果天天要做决策，时时要做决策，那恰恰说明他是个疏懒和无效的人。</p>
<p>决策者也常常需要留意是否有非常事件出现。他一定经常自问：“这一解释能说明某些事件吗？能说明所有同类的事件吗？这个问题的解答，可能引发什么结果？”，最后当出现了别的非常事件时，当出现了他的解答所不能解释的事件时，或者当发生的结果与预期不符时，他又回过头来重新检讨原来的问题。</p>
<h2 id="了解解决问题的界限"><a href="#了解解决问题的界限" class="headerlink" title="了解解决问题的界限"></a>了解解决问题的界限</h2><p>决策的目标是什么？最低限度应该达成什么目的？应该满足什么“边界条件”？一项有效的决策必须符合边界条件，必须足以达成目的。</p>
<p>边界条件说明得越清楚和越精细，则据以做出的决策越有效，越能解决需解决的问题。反过来说，边界条件不够明确，则所做的决策不论看起来如何了不起，都肯定是一项无效的决策。</p>
<p>边界条件往往不容易找出来，每个人所看到的边界条件往往也不尽相同。我们对边界条件必须保持清醒的认识，这能提醒我们一项决策什么时候应该抛弃。这里我们举出两个实例说明，第一个是边界条件含糊不清的决策，第二个是边界条件清晰明确，因而决策人能够立即以新决策来取代不合时宜的决策。</p>
<blockquote>
<p>第一个实例，是关于第一次世界大战时德军参谋本部所做的“舒利芬计划”。所谓舒利芬计划，是德军在东西两面同时作战的战略。根据这一计划的构想，德军对付俄军，只需用小部分兵力来牵制，因为当时俄军力量较弱；但对付法军则要全力作战，期望以闪电战一举歼灭法军，然后再转而对付俄军。按照这一计划，自然在作战初期，德军要让俄军深入德境，等到对法之战获胜之后，再开始对俄军反攻。不料事出意外，俄军侵入德境的速度太快，在1914年8月间，东普鲁士已全面告急了。</p>
<p>当初舒利芬将军拟订作战计划时胸有成竹，一切边界条件都十分明确。然而他的继任将领，不幸只擅长作战而拙于决策和战略。所以，德军后来竟抛弃了舒利芬计划中最基本的原则：德国的军力应集中而不应分散。按理来说，德军可以将舒利芬计划完全抛弃。然而他们却固执于原计划，遂使原定目标不可能达成。其结果是，德军在西边的兵力调走了，使对法之战的胜利无法贯彻到底;而在东边的兵力，又不足以对抗俄军。终于造成舒利芬计划中，原欲竭力避免的一种“僵持战局”产生了。僵持战局只是兵力的消耗，靠人力才能取胜，而不是靠优秀的战略来取胜。所以，从此以后，德军的作战完全走了样，只能靠随机应变，靠鼓励士气和靠奇迹，而不是靠最初所订的战略了。</p>
<p> 现在再举第二个例子，是1933年罗斯福总统的故事。罗斯福总统当初在竞选活动中提出的口号是“经济复兴”。他拟订了一套经济复兴计划，原是以1933年时美国财政的保守政策和预算平衡为基础。可是不巧在罗斯福总统接任之前，美国的经济几乎整个要垮了。当然，发生了这种变化，罗斯福的经济政策也许在经济上仍然可以行得通，但是在政治上明显地是很难搞下去了。</p>
<p>于是，罗斯福立刻另提了一项政治目标，来代替当初的经济目标。他原先计划的是“复兴”，现在马上转变为“改造”。新计划要求有政治上的动力，因此，起初以保守为基础的经济政策，现在一变而成为激烈的革新政策了。边界条件变了，罗斯福总统真是反应敏锐, 不愧是一位伟大的决策者，能断然放弃原定计划，以保证施政的有效。</p>
</blockquote>
<p>在各种不同的可能决策中要识别出哪项决策最危险（所谓最危险的决策，就是勉强可行的决策，唯有在一切顺利的情况下，才可能达成的决策），也必须了解边界条件。每一项决策都有意义，但是当我们进一步探究必须满足的规范时，便可能发现各项规范有互相冲突的情况。这样的决策纵然不能说是不可能成功的，最多也只是可能成功而已。若成功需寄望于奇迹，则问题不是奇迹出现的机会太小，而是我们不能依赖奇迹。</p>
<h2 id="研究“正确”的决策是什么"><a href="#研究“正确”的决策是什么" class="headerlink" title="研究“正确”的决策是什么"></a>研究“正确”的决策是什么</h2><p>决策的第三个要素，是研究“正确”的决策是什么，而不是研究“能为人接受”的决策是什么。人总有采取折中办法的倾向，如果我们不知道符合规范及边界条件的“正确”决策是什么，就无法辨别正确的折中和错误的折中之间的区别，最终不免走到错误的折中的方向去。</p>
<p>所谓“折中”，实际上有两种。第一种“折中”，即俗语所谓“半片面包总比没有面包好”。第二种“折中”，则可用古代所罗门王审判两位妇人争夺婴儿的故事来说明：“与其要回半个死孩子，不如保全婴儿性命，将婴儿送与对方好。”第一种“折中”，仍能符合边界条件，因为面包本是为了充饥，半片面包仍然是面包。但是第二种“折中”，却完全不符合边界条件了：婴儿是一条生命，半个婴儿就没有生命可言，只是半个尸体了。</p>
<p>关于决策是否容易被他人接受的问题，如果老是要考虑如何才能被他人接受，又怕他人会反对，那就完全是浪费时间，不会有任何结果。世界上的事，你所担心的往往不会出现；而你从来没有担心的，却可能变成极大的阻碍。当你担心别人不接受时就不敢提出最重要的结论，所以也得不到有效和正确的答案。</p>
<h2 id="化决策为行动"><a href="#化决策为行动" class="headerlink" title="化决策为行动"></a>化决策为行动</h2><p>考虑边界条件，是决策过程中最难的一步；化决策为行动，则是最费时的一步。然而从决策开始，我们就应该将行动的承诺纳入决策中，否则便是纸上谈兵。事实上，一项决策如果没有列举一条一条的行动步骤, 并指派为某某人的工作和责任，那便不能算是一项决策，最多只是一种意愿而已。</p>
<blockquote>
<p> 过多的政策说明令人困扰，尤其是在企业机构里更是如此：决策中没有行动的承诺，没有指定何人负责执行。所以，组织的成员看到颁布的政策时，总不免是你看看我，我看看你，以为上级只不过是说说罢了。</p>
</blockquote>
<p>若要化决策为行动，首先必须明确无误地回答下面几个问题：谁应该了解这项决策？应该采取什么行动？谁采取行动？这些行动应如何进行，才能使执行的人有所遵循？特别是第一个和最后一个问题，通常最容易被人忽略，以至于即使有了结果，也是灾难性的。</p>
<blockquote>
<p>用一个故事来说明“谁应该了解这项决策”的重要性。某一制造生产设备的大厂家，几年前决定停产某一型号的设备。这种设备本是该公司多年来的标准设备，迄今仍普遍使用，有关这种设备的订单很多，因此公司决定在未来三年继续向老客户提供这种设备。三年之后，公司才停止生产和销售这种设备。整个公司上下，谁也没有想到这一决策应让什么人知道。 甚至公司采购部门也不知道，因此仍然继续订购这种设备的零件，采购人员只知道按销货金额的一定比率购进零件。结果到了公司正式停产的那一天，库房竟积存了足够8年到10年的零件库存。这笔损失真是相当可观。</p>
</blockquote>
<p>决策行动还必须与执行人员的工作能力相适应。</p>
<blockquote>
<p>某一化学公司几年前曾发生大批资金冻结于非洲某两个国家，无法汇出之事。该公司为了保护这批资金，决定投资于非洲当地的企业。他们选定的企业，第一，对非洲当地的经济发展确有贡献；第二，不必从外面进口别的资源；第三，该企业将来成功后，一旦该国外汇解冻，应有希望转售于当地企业家，而将资金汇出。因此，该公司便积极着手筹备设厂，发展了一种简单的化学处理程序，将当地出产的热带水果加工。那种水果，在那两个国家中都有丰富的产量，但过去因没有加工而腐烂率极高，不能远销西方市场。</p>
<p>经过一番努力，两个国家的工厂都经营得非常成功。但是其中一个厂的厂长设定了过高的技术和管理水平，结果在当地找不到适当人选来接管。而另一个厂的厂长充分考虑到当地人员的水平，故加工程序较为简单，管理也较为容易。结果全厂自下而上，都能聘到可用的当地人才。</p>
<p>几年过去，两个国家都可以将外汇汇出了。在这时，公司当局准备将两家工厂转售当地的企业家。然而，那家有声有色、水准极高的加工厂，由于当地没有适合的技术和管理人才始终无法售出，结果该厂只落得清算了事。而另一家水准平平的工厂，当地投资人都竞相购买，公司不但收回了原先投下的资金，而且还大获其利。</p>
<p>事实上两厂的加工程序和经验方式基本上是相同的，问题只是第一家工厂当初在决策时，没有考虑到: “这一决策应由谁来执行?他们能做些什么?”从而导致最终的失败。</p>
</blockquote>
<p>尤其是为推行某一决策的执行人员必须改变其行为习惯和态度时，化决策为行动更是最重要的考虑。在这种情况下, 不但行动责任必须明确指定，执行人员必须确有能力，而且绩效的衡量及标准、激励制度也都需要配合改变。否则工作人员就会困于情绪的冲突之中。</p>
<blockquote>
<p>例如贝尔电话公司的总裁费尔，当初提出“以服务为目的”的新决策时，如果没有同时设计出可以用于衡量管理绩效的服务标准，则这一决策必将落空。在那以前，贝尔公司一向以盈利或成本为衡量绩效的标准。由于费尔提出了新标准，所以新目标才能顺利被人接受。</p>
</blockquote>
<h2 id="建立信息反馈制度"><a href="#建立信息反馈制度" class="headerlink" title="建立信息反馈制度"></a>建立信息反馈制度</h2><p>决策的最后一个要素，是应在决策中建立一项信息反制度，以便经常对决策所预期的成果做实际的印证。决策是人做的，人难免会犯错误。即使是最有效的决策，总有一天也是会淘汰的。</p>
<blockquote>
<p>艾森豪威尔当选美国总统时，他的前任杜鲁门总统曾说：“可怜的艾克，他是军人，下达命令后必有人执行；现在他要坐在这间大办公室里了，只怕他发布命令之后，一件事也做不成。”这不是因为军事将领比总统的权力更大，其实是因为军事组织早就知道仅仅发布命令是没有用的，必须同时建立反馈制度，可以检讨命令的执行。而最可靠的反馈，却在于亲自视察。然而当了总统，通常只能批阅报告。批阅报告有什么用呢？在军队里，长官发了命令，总得亲自检査命令的执行，至少也得派遣代表去检査，而不会坐在总部等候报告。这不是说军人不信任下属，而是经验告诉他们“报告”不一定靠得住。</p>
</blockquote>
<p>自从电脑问世以来，决策者和执行者之间的关系可能更加疏远。所以，如果管理者老坐在办公室，不到工作现场，他和实际情形必将越来越脱节。电脑处理的只是抽象资料，抽象资料只有经过实践的检验之后才是可靠的。否则必将走入歧路。</p>
<p>若想了解赖以做出决策的前提是否仍然有效，或者是否已经过时，只有亲自检査才最为可靠。我们看到许多早该修改的措施始终没有修改，其原因主要就是管理者不肯亲自去了解情况。企业的决策如此，政府的政策也是如此。我们需要组织化的信息作为反馈。我们需要数字，也需要报告。可是如果反馈不能反映实际情况，我们又不肯亲自察看，那么我们缺乏有效性也就不改怨谁了。</p>
<h1 id="有效的决策"><a href="#有效的决策" class="headerlink" title="有效的决策"></a>有效的决策</h1><h2 id="个人见解和决策的关系"><a href="#个人见解和决策的关系" class="headerlink" title="个人见解和决策的关系"></a>个人见解和决策的关系</h2><p>有效的决策常自多种不同而互相冲突的见解中产生，常自多种旗鼓相当、优劣互见的方案中产生。决策的过程先从本人的见解开始，因为凡是在某一领域具有经验者，都应该有他的见解。</p>
<p>人总是从自己的见解开始，所以要求别人从搜集事实开始，是不符合实际的。其结果是他所搜集的事实，必是以他自己既有的结论为根据；他既然先有了结论，必能搜集到许多事实。干过统计工作的人都能体会这一点，所以往往最不相信统计数字。统计工作人员可以知道或不知道数字提供者的立场，但是他知道数字的可疑。</p>
<p>唯一可以印证某一见解是否符合实际的方法，应以“见解为先”为基础，有了这样的认识，才能知道我们是以“尚待证实的假设”为起点，决策过程如此，科学研究也如此。假设是不必辩论的，却必须经得起验证，经得起验证的假设才值得我们重视。</p>
<p>有效的管理者鼓励大家提出见解。但在鼓励的同时，他也会叫大家深思其见解，认清其见解经过实证后的结果。因此，有效的管理者会问：“要验证某一假设是否为真，我们该知道些什么？”“要验证某一见解，应有些怎样的事实？他会培养出一种习惯：认清需要观察些什么、需要研究些什么和需要验证些什么。他会要求提出见解的每一个人理清他们应该期待和寻找什么样的事实。</p>
<p>最关键的问题是“相关的标准是什么？”。有效的决策人通常必先假定传统的衡量方法并非适当的衡量方法，不然他就用不着做决策了，只做简单调整就可以了。传统的衡量方法反映的是昨天的决策。我们之所以需要一项新决策，正表示过去的衡量方法已不适于今天了。</p>
<blockquote>
<p> 自从朝鲜战争以来，美国军用物资的采购和库存政策一直不理想。军方也曾为这个问题绞尽脑汁，做过许多研究，但情况不但没有好转，反而每况愈下。直到麦克纳马拉出任国防部长，才向军需库存的传统衡量方法发起了挑战。在过去，军需物资的采购和库存，一直以物资项目的总项数和总金额为衡量的基础。麦克纳马拉一反此项传统，改用另一种衡量方法。他发现在所有军需物资中，有极少数的项目(也许只占总项数的4%) 是高价物资，它们的采购金额占采购总金额的90%以上。 同样地，他又发现有极少数的项目(大约也只占总项数的4%)是重要物资，足以维持90%的战备。在这两项物资(高价物资和战备物资)中，尚有部分重复者，所以合并起来，全部重要物资只不过占总项数的5%或6%而已。</p>
<p>麦克纳马拉极力主张这类物资应予分别管理，严加管制。至于其余的95%的物资，论金额不大，论重要性也不致对战备有重大影响，他主张按照所谓“例外原则”来管理。麦克纳马拉这种一反过去传统的新衡量方法，立刻成为军需物资采购和库存的高度有效决策，也使整个后勤制度为之改观。</p>
</blockquote>
<p>如何才能找出适当的衡量方法呢? 只有依靠“反馈”制度，不过这里的反馈，是决策前的反馈。</p>
<blockquote>
<p>人事方面的许多问题都用“平均”数字来衡量，例如“平均每百人发生停工事故数”、“缺勤率”、“病假率”等等。但是一位管理者如果肯亲自出去看一看，就能发现他需要的是另一套衡量方法。“平均数”适用于保险公司的需要，但是对人事管理的决策没有意义，甚至有时还误导人们。以“停工事故”而言，可能大多数意外事件均发生在工厂内某一两个部门里。至于“缺勤率”，也可能大部分出在某一个单位。甚至于“病假率”，也不见得每一部门都与“平均数”相近，可能只局限于某一部分人，例如年轻女性。所以，有关人事方面的措施，如果仅以“平均数”为依据——例如据以推动全厂性的安全运动，就不见得能收到预期效果，甚至可能使情况更糟。</p>
<p>同样的道理，汽车制造业人士没有亲身查看，也正是该行业未能及早发现应该改善车辆安全设计的原因。汽车行业一向采用惯用的衡量方法，如“平均每行车公里交通事故数”。如果他们能亲身查看，就会发现交通事故应该改以“人体伤残情况”来衡量。如果能这样做，他们就能知道这项“安全运动”的重点，该放在“一旦发生事故时如何使损伤减至最低”方面，也就是说，应该改良车辆的设计。</p>
</blockquote>
<p>找出适当的衡量方法不是数学方法所能解决的，这是一项带有风险的判断。所谓判断，必须先有两项以上的方案，再自其中选取最适当的一种。</p>
<blockquote>
<p>以企业投资为例，通常都有多种衡量方法。其一，衡量投入资金需要多久才能收回；其二，衡量投资的获利能力；其三，衡量投资收益的“现值”。此外还有其他方法，但有效的管理者不会仅以其中某一方法为满足。即使会计部门强烈地推荐某一种方法最科学，有效的管理者也知道，任何方法都只能显示投资决策的某一层面。所以，除非他对每一角度都看得清清楚楚，否则不会轻易判断哪种方法最适合。会计部门也许不胜其烦，然而有效的管理者仍必须坚持分别用三种不同方法加以计算，他才会判定“某一衡量方法对这个投资决策来讲是最适合的”。</p>
</blockquote>
<p>这也说明了为什么有效的决策者故意不遵循教科书原则的道理。教科书上说决策需寻求“意见的一致”，但是他们却有意“制造”互相冲突的不同意见。换句话说，管理者的决策不是从“众口一词”中得来的。好的决策，应以互相冲突的意见为基础，从不同的观点和不同的判断中选择。所以，除非有不同的见解，否则就不可能有决策。这是决策的第一条原则。</p>
<blockquote>
<p>通用汽车公司总裁斯隆曾在该公司一次高层会议中说过：“诸位先生，在我看来，我们对这项决策已经有了完全一致的看法了。现在会议结束，这一问题延到下次开会时再行讨论。我希望下次开会时能听到相反的意见，只有这样，我们才能得到对这项决策的真正了解。”</p>
<p>在美国历史上每一位有效的总统都各有其一套激发反对意见的办法，以帮助自己做出有效的决策。林肯、老罗斯福、罗斯福、杜鲁门，都各有他们的方式。他们共同的秘诀都在于激发反对意见，以便从各种角度去了解决策的真正涵义。据说华盛顿总统最不愿见到冲突和争辩，希望有个意见一致的内阁。但实际上华盛顿在处理重要问题时常分别去征求汉密尔顿(Hamilton，华盛顿时代的财政部长)和杰斐逊(Jefferson，美国第三位总统)的意见，以便取得不同的意见。</p>
</blockquote>
<h2 id="反面意见的运用"><a href="#反面意见的运用" class="headerlink" title="反面意见的运用"></a>反面意见的运用</h2><p>为什么该有反面意见，主要有三项理由。</p>
<p>1.唯有引起争辩、掌握实据和经过深思熟虑的反面意见，才能保护决策者不致沦为组织的俘虏。<br>2.反面意见本身，正是决策所需的“另一方案”。如果在决策过程中有若干方案可供选择，则决策者进可攻退可守，有多方思考和比较的余地。否则，决策者舍此以外别无他途，无异于赌博。</p>
<blockquote>
<p>前文提到的德军“舒利芬计划”走不通了，德军始终没有第二套战略方案，只好痛苦地撑持下去，走一步改一步。实际上前后25年，德军参谋本部从来没有想到增拟另一套计划。参谋本部的力量，全部耗用在研究舒利芬计划的细节上了。等到舒利芬计划失败时，再也找不出第二条可行之路了。</p>
<p>罗斯福总统的故事正好相反。在他就任总统之前，竞选活动全以正统的经济计划为基础。但是同时，罗斯福总统还有另一批后来被称为“智囊团”的人才，专门研究“替代方案”。那套替代方案 以早年老罗斯福总统时代进步党的建议为基础，是一种根本不同的政策，以经济和社会的全面改革为目的。那一批研究“替代方案”的人才，后来都成了罗斯福总统的智囊团。因此，罗斯福接任总统后，美国金融制度起了变化，在当初的正统经济计划行不通的时候，他立刻胸有成竹地提出了第二套计划。所以，他才有一项有效的政策。</p>
</blockquote>
<p>3.反面意见可以激发想像力。一位管理者处理问题时，不管是政治、经济、社会还是军事，通常总是“不确定性”极高，就需要有“创造性”的解决方案，来开创新的局面。缺乏想像力的管理者不可能从另一个不同的、全新的角度去观察和理解。不同意见，特别是那些经过缜密推断和反复思考的、论据充分的不同意见，便是激发想像力的最为有效的因素。</p>
<blockquote>
<p>维多利亚时代南海某小岛的一位岛民前往西方旅行，归来后对岛上亲友畅谈他在西方所看到的“奇迹”。他说西方人的家中竟没有水喝。而在他们的小岛上，用水都是用半截竹筒引进来，所以家中可以“看见”流水。可是西方人家中是否真没有水呢？那只是因为西方国家用的是自来水，用水时需打开水龙头。但这位岛民在西方旅行时，谁也没有告诉他扭开水龙头即可有水。</p>
</blockquote>
<p>所以，有效的管理者会运用反面意见。只有这样，他才能避免为“似是而非”的看法所征服，他才能得到“替代方案”，以供他选择和决定；他也才能在万一决策行不通时不至于迷惘。同时，鼓励反面意见，可以启发他本人的想像力，启发与他共事者的想像力。反面意见能把“言之有理”者转化为“正确”，再把“正确”转化为“良好的决策”。</p>
<p>有效的管理者绝不认为某一行动方向为“是”，其他行动方向均为“非”。他也绝不坚持己见，以自己为“是”，以他人为“非”。有效的管理者会先找出为什么各人有不同的意见，并且他总是先假定任何人提出不同的意见，必是出于至诚，而不是视他人为蠢才或捣乱。</p>
<h2 id="是否真需要新决策"><a href="#是否真需要新决策" class="headerlink" title="是否真需要新决策"></a>是否真需要新决策</h2><p>有效的管理者还得再问一个问题：“我们是不是真需要一项决策？”有时候不做任何新决策，可能正是最好的决策。</p>
<p>做一项决策像动一次外科手术。任何新的决策都不免影响既有的制度，因此多少得冒风险。外科医师不到非动手术不可的时候绝不轻言开刀；同样地，不到非做决策的时候，也不宜轻易做出决策。每一位决策人也正像外科医师一样，各有不同性格。有的倾向于急进，有的则偏于保守。但是, 性格尽管不同，他们应当信守的原则却是统一的。</p>
<p>什么时候需要决策？如果继续保守成规情况就会恶化，那就必须做出新的决策。遇有新的机会来临，而且这新的机会至关重要、稍纵即逝的时候，也必须立刻做出新的决策。</p>
<p>决策的反面是不做任何决策，有时候不做任何改变，事情也不会出问题。我们问：“保持现状，会有什么后果？”如果不会有变化，那又何必横生枝节？</p>
<blockquote>
<p>一位财务主管感到财务危机重重，大声疾呼要求降低成本，连细枝末节也不放过。然而从小处来降低成本，即使有成果，其成果也微不足道。举例来说，他也许发现公司里最难控制成本的地方在推销和运输部门。于是他用了种种办法，去帮助这两个部门控制成本。他发现某一部门 “多”用了两三位老职员，于是大声叫嚷裁员，不顾别人对他的印象。别人说那两三位老职员已届退休之年，予以解雇未免不近情理，但他不听。他还说：“为什么要留用这几位老职员，而叫整个工厂受到影响?”</p>
<p>这次事件过去之后，公司同仁谁也不记得他当初挽救了公司，大家只记得他公报私仇，说他跟两三位与他合不来的老职员作对——而事实正是如此。其实，2000年前罗马律法就曾说过：“行政长官不宜考虑鸡毛蒜皮的事情。”直到今天，决策者还需要好好学习这句话。</p>
</blockquote>
<p>我们通常所做的决策，大部分都介于必须做决策与可以不做决策这两者之间。我们的问题，通常多是如何改进，而不是如何做真正的变革和创新。当然，这类问题还是值得我们重视的，有新决策，情况也许会变得更好。在这种情形下，有效的管理者会做比较：做了新决策可能有什么收获和风险；不做又可能有什么损失。实际上只要遵循下面两项原则就行了：</p>
<ol>
<li>如果利益远大于成本及风险，就该行动。</li>
<li>行动或不行动，切忌只做一半或折中。</li>
</ol>
<blockquote>
<p>以外科医师为例，做一次切除扁桃体或切除阑尾的手术固然是冒险，但是如果只切除一半同样是一大冒险。手术不成功不但治不了病，反将引起更严重的后果。所以，开刀或不开刀，不能只开一半。同样地，有效的决策者会采取行动或不采取行动，而不会只采取一半行动，只采取一半行动才是不折不扣的错误。</p>
</blockquote>
<h2 id="条件具备，即刻行动"><a href="#条件具备，即刻行动" class="headerlink" title="条件具备，即刻行动"></a>条件具备，即刻行动</h2><p>一切条件具备，现在就只等着决策了。规范已经清楚了，不同方案已经想到了，得失也衡量了，一切都已经一目了然，应采取什么行动，也已经清清楚楚。该采取什么决策，已是明摆着的了。</p>
<p>不幸的是，许多人到了这一步反而犹豫起来。此时，有效的管理者绝不会说：“让我们再研究研究！”那只证明这位管理者缺乏胆识。没有胆识的人可能失败一千次，有胆识的人则只失败一次。</p>
<p>面对他人“再研究研究”的呼声，卓有成效的管理者会问：“是不是再做一次研究就能讨论出新方案来？即使研究出新的方案，它是不是一定比现有的方案好？”如果答案是否定的，那么管理者就不需要再去做任何研究，他绝不会因为自己的优柔寡断再去浪费别人的时间。</p>
<p>不过，如果他的确尚未了解清楚，他也不会冒冒失失的做决策。但只要决策是正确的，就没有理由因其执行困难、因其可怕，或因其麻烦而退却。有效的决策者不会等得太久，也许一两天，最多一两周，只要“守护神”不在他耳朵边，他便会尽快行动。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul>
<li>管理者的工作必须卓有成效。</li>
<li>卓有成效是可以学会的。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>今天的社会有两种需要：</p>
<ul>
<li>对组织而言，需要个人为其做出贡献。</li>
<li>对个人而言，需要把组织当成实现自己人生目标的工具。</li>
</ul>
<p>只有管理者的有效性，才能使这两种社会需要相辅相成。因此，管理者必须学会卓有成效。</p>
]]></content>
      
        <categories>
            
            <category> 其它 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[系统编码问题]]></title>
      <url>http://lizonghang.github.io/2018/01/25/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>使用Python处理某些特殊字符或中文字符时，经常出现<code>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position xxx</code>。</p>
<p>打开一个Python解释器，看一下当前默认的编码，为ASCII码，ASCII码最多只能表示256个字符，因此对于中文字符或特殊字符就无能为力了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import sys</div><div class="line">&gt;&gt;&gt; sys.getdefaultencoding()</div><div class="line">&apos;ascii&apos;</div></pre></td></tr></table></figure>
<p>通常网上的办法为，但这不是一个好方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(&apos;utf8&apos;)</div></pre></td></tr></table></figure>
<p> 在Django Model中上传带有中文名的文件或图片时，也出现了编码错误的问题，建议不要在脚本内更改默认编码，而是将系统locale语言设置为zh_CN.UTF-8。查看系统默认语言：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ cat /etc/default/locale</div><div class="line">LANG=en_CN.UTF-8</div></pre></td></tr></table></figure>
<p>需要下载zh_CN.UTF-8并设置为默认语言:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 安装中文支持</div><div class="line">➜ sudo apt-get install language-pack-zh-hans</div><div class="line"># 更新locale文件并设置为默认语言。注意：此过程会在Shell中显示UI界面，先选中下载zh_CN.UTF-8 UTF-8语言集，回车确认，再选择设置zh_CN.UTF-8为系统默认语言。</div><div class="line">➜ dpkg-reconfigure locales</div><div class="line"># 查看当前系统语言</div><div class="line">➜ cat /etc/default/locale</div><div class="line">LANG=zh_CN.UTF-8</div></pre></td></tr></table></figure>
<p>将<code>export LC_ALL=zh_CN.UTF-8</code>添加到.bashrc并重载配置文件。</p>
<p>至此Django Model上传文件为中文文件名的UnicodeEncodeError就解决了。</p>
]]></content>
      
        <categories>
            
            <category> 服务器/后台 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark Yarn集群模式]]></title>
      <url>http://lizonghang.github.io/2018/01/14/Spark-Yarn%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>前置条件:</p>
<ul>
<li><a href="https://lizonghang.github.io/2018/01/09/Hadoop安装与伪分布式部署/#more">Hadoop+ZooKeeper</a></li>
<li><a href="https://lizonghang.github.io/2018/01/14/Spark-Standalone集群模式与ZooKeeper搭建热备HA/">Spark</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">➜ ssh parallels@master jps</div><div class="line">5763 NameNode</div><div class="line">6728 Jps</div><div class="line">6056 SecondaryNameNode</div><div class="line">3806 QuorumPeerMain</div><div class="line">➜ ssh parallels@slave1 jps</div><div class="line">3728 QuorumPeerMain</div><div class="line">4577 DataNode</div><div class="line">4789 ResourceManager</div><div class="line">5419 Jps</div><div class="line">4910 NodeManager</div><div class="line">➜ ssh parallels@slave2 jps</div><div class="line">4807 NodeManager</div><div class="line">5145 Jps</div><div class="line">3577 QuorumPeerMain</div><div class="line">4474 DataNode</div><div class="line">4686 ResourceManager</div></pre></td></tr></table></figure>
<p>修改spark-2.2.1/conf/spark-env.sh:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜ vim spark-env.sh</div><div class="line">...</div><div class="line">export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop</div><div class="line">export YARN_CONF_DIR=$HADOOP_HOME/etc/hadoop</div><div class="line"># If echo $JAVA_HOME is blank</div><div class="line">export JAVA_HOME=/usr/lib/jvm/java-8-oracle</div><div class="line">export PATH=$PATH:$JAVA_HOME/bin</div></pre></td></tr></table></figure>
<p>将spark-2.2.1/jars/*上传到HDFS文件系统中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ hadoop fs -mkdir /spark_jars</div><div class="line">➜ hadoop fs -put spark-2.2.1/jars/* /spark_jars</div></pre></td></tr></table></figure>
<p>编辑spark-default.conf:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ cp spark-defaults.conf.template spark-defaults.conf</div><div class="line">➜ vim spark-defaults.conf</div><div class="line">...</div><div class="line">spark.yarn.jars=hdfs://master:9000/spark_jars/*</div></pre></td></tr></table></figure>
<p>Cluster集群模式测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜ spark-submit --class org.apache.spark.examples.SparkPi \</div><div class="line">    --master yarn \</div><div class="line">    --deploy-mode cluster \</div><div class="line">    --driver-memory 1g \</div><div class="line">    --executor-memory 1g \</div><div class="line">    --executor-cores 1 \</div><div class="line">    examples/jars/spark-examples_2.11-2.2.1.jar \</div><div class="line">    10</div></pre></td></tr></table></figure>
<p>查看<a href="http://slave1:8088" target="_blank" rel="external">http://slave1:8088</a>该Application的状态，若State为FINISHED，FinalStatus为SUCCEEDED，则YARN集群正常工作。</p>
<p>Client集群模式测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ pyspark --master yarn --deploy-mode client</div></pre></td></tr></table></figure>
<p>Client模式运行过程中可能会报java.nio.channels.ClosedChannelException、java.io.IOException: Failed to send RPC等一堆错，查看NodeManager的日志:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Container is running beyond virtual memory limits. Current usage: 192.9 MB of 1 GB physical memory used; 2.1 GB of 2.1 GB virtual memory used. Killing container.</div></pre></td></tr></table></figure>
<p>可以判断出是虚拟内存不足导致Container关闭。</p>
<p>网上的解决办法：</p>
<p>一、根据主机内存分配设置hadoop-3.0.0/etc/hadoop/yarn-site.xml改变内存限制（无作用）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;/name&gt;</div><div class="line">&lt;value&gt;8192&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt;</div><div class="line">&lt;value&gt;1024&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.nodemanager.vmem-pmem-ratio&lt;/name&gt;</div><div class="line">&lt;value&gt;2.1&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure>
<p>二、直接关闭虚拟内存检测（无作用）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt;</div><div class="line">&lt;value&gt;false&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;</div><div class="line">&lt;value&gt;false&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure>
<p>三、给虚拟机多分配些内存</p>
]]></content>
      
        <categories>
            
            <category> Hadoop/Spark </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark Standalone集群模式与ZooKeeper搭建热备HA]]></title>
      <url>http://lizonghang.github.io/2018/01/14/Spark-Standalone%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%8EZooKeeper%E6%90%AD%E5%BB%BA%E7%83%AD%E5%A4%87HA/</url>
      <content type="html"><![CDATA[<p>集群环境说明: 开启三台Linux虚拟机，一台作为Master，两台作为Slave，NAT模式或桥接模式均可，信息如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Master</div><div class="line">    IP: 10.211.55.3</div><div class="line">    Hostname: master</div><div class="line">    Cores: 2</div><div class="line">    Memory: 2G</div><div class="line">    </div><div class="line">Slave1</div><div class="line">    IP: 10.211.55.4</div><div class="line">    Hostname: slave1</div><div class="line">    Cores: 2</div><div class="line">    Memory: 2G</div><div class="line"></div><div class="line">Slave2</div><div class="line">    IP: 10.211.55.5</div><div class="line">    Hostname: slave2</div><div class="line">    Cores: 2</div><div class="line">    Memory: 2G</div></pre></td></tr></table></figure></p>
<h1 id="Spark下载与配置"><a href="#Spark下载与配置" class="headerlink" title="Spark下载与配置"></a>Spark下载与配置</h1><h2 id="Spark下载"><a href="#Spark下载" class="headerlink" title="Spark下载"></a>Spark下载</h2><p>从官网下载适合适合本机Hadoop版本的<a href="http://spark.apache.org/downloads.html" target="_blank" rel="external">spark</a>，作者使用<a href="https://www.apache.org/dyn/closer.lua/spark/spark-2.2.1/spark-2.2.1-bin-hadoop2.7.tgz" target="_blank" rel="external">spark-2.2.1-bin-hadoop2.7.tgz</a>。假设解压到~/spark-2.2.1。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>添加环境变量：将spark-2.2.1/bin添加到$PATH$中。</p>
<p>注意: spark-2.2.1/sbin中含有与hadoop-3.0.0/sbin中相同文件名的脚本，因此不要将spark-2.2.1/sbin添加到$PATH$。</p>
<h2 id="Spark-Standalone集群模式配置"><a href="#Spark-Standalone集群模式配置" class="headerlink" title="Spark Standalone集群模式配置"></a>Spark Standalone集群模式配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜ cd spark-2.2.1/conf</div><div class="line">➜ cp slaves.template slaves</div><div class="line">➜ cp spark-env.sh.template spark-env.sh</div><div class="line">➜ vim spark-env.sh</div><div class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_111</div><div class="line">export SPARK_MASTER_IP=master</div><div class="line">export SPARK_MASTER_PORT=7077</div><div class="line">export SPARK_WORKER_CORES=1</div><div class="line">export SPARK_WORKER_INSTANCES=1</div><div class="line">export SPARK_WORKER_MEMORY=1g</div><div class="line">➜ vim slaves</div><div class="line">slave1</div><div class="line">slave2</div></pre></td></tr></table></figure>
<p>编辑好后，将spark-env.sh和slaves文件复制到slave1和slave2主机的spark-2.2.1/conf目录中。</p>
<h2 id="Spark运行与测试"><a href="#Spark运行与测试" class="headerlink" title="Spark运行与测试"></a>Spark运行与测试</h2><h3 id="启动Spark"><a href="#启动Spark" class="headerlink" title="启动Spark"></a>启动Spark</h3><p>使用spark-2.2.1/sbin/start-all.sh脚本启动Spark。</p>
<p>注意: 不是直接使用start-all.sh，因为PATH中start-all.sh对应的可能是hadoop-3.0.0/sbin/start-all.sh。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ cd spark-2.2.1</div><div class="line">➜ spark-2.2.1/sbin/start-all.sh</div><div class="line">starting org.apache.spark.deploy.master.Master, logging to /home/parallels/Desktop/spark-2.2.1/logs/spark-parallels-org.apache.spark.deploy.master.Master-1-master.out</div><div class="line">slave2: starting org.apache.spark.deploy.worker.Worker, logging to /home/parallels/Desktop/spark-2.2.1/logs/spark-parallels-org.apache.spark.deploy.worker.Worker-1-slave2.out</div><div class="line">slave1: starting org.apache.spark.deploy.worker.Worker, logging to /home/parallels/Desktop/spark-2.2.1/logs/spark-parallels-org.apache.spark.deploy.worker.Worker-1-slave1.out</div></pre></td></tr></table></figure>
<p>查看master-Master、slave1-Worker、slave2-Woker进程是否启动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">➜ ssh parallels@master jps</div><div class="line">16433 Jps</div><div class="line">16205 Master</div><div class="line">➜ ssh parallels@slave1 jps</div><div class="line">12880 Jps</div><div class="line">12465 Worker</div><div class="line">➜ ssh parallels@slave2 jps</div><div class="line">10468 Worker</div><div class="line">10890 Jps</div></pre></td></tr></table></figure>
<p>Spark可视化页面8080端口: <a href="http://master:8080。" target="_blank" rel="external">http://master:8080。</a></p>
<h3 id="Client与Cluster模式集群测试"><a href="#Client与Cluster模式集群测试" class="headerlink" title="Client与Cluster模式集群测试"></a>Client与Cluster模式集群测试</h3><h4 id="Client模式集群测试"><a href="#Client模式集群测试" class="headerlink" title="Client模式集群测试"></a>Client模式集群测试</h4><p>Client模式下Driver与Client位于同一主机master，输出直接打印到Client。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜ spark-submit --class org.apache.spark.examples.SparkPi --master spark://master:7077 --executor-memory 1G --total-executor-cores 2 spark-2.2.1/examples/jars/spark-examples_2.11-2.2.1.jar 1000</div><div class="line">...</div><div class="line">Pi is roughly 3.141622391416224</div></pre></td></tr></table></figure>
<h4 id="Cluster模式集群测试"><a href="#Cluster模式集群测试" class="headerlink" title="Cluster模式集群测试"></a>Cluster模式集群测试</h4><p>Cluster模式下Driver位于Worker的某个节点中，Client与Worker分离，输出不打印到Client，可在8080端口对应页面中Application的stdout中查看打印结果。该模式可用于长时间运行的程序。</p>
<p>注意: <code>—deploy-mode</code>默认为<code>client</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ spark-submit --class org.apache.spark.examples.SparkPi --master spark://master:7077 --deploy-mode cluster --supervise --executor-memory 1G --total-executor-cores 2 spark-2.2.1/examples/jars/spark-examples_2.11-2.2.1.jar 1000</div></pre></td></tr></table></figure>
<p>运行时可在8080端口对应页面中看到某个Worker节点上启动了Driver。</p>
<h1 id="ZooKeeper搭建热备HA"><a href="#ZooKeeper搭建热备HA" class="headerlink" title="ZooKeeper搭建热备HA"></a>ZooKeeper搭建热备HA</h1><p>官方说明: <a href="http://spark.apache.org/docs/latest/spark-standalone.html#high-availability" target="_blank" rel="external">Standby Masters with ZooKeeper</a>。</p>
<h2 id="ZooKeeper下载与配置"><a href="#ZooKeeper下载与配置" class="headerlink" title="ZooKeeper下载与配置"></a>ZooKeeper下载与配置</h2><p>参考前文<a href="https://lizonghang.github.io/2018/01/09/Hadoop安装与伪分布式部署/">Hadoop安装与伪分布式部署</a>中的”ZooKeeper安装与配置”一节。假设<code>clientPort=2181</code>。</p>
<p>启动ZooKeeper:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">➜ ssh parallels@master $ZK_HOME/bin/zkServer.sh start</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/parallels/Desktop/zookeeper-3.4.11/bin/../conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div><div class="line">➜ ssh parallels@slave1 $ZK_HOME/bin/zkServer.sh start</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/parallels/Desktop/zookeeper-3.4.11/bin/../conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div><div class="line">➜ ssh parallels@slave2 $ZK_HOME/bin/zkServer.sh start</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/parallels/Desktop/zookeeper-3.4.11/bin/../conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div><div class="line">➜ ssh parallels@master $ZK_HOME/bin/zkServer.sh status</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/parallels/Desktop/zookeeper-3.4.11/bin/../conf/zoo.cfg</div><div class="line">Mode: follower</div><div class="line">➜ ssh parallels@slave1 $ZK_HOME/bin/zkServer.sh status</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/parallels/Desktop/zookeeper-3.4.11/bin/../conf/zoo.cfg</div><div class="line">Mode: leader</div><div class="line">➜ ssh parallels@slave2 $ZK_HOME/bin/zkServer.sh status</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/parallels/Desktop/zookeeper-3.4.11/bin/../conf/zoo.cfg</div><div class="line">Mode: follower</div></pre></td></tr></table></figure></p>
<p>此时三台主机中应各有一个QuorumPeerMain进程。</p>
<h3 id="Spark-HA配置"><a href="#Spark-HA配置" class="headerlink" title="Spark HA配置"></a>Spark HA配置</h3><p>在spark-2.2.1/conf/spark-env.sh中添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export SPARK_DAEMON_JAVA_OPTS=&quot;-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=master:2181,slave1:2181,slave2:2181&quot;</div></pre></td></tr></table></figure></p>
<p>并将该文件复制到slave1和slave2中，重启Spark:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ spark-2.2.1/sbin/stop-all.sh</div><div class="line">➜ spark-2.2.1/sbin/start-all.sh</div></pre></td></tr></table></figure>
<p>此时三台主机中仍然只有master一台有Master进程，slave1和slave2只有Worker进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">➜ ssh parallels@master jps</div><div class="line">21894 Master</div><div class="line">21146 QuorumPeerMain</div><div class="line">22458 Jps</div><div class="line">➜ ssh parallels@slave1 jps</div><div class="line">17475 QuorumPeerMain</div><div class="line">18234 Worker</div><div class="line">18746 Jps</div><div class="line">➜ ssh parallels@slave2 jps</div><div class="line">15315 QuorumPeerMain</div><div class="line">16056 Worker</div><div class="line">16575 Jps</div></pre></td></tr></table></figure>
<p>假设启用slave1作为备用Master（Standby），编辑slave1中的spark-2.2.1/conf/spark-env.sh文件，将<code>SPARK_MASTER_IP</code>改为其自己。随后使用spark-2.2.1/sbin/start-master.sh&lt;/code&gt;启动slave1的Master进程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># slave1</div><div class="line">➜ spark-2.2.1/sbin/start-master.sh</div><div class="line">➜ jps</div><div class="line">17475 QuorumPeerMain</div><div class="line">19623 Jps</div><div class="line">18234 Worker</div><div class="line">19454 Master</div></pre></td></tr></table></figure>
<p>此时slave1上同时运行了Master进程和Worker进程，通过<a href="http://master:8080" target="_blank" rel="external">http://master:8080</a>和<a href="http://slave1:8080" target="_blank" rel="external">http://slave1:8080</a>可以看出master上的Master进程处于ALIVE状态，slave1上的Master进程处于STANDBY状态。</p>
<p>手动杀死master上的Master进程，隔一段时间（1-2min）可以看到slave1上的Master进程切换为ALIVE状态，并且原master上的Application信息转移到slave1。</p>
<h1 id="Spark使用Standalone集群模式运行"><a href="#Spark使用Standalone集群模式运行" class="headerlink" title="Spark使用Standalone集群模式运行"></a>Spark使用Standalone集群模式运行</h1><p>交互式环境:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ pyspark --master spark://master:7077</div></pre></td></tr></table></figure></p>
<p>脚本文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from pyspark import SparkConf, SparkContext</div><div class="line">conf = SparkConf().setMaster(&quot;spark://master:7077&quot;)</div><div class="line">sc = SparkContext(conf=conf)</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Hadoop/Spark </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hive+MySQL安装与伪分布式配置]]></title>
      <url>http://lizonghang.github.io/2018/01/10/Hive-MySQL%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="下载Hive"><a href="#下载Hive" class="headerlink" title="下载Hive"></a>下载<a href="http://mirror.bit.edu.cn/apache/hive/" target="_blank" rel="external">Hive</a></h1><p>作者使用的是hive-2.3.2，解压到~/hive-2.3.2。</p>
<h1 id="Hive配置"><a href="#Hive配置" class="headerlink" title="Hive配置"></a>Hive配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ cd cd hive-2.3.2/conf</div><div class="line">➜ cp hive-log4j2.properties.template hive-log4j2.properties</div><div class="line">➜ cp hive-default.xml.template hive-site.xml</div><div class="line">➜ cp hive-env.sh.template hive-env.sh</div><div class="line">➜ cp hive-exec-log4j2.properties.template hive-exec-log4j2.properties</div></pre></td></tr></table></figure>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ vim ~/.zshrc</div><div class="line"># Hive</div><div class="line">export HIVE_HOME=~/hive-2.3.2</div><div class="line">export PATH=$PATH:$HIVE_HOME/bin</div><div class="line">➜ source ~/.zshrc</div></pre></td></tr></table></figure>
<h2 id="修改hive-site-xml"><a href="#修改hive-site-xml" class="headerlink" title="修改hive-site.xml:"></a>修改hive-site.xml:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</div><div class="line">&lt;value&gt;jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;</div><div class="line">&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;</div><div class="line">&lt;value&gt;USER&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;</div><div class="line">&lt;value&gt;PASSWORD&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<p>注意: 其中<code>USER</code>和<code>PASSWORD</code>是MySQL中的用户名和密码，在之后设置好MySQL账户密码后修改此处。</p>
<h1 id="MySQL配置"><a href="#MySQL配置" class="headerlink" title="MySQL配置"></a>MySQL配置</h1><p>MySQL的安装参考<a href="https://lizonghang.github.io/2018/01/10/Mac安装MySQL/">Mac安装MySQL</a>或<a href="https://lizonghang.github.io/2018/01/10/Linux安装MySQL/">Linux安装MySQL</a>。</p>
<p>使用root账户以及密码登录MySQL:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ mysql -u root -p</div></pre></td></tr></table></figure></p>
<p>新建hive数据库，用来保存hive的元数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; create database hive;</div></pre></td></tr></table></figure></p>
<p>将hive数据库下的所有表的所有权限赋给hadoop用户(自定义，对应hive-site.xml中的<code>USER</code>)，并将mysql作为登录密码(自定义，对应hive-site.xml中的<code>PASSWORD</code>)，然后刷新系统权限关系表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; CREATE USER  &apos;hadoop&apos;@&apos;%&apos;  IDENTIFIED BY &apos;mysql&apos;;</div><div class="line">mysql&gt; GRANT ALL PRIVILEGES ON  *.* TO &apos;hadoop&apos;@&apos;%&apos; WITH GRANT OPTION;</div><div class="line">mysql&gt; flush privileges;</div></pre></td></tr></table></figure></p>
<p>注意: 在ubuntu系统里，默认情况下MySQL只允许本地登录，所以需要修改配置文件将地址绑定注释。在/etc/mysql/my.cnf中找到<code>bind-address</code>并注释该行。</p>
<p>将MySQL驱动包<a href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="external">mysql-connector-java-5.1.45-bin.jar</a>复制到~/hive-2.3.2/lib。</p>
<h1 id="运行Hive"><a href="#运行Hive" class="headerlink" title="运行Hive"></a>运行Hive</h1><p>先初始化Hive元数据库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ schematool -initSchema -dbType mysql</div></pre></td></tr></table></figure></p>
<p>看一下初始化后的信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜ schematool -dbType mysql -info</div><div class="line">...</div><div class="line">Metastore connection URL:     jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true</div><div class="line">Metastore Connection Driver :     com.mysql.jdbc.Driver</div><div class="line">Metastore connection User:     lizh</div><div class="line">Hive distribution version:     2.3.0</div><div class="line">Metastore schema version:     2.3.0</div><div class="line">schemaTool completed</div></pre></td></tr></table></figure></p>
<p>运行Hive:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">➜  ~ hive</div><div class="line">...</div><div class="line">hive&gt; create table test(id int,name string);</div><div class="line">OK</div><div class="line">Time taken: 0.011 seconds</div><div class="line">hive&gt; show tables;</div><div class="line">OK</div><div class="line">test</div><div class="line">Time taken: 0.022 seconds, Fetched: 1 row(s)</div></pre></td></tr></table></figure></p>
<p>看看Hive在HDFS创建的目录:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜ hadoop fs -ls /user</div><div class="line">Found 2 items</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-10 20:33 /user/hive</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-09 20:09 /user/lizh</div><div class="line">➜ hadoop fs -ls -R /user/hive</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-10 20:33 /user/hive/warehouse</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-10 20:33 /user/hive/warehouse/test</div></pre></td></tr></table></figure></p>
<p>看看Hive在MySQL中创建的新表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; use hive;</div><div class="line">mysql&gt; select * from TBLS;</div><div class="line">+--------+-------------+-------+------------------+-------+-----------+-------+----------+---------------+--------------------+--------------------+--------------------+</div><div class="line">| TBL_ID | CREATE_TIME | DB_ID | LAST_ACCESS_TIME | OWNER | RETENTION | SD_ID | TBL_NAME | TBL_TYPE      | VIEW_EXPANDED_TEXT | VIEW_ORIGINAL_TEXT | IS_REWRITE_ENABLED |</div><div class="line">+--------+-------------+-------+------------------+-------+-----------+-------+----------+---------------+--------------------+--------------------+--------------------+</div><div class="line">|      1 |  1515587593 |     1 |                0 | lizh  |         0 |     1 | test     | MANAGED_TABLE | NULL               | NULL               |                    |</div><div class="line">+--------+-------------+-------+------------------+-------+-----------+-------+----------+---------------+--------------------+--------------------+--------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Hadoop/Spark </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux安装MySQL]]></title>
      <url>http://lizonghang.github.io/2018/01/10/Linux%E5%AE%89%E8%A3%85MySQL/</url>
      <content type="html"><![CDATA[<h3 id="检查系统上是否已经装了MySQL"><a href="#检查系统上是否已经装了MySQL" class="headerlink" title="检查系统上是否已经装了MySQL"></a>检查系统上是否已经装了MySQL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ netstat -tap | grep mysql</div></pre></td></tr></table></figure>
<p>如果没有，直接用apt安装；如果已经装好了，但是不知道root密码，且没有办法获取到root密码，需要完全卸载MySQL并重装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ sudo rm -R /var/lib/mysql/</div><div class="line">➜ sudo rm -R /etc/mysql/</div><div class="line">➜ sudo apt-get autoremove mysql* --purge</div><div class="line">➜ sudo apt-get remove apparmor</div></pre></td></tr></table></figure>
<p>注意: 如果使用的shell是zsh，autoremove可能会出现no matches found: mysql<em>。zsh默认对mysql</em>进行解释，而不是传递给autoremove，因此需要在~/.zshrc中加入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setopt no_nomatch</div></pre></td></tr></table></figure>
<h3 id="apt安装MySQL"><a href="#apt安装MySQL" class="headerlink" title="apt安装MySQL"></a>apt安装MySQL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ sudo apt-get install mysql-server mysql-common</div></pre></td></tr></table></figure>
<p>安装过程中会提示输入root密码。</p>
<h3 id="登录测试"><a href="#登录测试" class="headerlink" title="登录测试"></a>登录测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ mysql -u root -p</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Hadoop/Spark </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac安装MySQL]]></title>
      <url>http://lizonghang.github.io/2018/01/10/Mac%E5%AE%89%E8%A3%85MySQL/</url>
      <content type="html"><![CDATA[<h3 id="更新-Homebrew-后安装MySQL"><a href="#更新-Homebrew-后安装MySQL" class="headerlink" title="更新 Homebrew 后安装MySQL"></a>更新 Homebrew 后安装MySQL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ brew update</div><div class="line">➜ brew install mysql</div></pre></td></tr></table></figure>
<h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ mysql.server start</div></pre></td></tr></table></figure>
<h3 id="设置登录密码"><a href="#设置登录密码" class="headerlink" title="设置登录密码"></a>设置登录密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">➜ mysql_secure_installation</div><div class="line"></div><div class="line">Securing the MySQL server deployment.</div><div class="line"></div><div class="line">Connecting to MySQL using a blank password.</div><div class="line"></div><div class="line">VALIDATE PASSWORD PLUGIN can be used to test passwords</div><div class="line">and improve security. It checks the strength of password</div><div class="line">and allows the users to set only those passwords which are</div><div class="line">secure enough. Would you like to setup VALIDATE PASSWORD plugin?</div><div class="line"></div><div class="line">Press y|Y for Yes, any other key for No: y</div><div class="line"></div><div class="line">There are three levels of password validation policy:</div><div class="line"></div><div class="line">LOW    Length &gt;= 8</div><div class="line">MEDIUM Length &gt;= 8, numeric, mixed case, and special characters</div><div class="line">STRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary file</div><div class="line"></div><div class="line">Please enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 0</div><div class="line">Please set the password for root here.</div><div class="line"></div><div class="line">New password: PASSWORD_HERE</div><div class="line"></div><div class="line">Re-enter new password: PASSWORD_HERE</div><div class="line"></div><div class="line">Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : y</div><div class="line"></div><div class="line">By default, a MySQL installation has an anonymous user,</div><div class="line">allowing anyone to log into MySQL without having to have</div><div class="line">a user account created for them. This is intended only for</div><div class="line">testing, and to make the installation go a bit smoother.</div><div class="line">You should remove them before moving into a production</div><div class="line">environment.</div><div class="line"></div><div class="line">Remove anonymous users? (Press y|Y for Yes, any other key for No) : y</div><div class="line">Success.</div><div class="line"></div><div class="line">Normally, root should only be allowed to connect from</div><div class="line">&apos;localhost&apos;. This ensures that someone cannot guess at</div><div class="line">the root password from the network.</div><div class="line"></div><div class="line">Disallow root login remotely? (Press y|Y for Yes, any other key for No) : n</div><div class="line"></div><div class="line">... skipping.</div><div class="line">By default, MySQL comes with a database named &apos;test&apos; that</div><div class="line">anyone can access. This is also intended only for testing,</div><div class="line">and should be removed before moving into a production</div><div class="line">environment.</div><div class="line"></div><div class="line">Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y</div><div class="line">- Dropping test database...</div><div class="line">Success.</div><div class="line"></div><div class="line">- Removing privileges on test database...</div><div class="line">Success.</div><div class="line"></div><div class="line">Reloading the privilege tables will ensure that all changes</div><div class="line">made so far will take effect immediately.</div><div class="line"></div><div class="line">Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y</div><div class="line">Success.</div><div class="line"></div><div class="line">All done!</div></pre></td></tr></table></figure>
<h3 id="使用设置的密码测试登录"><a href="#使用设置的密码测试登录" class="headerlink" title="使用设置的密码测试登录"></a>使用设置的密码测试登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ mysql -u root -p</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Hadoop/Spark </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[HBase安装与伪分布式部署]]></title>
      <url>http://lizonghang.github.io/2018/01/10/HBase%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<p>注意: 使用HBase需要确保已启动HDFS和ZooKeeper。</p>
<p>下载<a href="https://mirrors.cnnic.cn/apache/hbase/" target="_blank" rel="external">HBase安装包</a>，作者使用的是hbase-1.2.6。假设解压到~/hbase-1.2.6。</p>
<p>将Hadoop下的hdfs-site.xml和core-site.xml复制到HBase的conf目录下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ cp ~/hadoop-3.0.0/etc/hadoop/hdfs-site.xml ~/hbase-1.2.6/conf/</div><div class="line">➜ cp ~/hadoop-3.0.0/etc/hadoop/core-site.xml ~/hbase-1.2.6/conf/</div></pre></td></tr></table></figure>
<p>将路径~/hbase-1.2.6/bin添加到<code>PATH</code>中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># HBase</div><div class="line">export HBASE_HOME=~/hbase-1.2.6</div><div class="line">export PATH=$PATH:$HBASE_HOME/bin</div></pre></td></tr></table></figure>
<p>设置hbase-env.sh中的<code>JAVA_HOME</code>，并告诉HBase使用外部ZK:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜ vim hbase-1.2.6/conf/hbase-env.sh</div><div class="line"></div><div class="line"># The java implementation to use.  Java 1.7+ required.</div><div class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_111</div><div class="line"></div><div class="line"># Tell HBase whether it should manage it&apos;s own instance of Zookeeper or not.</div><div class="line">export HBASE_MANAGES_ZK=false</div></pre></td></tr></table></figure>
<p>配置hbase-site.xml:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">➜ vim hbase-1.2.6/conf/hbase-site.xml</div><div class="line"></div><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;hbase.rootdir&lt;/name&gt;</div><div class="line">&lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;hbase.cluster.distributed&lt;/name&gt;</div><div class="line">&lt;value&gt;true&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;hbase.master.info.port&lt;/name&gt;</div><div class="line">&lt;value&gt;60010&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;</div><div class="line">&lt;value&gt;localhost:2181,localhost:2182,localhost:2183&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<p>设置slave的集群:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜ vim hbase-1.2.6/conf/regionservers</div><div class="line"></div><div class="line">localhost</div></pre></td></tr></table></figure>
<p>注意: 若为全分布式部署，需要修改<code>hbase.rootdir</code>与<code>hbase.zookeeper.quorum</code>，并在regionservers中添加DataNode主机名。将hbase-1.2.6文件夹复制到其它节点，并启动所有节点的HBase。</p>
<p>注意: 需要提前启动ZooKeeper和HDFS。</p>
<p>启动HBase:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ start-hbase.sh</div><div class="line">➜ jps</div><div class="line">45043 HMaster</div><div class="line">45283 HRegionServer</div><div class="line">...</div></pre></td></tr></table></figure>
<p>查看HBase Web是否可访问，<a href="http://127.0.0.1:60010" target="_blank" rel="external">http://127.0.0.1:60010</a>，可以使用命令<code>netstat -tpnl | grep 60010</code>查看60010端口是否开启。</p>
<p>注意: 全分布模式下，为保证集群的可靠性，要启动多个HMaster:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ hbase-daemon.sh start master</div></pre></td></tr></table></figure>
<p>使用Shell操作HBase:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ hbase shell</div></pre></td></tr></table></figure>
<p>官方文档: <a href="http://hbase.apache.org/book.html" target="_blank" rel="external">Apache HBase ™ Reference Guide</a></p>
]]></content>
      
        <categories>
            
            <category> Hadoop/Spark </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop安装与伪分布式部署]]></title>
      <url>http://lizonghang.github.io/2018/01/09/Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<p>注意: 本文中<code>~</code>建议换成完整路径。</p>
<p>注意: 由于对内存要求较高，建议直接在本机，而不是在虚拟机进行实验。</p>
<h1 id="Java环境要求"><a href="#Java环境要求" class="headerlink" title="Java环境要求"></a>Java环境要求</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜ java -version</div><div class="line">java version &quot;1.8.0_91&quot;</div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_91-b14)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)</div><div class="line">➜ javac -version</div><div class="line">javac 1.8.0_111</div><div class="line">➜ jps</div><div class="line">28460 Jps</div></pre></td></tr></table></figure>
<p>若Java版本较低，建议升级到Java1.8，在官网下载对应系统的<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">jdk-8u151或jdk-8u152</a>覆盖当前版本。</p>
<h1 id="ZooKeeper安装与配置"><a href="#ZooKeeper安装与配置" class="headerlink" title="ZooKeeper安装与配置"></a>ZooKeeper安装与配置</h1><h2 id="ZooKeeper安装"><a href="#ZooKeeper安装" class="headerlink" title="ZooKeeper安装"></a>ZooKeeper安装</h2><p>在<a href="https://www.apache.org/dyn/closer.cgi/zookeeper/" target="_blank" rel="external">ZooKeeper</a>官网下载较新版本的ZooKeeper。作者使用的ZooKeeper 3.4.11。假设解压到目录<code>~/zookeeper/zookeeper-3.4.11-0</code>。</p>
<h2 id="ZooKeeper配置"><a href="#ZooKeeper配置" class="headerlink" title="ZooKeeper配置"></a>ZooKeeper配置</h2><p>进入ZooKeeper根目录，添加配置文件<code>zoo.cfg</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ cp conf/zoo_sample.cfg conf/zoo.cfg</div><div class="line">➜ vim conf/zoo.cfg</div></pre></td></tr></table></figure>
<p><code>zoo.cfg</code>配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">tickTime=2000</div><div class="line">initLimit=10</div><div class="line">syncLimit=5</div><div class="line">dataDir=~/zookeeper/zookeeper-3.4.11-0/data</div><div class="line">clientPort=2181</div><div class="line"></div><div class="line">server.0=127.0.0.1:8880:7770</div><div class="line">server.1=127.0.0.1:8881:7771</div><div class="line">server.2=127.0.0.1:8882:7772</div></pre></td></tr></table></figure>
<p>在ZooKeeper根目录下新建<code>./data/myid</code>，其记录值为<code>server.X</code>的<code>X</code>值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ mkdir data</div><div class="line">➜ echo 0 &gt; data/myid</div></pre></td></tr></table></figure>
<p>复制ZooKeeper两次，得到三个ZooKeeper文件夹:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜ cd ~/zookeeper</div><div class="line">➜ cp zookeeper-3.4.11-0 zookeeper-3.4.11-1</div><div class="line">➜ cp zookeeper-3.4.11-0 zookeeper-3.4.11-2</div></pre></td></tr></table></figure>
<p>分别修改<code>zookeeper-3.4.11-1/conf/zoo.cfg</code>和<code>zookeeper-3.4.11-2/conf/zoo.cfg</code>，将<code>dataDir</code>中的路径修改为对应文件夹名称的路径，并修改对应的<code>data/myid</code>记录值。</p>
<h2 id="ZooKeeper启动、停止与状态查询"><a href="#ZooKeeper启动、停止与状态查询" class="headerlink" title="ZooKeeper启动、停止与状态查询"></a>ZooKeeper启动、停止与状态查询</h2><h3 id="ZooKeeper启动"><a href="#ZooKeeper启动" class="headerlink" title="ZooKeeper启动"></a>ZooKeeper启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/zookeeper/zookeeper-3.4.11-0</div><div class="line">bin/zkServer.sh start conf/zoo.cfg</div></pre></td></tr></table></figure>
<h3 id="ZooKeeper停止"><a href="#ZooKeeper停止" class="headerlink" title="ZooKeeper停止"></a>ZooKeeper停止</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/zkServer.sh stop</div></pre></td></tr></table></figure>
<h3 id="ZooKeeper状态查询"><a href="#ZooKeeper状态查询" class="headerlink" title="ZooKeeper状态查询"></a>ZooKeeper状态查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/zkServer.sh status</div></pre></td></tr></table></figure>
<h2 id="ZooKeeper批量操作脚本"><a href="#ZooKeeper批量操作脚本" class="headerlink" title="ZooKeeper批量操作脚本"></a>ZooKeeper批量操作脚本</h2><p>在<code>~/zookeeper</code>新建一个文件夹<code>scripts</code>以存放脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ ls</div><div class="line">zoo-start-all.sh  zoo-status-all.sh  zoo-stop-all.sh</div></pre></td></tr></table></figure>
<p><code>zoo-start-all.sh</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">ZK_HOME_0=/home/lizh/zookeeper/zookeeper-3.4.11-0</div><div class="line">ZK_HOME_1=/home/lizh/zookeeper/zookeeper-3.4.11-1</div><div class="line">ZK_HOME_2=/home/lizh/zookeeper/zookeeper-3.4.11-2</div><div class="line"></div><div class="line">$ZK_HOME_0/bin/zkServer.sh start $ZK_HOME_0/conf/zoo.cfg</div><div class="line">$ZK_HOME_1/bin/zkServer.sh start $ZK_HOME_1/conf/zoo.cfg</div><div class="line">$ZK_HOME_2/bin/zkServer.sh start $ZK_HOME_2/conf/zoo.cfg</div><div class="line"></div><div class="line">jps</div></pre></td></tr></table></figure>
<p><code>zoo-stop-all.sh</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">ZK_HOME_0=/home/lizh/zookeeper/zookeeper-3.4.11-0</div><div class="line">ZK_HOME_1=/home/lizh/zookeeper/zookeeper-3.4.11-1</div><div class="line">ZK_HOME_2=/home/lizh/zookeeper/zookeeper-3.4.11-2</div><div class="line"></div><div class="line">$ZK_HOME_0/bin/zkServer.sh stop</div><div class="line">$ZK_HOME_1/bin/zkServer.sh stop</div><div class="line">$ZK_HOME_2/bin/zkServer.sh stop</div><div class="line"></div><div class="line">jps</div></pre></td></tr></table></figure></p>
<p><code>zoo-status-all.sh</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">ZK_HOME_0=/home/lizh/zookeeper/zookeeper-3.4.11-0</div><div class="line">ZK_HOME_1=/home/lizh/zookeeper/zookeeper-3.4.11-1</div><div class="line">ZK_HOME_2=/home/lizh/zookeeper/zookeeper-3.4.11-2</div><div class="line"></div><div class="line">$ZK_HOME_0/bin/zkServer.sh status</div><div class="line">$ZK_HOME_1/bin/zkServer.sh status</div><div class="line">$ZK_HOME_2/bin/zkServer.sh status</div><div class="line"></div><div class="line">jps</div></pre></td></tr></table></figure></p>
<p>并将路径<code>~/zookeeper/scripts</code>添加到<code>PATH</code>中，便可方便地批量启动、停止、查看ZooKeeper的状态。</p>
<h2 id="ZooKeeper启动与状态"><a href="#ZooKeeper启动与状态" class="headerlink" title="ZooKeeper启动与状态"></a>ZooKeeper启动与状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜ zoo-start-all.sh</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-0/conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-1/conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-2/conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div><div class="line">27895 QuorumPeerMain</div><div class="line">27752 QuorumPeerMain</div><div class="line">27821 QuorumPeerMain</div></pre></td></tr></table></figure>
<p>可以看到ZooKeeper启动了三个<code>QuorumPeerMain</code>进程。因为ZooKeeper采用投票机制选举Leader，因此至少需要启动三个进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜ zoo-status-all.sh</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-0/bin/../conf/zoo.cfg</div><div class="line">Mode: follower</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-1/bin/../conf/zoo.cfg</div><div class="line">Mode: leader</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-2/bin/../conf/zoo.cfg</div><div class="line">Mode: follower</div><div class="line">27895 QuorumPeerMain</div><div class="line">27752 QuorumPeerMain</div><div class="line">27821 QuorumPeerMain</div></pre></td></tr></table></figure>
<p>一个ZooKeeper集群中有且仅能有一个投票选出的Leader，其它都是Learner(包括ObServer和Follower)。此时Client可以通过端口2181~2183连接任意一个ZooKeeper:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">➜ ~/zookeeper/zookeeper-3.4.11-0/bin/zkCli.sh -server 127.0.0.1:2181</div><div class="line">...</div><div class="line">[zk: 127.0.0.1:2181(CONNECTED) 0] help</div><div class="line">ZooKeeper -server host:port cmd args</div><div class="line">        stat path [watch]</div><div class="line">        set path data [version]</div><div class="line">        ls path [watch]</div><div class="line">        delquota [-n|-b] path</div><div class="line">        ls2 path [watch]</div><div class="line">        setAcl path acl</div><div class="line">        setquota -n|-b val path</div><div class="line">        history</div><div class="line">        redo cmdno</div><div class="line">        printwatches on|off</div><div class="line">        delete path [version]</div><div class="line">        sync path</div><div class="line">        listquota path</div><div class="line">        rmr path</div><div class="line">        get path [watch]</div><div class="line">        create [-s] [-e] path data acl</div><div class="line">        addauth scheme auth</div><div class="line">        quit</div><div class="line">        getAcl path</div><div class="line">        close</div><div class="line">        connect host:port</div><div class="line">[zk: 127.0.0.1:2181(CONNECTED) 1]</div></pre></td></tr></table></figure>
<h1 id="安装Hadoop"><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h1><p>在<a href="http://hadoop.apache.org/releases.html" target="_blank" rel="external">Hadoop官网</a>下载较新版本的Hadoop binary版本。作者使用的Hadoop 3.0.0。假设解压到用户目录<code>~/hadoop-3.0.0</code>。</p>
<p>进入Hadoop根目录后，首先需要配置JAVA_HOME:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ vim etc/hadoop/hadoop-env.sh</div><div class="line">...</div><div class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_111</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>查看Hadoop是否能正常运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜ hadoop version</div><div class="line">Hadoop 3.0.0</div><div class="line">Source code repository https://git-wip-us.apache.org/repos/asf/hadoop.git -r c25427ceca461ee979d30edd7a4b0f50718e6533</div><div class="line">Compiled by andrew on 2017-12-08T19:16Z</div><div class="line">Compiled with protoc 2.5.0</div><div class="line">From source with checksum 397832cb5529187dc8cd74ad54ff22</div><div class="line">This command was run using /home/lizh/hadoop-3.0.0/share/hadoop/common/hadoop-common-3.0.0.jar</div></pre></td></tr></table></figure></p>
<h2 id="添加Hadoop可执行文件路径到PATH"><a href="#添加Hadoop可执行文件路径到PATH" class="headerlink" title="添加Hadoop可执行文件路径到PATH"></a>添加Hadoop可执行文件路径到PATH</h2><p>在<code>~/.bashrc</code>中添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Hadoop</div><div class="line">export HADOOP_HOME=~/hadoop-3.0.0</div><div class="line">export HADOOP_MAPRED_HOME=$HADOOP_HOME</div><div class="line">export PATH=$PATH:$HADOOP_HOME/bin</div><div class="line">export PATH=$PATH:$HADOOP_HOME/sbin</div></pre></td></tr></table></figure></p>
<p>以便快捷使用Hadoop可执行程序<code>bin/*</code>与脚本<code>sbin/*</code>。</p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><h3 id="log4j-properties"><a href="#log4j-properties" class="headerlink" title="log4j.properties"></a>log4j.properties</h3><p>修改<code>etc/hadoop/log4j.properties</code>文件中的<code>hadoop.root.logger</code>可控制输出日志级别。</p>
<h3 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h3><p><code>etc/hadoop/core-site.xml</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;fs.defaultFS&lt;/name&gt;</div><div class="line">&lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;</div><div class="line">&lt;value&gt;localhost:2181,localhost:2182,localhost:2183&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<h3 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h3><p><code>etc/hadoop/mapred-site.xml</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;mapreduce.framework.name&lt;/name&gt;</div><div class="line">&lt;value&gt;yarn&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt;</div><div class="line">&lt;value&gt;HADOOP_MAPRED_HOME=$HADOOP_MAPRED_HOME&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;mapreduce.map.env&lt;/name&gt;</div><div class="line">&lt;value&gt;HADOOP_MAPRED_HOME=$HADOOP_MAPRED_HOME&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;mapreduce.reduce.env&lt;/name&gt;</div><div class="line">&lt;value&gt;HADOOP_MAPRED_HOME=$HADOOP_MAPRED_HOME&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<h3 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h3><p><code>etc/hadoop/hdfs-site.xml</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;dfs.replication&lt;/name&gt;</div><div class="line">&lt;value&gt;1&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;dfs.http.address&lt;/name&gt;</div><div class="line">&lt;value&gt;0.0.0.0:50070&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;dfs.namenode.datanode.registration.ip-hostname-check&lt;/name&gt;</div><div class="line">&lt;value&gt;true&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<h3 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h3><p><code>etc/hadoop/yarn-site.xml</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.resourcemanager.zk-address&lt;/name&gt;</div><div class="line">&lt;value&gt;master:2181,slave1:2181,slave2:2181&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</div><div class="line">&lt;value&gt;mapreduce_shuffle&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<h3 id="workers"><a href="#workers" class="headerlink" title="workers"></a>workers</h3><p><code>etc/hadoop/workers</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">localhost</div></pre></td></tr></table></figure></p>
<p>注意: 若workers中直接指定服务器IP，则需要将<code>hdfs-site.xml</code>中的<code>dfs.namenode.datanode.registration.ip-hostname-check</code>指定为<code>false</code>。</p>
<p>注意: 在全分布模式下，若需要在workers中使用主机名，参考之前的文章<a href="https://lizonghang.github.io/2018/01/09/Ubuntu设置静态IP与主机名/">Ubuntu设置静态IP与主机名</a>。</p>
<h2 id="开启SSH免密登录"><a href="#开启SSH免密登录" class="headerlink" title="开启SSH免密登录"></a>开启SSH免密登录</h2><p>注意: 若为全分布模式，每两对主机之间都需要配置SSH免密；若为伪分布模式，能够<code>ssh localhost</code>即可。</p>
<h3 id="OSX系统"><a href="#OSX系统" class="headerlink" title="OSX系统"></a>OSX系统</h3><p>默认安装有sshd，需要在”系统偏好设置—&gt;共享”中打开远程登录，并将本机<code>~/.ssh/id_rsa.pub</code>添加到<code>~/.ssh/authorized_keys</code>，确认<code>ssh localhost</code>能够免密登录。</p>
<h3 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h3><p>确认系统是否按照有sshd服务，若没有，需要安装openssh-server，开启sshd服务，并将本机<code>~/.ssh/id_rsa.pub</code>添加到<code>~/.ssh/authorized_keys</code>，确认<code>ssh localhost</code>能够免密登录。</p>
<h2 id="启动Hadoop伪分布集群"><a href="#启动Hadoop伪分布集群" class="headerlink" title="启动Hadoop伪分布集群"></a>启动Hadoop伪分布集群</h2><h3 id="格式化NameNode"><a href="#格式化NameNode" class="headerlink" title="格式化NameNode"></a>格式化NameNode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ hdfs namenode -format</div></pre></td></tr></table></figure>
<p>注意: 若曾多次格式化，可能出现版本冲突导致DataNode无法启动(版本遗留问题)，删除<code>/tmp/hadoop-lizh/dfs/name/current</code>后重新格式化并启动即可。</p>
<h3 id="启动DFS与YARN"><a href="#启动DFS与YARN" class="headerlink" title="启动DFS与YARN"></a>启动DFS与YARN</h3><h4 id="一次性启动"><a href="#一次性启动" class="headerlink" title="一次性启动"></a>一次性启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">➜ start-all.sh</div><div class="line">WARNING: Attempting to start all Apache Hadoop daemons as lizh in 10 seconds.</div><div class="line">WARNING: This is not a recommended production deployment configuration.</div><div class="line">WARNING: Use CTRL-C to abort.</div><div class="line">Starting namenodes on [localhost]</div><div class="line">Starting datanodes</div><div class="line">Starting secondary namenodes [Slave8]</div><div class="line">Starting resourcemanager</div><div class="line">Starting nodemanagers</div><div class="line">➜ jps</div><div class="line">30450 NameNode</div><div class="line">31381 ResourceManager</div><div class="line">27895 QuorumPeerMain</div><div class="line">31000 SecondaryNameNode</div><div class="line">27752 QuorumPeerMain</div><div class="line">30649 DataNode</div><div class="line">31757 NodeManager</div><div class="line">27821 QuorumPeerMain</div><div class="line">32109 Jps</div></pre></td></tr></table></figure>
<h4 id="分别启动"><a href="#分别启动" class="headerlink" title="分别启动"></a>分别启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">➜ start-dfs.sh</div><div class="line">Starting namenodes on [localhost]</div><div class="line">Starting datanodes</div><div class="line">Starting secondary namenodes [Slave8]</div><div class="line">➜ jps</div><div class="line">33760 DataNode</div><div class="line">34353 Jps</div><div class="line">27895 QuorumPeerMain</div><div class="line">33559 NameNode</div><div class="line">27752 QuorumPeerMain</div><div class="line">27821 QuorumPeerMain</div><div class="line">34109 SecondaryNameNode</div><div class="line">➜ start-yarn.sh</div><div class="line">Starting resourcemanager</div><div class="line">Starting nodemanagers</div><div class="line">➜ jps</div><div class="line">33760 DataNode</div><div class="line">35268 Jps</div><div class="line">27895 QuorumPeerMain</div><div class="line">33559 NameNode</div><div class="line">27752 QuorumPeerMain</div><div class="line">34552 ResourceManager</div><div class="line">27821 QuorumPeerMain</div><div class="line">34109 SecondaryNameNode</div><div class="line">34926 NodeManager</div></pre></td></tr></table></figure>
<h3 id="查看Hadoop集群是否正常启动"><a href="#查看Hadoop集群是否正常启动" class="headerlink" title="查看Hadoop集群是否正常启动"></a>查看Hadoop集群是否正常启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">➜ hdfs dfsadmin -report</div><div class="line">Configured Capacity: 226804576256 (211.23 GB)</div><div class="line">Present Capacity: 168025718784 (156.49 GB)</div><div class="line">DFS Remaining: 168025432064 (156.49 GB)</div><div class="line">DFS Used: 286720 (280 KB)</div><div class="line">DFS Used%: 0.00%</div><div class="line">Replicated Blocks:</div><div class="line">Under replicated blocks: 0</div><div class="line">Blocks with corrupt replicas: 0</div><div class="line">Missing blocks: 0</div><div class="line">Missing blocks (with replication factor 1): 0</div><div class="line">Pending deletion blocks: 0</div><div class="line">Erasure Coded Block Groups:</div><div class="line">Low redundancy block groups: 0</div><div class="line">Block groups with corrupt internal blocks: 0</div><div class="line">Missing block groups: 0</div><div class="line">Pending deletion blocks: 0</div><div class="line"></div><div class="line">-------------------------------------------------</div><div class="line">Live datanodes (1):</div><div class="line"></div><div class="line">Name: 127.0.0.1:9866 (localhost)</div><div class="line">Hostname: Slave8</div><div class="line">Decommission Status : Normal</div><div class="line">Configured Capacity: 226804576256 (211.23 GB)</div><div class="line">DFS Used: 286720 (280 KB)</div><div class="line">Non DFS Used: 47234248704 (43.99 GB)</div><div class="line">DFS Remaining: 168025432064 (156.49 GB)</div><div class="line">DFS Used%: 0.00%</div><div class="line">DFS Remaining%: 74.08%</div><div class="line">Configured Cache Capacity: 0 (0 B)</div><div class="line">Cache Used: 0 (0 B)</div><div class="line">Cache Remaining: 0 (0 B)</div><div class="line">Cache Used%: 100.00%</div><div class="line">Cache Remaining%: 0.00%</div><div class="line">Xceivers: 1</div><div class="line">Last contact: Tue Jan 09 19:36:16 CST 2018</div><div class="line">Last Block Report: Tue Jan 09 19:31:49 CST 2018</div></pre></td></tr></table></figure>
<h3 id="查看Web端口是否开启服务"><a href="#查看Web端口是否开启服务" class="headerlink" title="查看Web端口是否开启服务"></a>查看Web端口是否开启服务</h3><ul>
<li>50070端口查看HDFS信息。</li>
<li>8088端口查看ResourceManager信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜ netstat -tpnl | grep 50070</div><div class="line">(Not all processes could be identified, non-owned process info</div><div class="line">will not be shown, you would have to be root to see it all.)</div><div class="line">tcp        0      0 127.0.0.1:50070         0.0.0.0:*               LISTEN      33559/java</div><div class="line">➜ netstat -tpnl | grep 8088</div><div class="line">(Not all processes could be identified, non-owned process info</div><div class="line">will not be shown, you would have to be root to see it all.)</div><div class="line">tcp        0      0 0.0.0.0:8088            0.0.0.0:*               LISTEN      34552/java</div></pre></td></tr></table></figure>
<p>浏览器访问<code><a href="http://localhost:50070" target="_blank" rel="external">http://localhost:50070</a></code>和<code><a href="http://localhost:8088" target="_blank" rel="external">http://localhost:8088</a></code>可进入Web页面。</p>
<p>注意: 全分布模式下50070端口需要由<code><a href="http://master:50070" target="_blank" rel="external">http://master:50070</a></code>访问，8088端口需要在开启了ResourceManager的主机(即DataNode)<code><a href="http://slave:8088" target="_blank" rel="external">http://slave:8088</a></code>访问。</p>
<p>注意: 若使用YARN作为资源管理器，但没有开启ZooKeeper，可能会导致8088端口无法访问。</p>
<h2 id="关闭Hadoop集群"><a href="#关闭Hadoop集群" class="headerlink" title="关闭Hadoop集群"></a>关闭Hadoop集群</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜ stop-all.sh</div><div class="line">WARNING: Stopping all Apache Hadoop daemons as lizh in 10 seconds.</div><div class="line">WARNING: Use CTRL-C to abort.</div><div class="line">Stopping namenodes on [localhost]</div><div class="line">Stopping datanodes</div><div class="line">Stopping secondary namenodes [Slave8]</div><div class="line">Stopping nodemanagers</div><div class="line">Stopping resourcemanager</div><div class="line">➜ jps</div><div class="line">27895 QuorumPeerMain</div><div class="line">27752 QuorumPeerMain</div><div class="line">36745 Jps</div><div class="line">27821 QuorumPeerMain</div></pre></td></tr></table></figure>
<h1 id="HDFS文件操作指令与MapReduce测试"><a href="#HDFS文件操作指令与MapReduce测试" class="headerlink" title="HDFS文件操作指令与MapReduce测试"></a>HDFS文件操作指令与MapReduce测试</h1><h2 id="HDFS文件操作指令"><a href="#HDFS文件操作指令" class="headerlink" title="HDFS文件操作指令"></a>HDFS文件操作指令</h2><p>文件指令格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop fs &lt;args&gt;</div></pre></td></tr></table></figure></p>
<p>详细指令可参考<a href="http://hadoop.apache.org/docs/r3.0.0/hadoop-project-dist/hadoop-common/FileSystemShell.html" target="_blank" rel="external">Hadoop 3.0.0官方文档</a></p>
<p>可通过<code>hadoop fs -help ls</code>查看指令描述:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">➜ hadoop fs -help ls</div><div class="line">-ls [-C] [-d] [-h] [-q] [-R] [-t] [-S] [-r] [-u] [-e] [&lt;path&gt; ...] :</div><div class="line">List the contents that match the specified file pattern. If path is not</div><div class="line">specified, the contents of /user/&lt;currentUser&gt; will be listed. For a directory a</div><div class="line">list of its direct children is returned (unless -d option is specified).</div><div class="line"></div><div class="line">Directory entries are of the form:</div><div class="line">permissions - userId groupId sizeOfDirectory(in bytes)</div><div class="line">modificationDate(yyyy-MM-dd HH:mm) directoryName</div><div class="line"></div><div class="line">and file entries are of the form:</div><div class="line">permissions numberOfReplicas userId groupId sizeOfFile(in bytes)</div><div class="line">modificationDate(yyyy-MM-dd HH:mm) fileName</div><div class="line"></div><div class="line">-C  Display the paths of files and directories only.</div><div class="line">-d  Directories are listed as plain files.</div><div class="line">-h  Formats the sizes of files in a human-readable fashion</div><div class="line">rather than a number of bytes.</div><div class="line">-q  Print ? instead of non-printable characters.</div><div class="line">-R  Recursively list the contents of directories.</div><div class="line">-t  Sort files by modification time (most recent first).</div><div class="line">-S  Sort files by size.</div><div class="line">-r  Reverse the order of the sort.</div><div class="line">-u  Use time of last access instead of modification for</div><div class="line">display and sorting.</div><div class="line">-e  Display the erasure coding policy of files and directories.</div></pre></td></tr></table></figure></p>
<p>例如使用<code>hadoop fs -ls -R /</code>可递归显示根目录下所有文件。</p>
<h2 id="MapReduce测试"><a href="#MapReduce测试" class="headerlink" title="MapReduce测试"></a>MapReduce测试</h2><ol>
<li><p>在Hadoop文件系统中创建用户文件夹，注意user为当前登录用户名，此处作者的用户名为lizh。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ hadoop fs -ls /</div><div class="line">➜ hadoop fs -mkdir -p /user/lizh</div><div class="line">➜ hadoop fs -ls -R /</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-09 20:02 /user</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-09 20:02 /user/lizh</div></pre></td></tr></table></figure>
</li>
<li><p>上传本地文本文件到HDFS(可以将hadoop-3.0.0/NOTICE.txt作为测试文本)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ hadoop fs -put hadoop-3.0.0/NOTICE.txt .</div><div class="line">➜ hadoop fs -ls</div><div class="line">Found 1 items</div><div class="line">-rw-r--r--   1 lizh supergroup      20891 2018-01-09 20:05 NOTICE.txt</div></pre></td></tr></table></figure>
</li>
</ol>
<p><code>-put hadoop-3.0.0/NOTICE.txt .</code>表示将本地NOTICE.txt文件上传到HDFS的用户主目录<code>/user/lizh</code>下，以<code>.</code>表示。当<code>-ls</code>不带路径时，默认为用户主目录。这就是必须创建路径<code>/user/username</code>而不是随意新建的原因。</p>
<ol>
<li>使用Hadoop自带测试程序wordcount来测试集群是否能够正常工作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">➜ hadoop jar hadoop-3.0.0/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.0.0.jar wordcount ./NOTICE.txt ./out/</div><div class="line">...</div><div class="line">➜ hadoop fs -ls</div><div class="line">Found 2 items</div><div class="line">-rw-r--r--   1 lizh supergroup      20891 2018-01-09 20:05 NOTICE.txt</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-09 20:09 out</div><div class="line">➜ hadoop fs -ls out</div><div class="line">Found 2 items</div><div class="line">-rw-r--r--   1 lizh supergroup          0 2018-01-09 20:09 out/_SUCCESS</div><div class="line">-rw-r--r--   1 lizh supergroup      11905 2018-01-09 20:09 out/part-r-00000</div></pre></td></tr></table></figure>
</li>
</ol>
<p>程序将输出结果输出到了<code>/user/lizh/out<code>文件夹，也表明集群是正常工作的。可通过<code>hadoop fs -cat ./out/part-r-00000</code>查看输出结果:</code></code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">➜  ~ hadoop fs -cat ./out/part-r-00000</div><div class="line">&quot;AS    1</div><div class="line">&quot;GCC    1</div><div class="line">&quot;Java    1</div><div class="line">&quot;License&quot;);    1</div><div class="line">#    6</div><div class="line">&amp;    1</div><div class="line">&apos;Aalto    1</div><div class="line">&apos;Apache    4</div><div class="line">&apos;ArrayDeque&apos;,    1</div><div class="line">&apos;Bouncy    1</div><div class="line">...</div></pre></td></tr></table></figure>
<p>注意: 该步骤对于DataNode内存要求较高，虚拟机难以满足其内存需求，因此建议在单机上运行伪分布模式来测试。</p>
<p>至此，一个简易的Hadoop伪分布集群(1个NameNode，1个DataNode)就部署完成了。通过伪分布式仅是用于调试与测试，后续文章中将会讲到全分布模式的部署以及在全分布模式下如何动态增加DataNode到集群等。</p>
]]></content>
      
        <categories>
            
            <category> Hadoop/Spark </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[保持SSH长期连接]]></title>
      <url>http://lizonghang.github.io/2018/01/09/%E4%BF%9D%E6%8C%81SSH%E9%95%BF%E6%9C%9F%E8%BF%9E%E6%8E%A5/</url>
      <content type="html"><![CDATA[<p>为避免长时间无数据传输导致网络中间节点断开SSH连接的问题，在SSH服务端或客户端开启心跳报文。</p>
<ol>
<li>在客户端<code>/etc/ssh/ssh_config</code>添加<code>ServerAliveInterval 60</code>。</li>
<li>在服务端<code>/etc/ssh/sshd_config</code>添加<code>ClientAliveInterval 60</code>后重启SSH服务。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 服务器/后台 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu设置静态IP与主机名]]></title>
      <url>http://lizonghang.github.io/2018/01/09/Ubuntu%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%90%8D/</url>
      <content type="html"><![CDATA[<h1 id="设置静态IP与DNS服务器"><a href="#设置静态IP与DNS服务器" class="headerlink" title="设置静态IP与DNS服务器"></a>设置静态IP与DNS服务器</h1><p>假设子网为10.211.55.0。</p>
<p>编辑<code>/etc/network/interfaces</code>文件，添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">auto eth1</div><div class="line">iface eth1 inet static</div><div class="line">address 10.211.55.3</div><div class="line">netmask 255.255.255.0</div><div class="line">network 10.211.55.0</div><div class="line">broadcast 10.211.55.255</div><div class="line">gateway 10.211.55.1</div></pre></td></tr></table></figure>
<p>为了使主机能够上外网，确认是否指定了DNS服务器，编辑<code>/etc/resolvconf/resolv.conf.d/base</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nameserver 8.8.8.8</div></pre></td></tr></table></figure>
<p>编辑完成后，重新读取配置文件并重启网络：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo resolvconf -u</div><div class="line">sudo /etc/init.d/networking restart</div></pre></td></tr></table></figure>
<h1 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h1><p>使用命令<code>hostname</code>可查看当前主机名，编辑文件<code>/etc/hostname</code>后重启主机可修改主机名。假设有两台主机名为master和slave的主机，在修改域名映射关系后可在master上直接通过主机名访问slave提供的服务，如浏览器直接输入<code><a href="http://slave:8088" target="_blank" rel="external">http://slave:8088</a></code>。</p>
<p>假设IP-A(master)=10.211.55.3，IP-B(slave)=10.211.55.4，在A和B的<code>/etc/hosts</code>文件里都添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">10.211.55.3 master</div><div class="line">10.211.55.4 slave</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 服务器/后台 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[AliCloud-Ubuntu-Server-With-IPv6]]></title>
      <url>http://lizonghang.github.io/2016/12/09/AliCloud-Ubuntu-Server-With-IPv6/</url>
      <content type="html"><![CDATA[<h1 id="Ubuntu支持IPv6"><a href="#Ubuntu支持IPv6" class="headerlink" title="Ubuntu支持IPv6"></a>Ubuntu支持IPv6</h1><p>阿里云服务器默认是不支持IPv6协议的，需要修改<code>/etc/sysctl.conf</code>文件解除对IPv6的禁止:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">net.ipv6.conf.all.disable_ipv6 = 0</div><div class="line">net.ipv6.conf.default.disable_ipv6 = 0</div><div class="line">net.ipv6.conf.lo.disable_ipv6 = 0</div></pre></td></tr></table></figure>
<p>修改完成后，启用新的配置，为服务器分配公网IPv6地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># sysctl -p</div></pre></td></tr></table></figure>
<p>使用命令<code>ifconfig</code>应该可以在公网IPv4对应的网卡中找到对应的IPv6地址，若没有重启服务器。</p>
<h1 id="nginx支持并监听IPv6的80端口"><a href="#nginx支持并监听IPv6的80端口" class="headerlink" title="nginx支持并监听IPv6的80端口"></a>nginx支持并监听IPv6的80端口</h1><p>首先查看当前的nginx是否支持IPv6协议，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nginx -V</div></pre></td></tr></table></figure>
<p>若输出的<code>configure arguments</code>中含有<code>—-with-ipv6</code>，则当前nginx支持IPv6协议，否则需要重新编译安装nginx，编译nginx时需要加上<code>—-with-ipv6</code>。</p>
<p>确认当前nginx支持ipv6后，修改<code>nginx.conf</code>中的server段，除了监听IPv4的80端口外还需要监听IPv6的80端口,若有需要还需要监听HTTPS协议的IPv6的443端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 80; // 监听IPv4的80端口,HTTP协议</div><div class="line">    listen [::]:80; // 监听IPv6的80端口,HTTP协议</div><div class="line">    ……</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen 443; // 监听IPv4的443端口,HTTPS协议</div><div class="line">    listen [::]:443; // 监听IPv6的443端口,HTTPS协议</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="申请IPv6中转隧道"><a href="#申请IPv6中转隧道" class="headerlink" title="申请IPv6中转隧道"></a>申请IPv6中转隧道</h1><p>由于国内阿里云不提供IPv6服务，实现IPv6需要申请中转服务，可以使用<a href="https://tunnelbroker.net" target="_blank" rel="external">tunnelbroker.net</a>提供的中转服务。</p>
<ol>
<li>在tunnelbroker.net注册一个账号</li>
<li>登录后进入左侧导航栏中的<code>Create Regular Tunnel</code>，在<code>IPv4 Endpoint</code>输入你的服务器的外网IPv4地址，选择<code>Hong Kong,HK</code>隧道服务器，创建一个新的ipv6隧道</li>
<li>创建好隧道后跳转到了Tunnel Details页，IPv6 Tunnel页是隧道的基本信息，你需要验证的是<code>Client IPv4 Address</code>是否为你的服务器外网IPv4地址，需要记录<code>Client IPv6 Address</code>对应的中转IPv6地址。</li>
<li>转到Example Configurations页，选择服务器操作系统类型，比如我的服务器使用的是Ubuntu，所以选择<code>Debian/Ubuntu</code>。按要求复制文本框中的内容并粘贴到服务器上对应的文件内。例如：</li>
</ol>
<p>Paste the following into /etc/network/interfaces:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">auto he-ipv6</div><div class="line">iface he-ipv6 inet6 v4tunnel</div><div class="line">        address 2001:470:18:8cb::2</div><div class="line">        netmask 64</div><div class="line">        endpoint 216.218.221.6</div><div class="line">        local 114.215.121.63</div><div class="line">        ttl 255</div><div class="line">        gateway 2001:470:18:8cb::1</div></pre></td></tr></table></figure>
<p>我们就需要将以上he-ipv6的网卡信息写入网卡配置文件<code>/etc/network/interfaces</code>中，保存后使用以下命令启动网卡:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/networking restart</div></pre></td></tr></table></figure>
<p>重启服务器后使用命令<code>ifconfig</code>应当可以看到新增了的he-ipv6网卡。</p>
<h1 id="检查防火墙规则"><a href="#检查防火墙规则" class="headerlink" title="检查防火墙规则"></a>检查防火墙规则</h1><p>要确保防火墙没有丢弃IPv6报文的规则，若服务器没有防火墙的相关需求，可简单的通过下述方式检查防火墙规则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root@iZ28zgwg61iZ:~# iptables -nL</div><div class="line">Chain INPUT (policy ACCEPT)</div><div class="line">target     prot opt source               destination</div><div class="line"></div><div class="line">Chain FORWARD (policy ACCEPT)</div><div class="line">target     prot opt source               destination</div><div class="line"></div><div class="line">Chain OUTPUT (policy ACCEPT)</div><div class="line">target     prot opt source               destination</div></pre></td></tr></table></figure>
<p>这是一个没有设置任何规则的防火墙，对于接收、发出、转发的报文的默认策略都是ACCEPT，在这种环境下IPv6报文不受影响。</p>
<p>若需要设置一些过滤规则最好将INPUT、OUTPUT链的默认策略设置为ACCEPT，保证IPv6报文能正常收发或作一些合理的过滤，参阅相关书籍谨慎设置，不熟悉iptables的话建议先熟悉了再到VPS上设置，或者简单的将所有规则清除并设置默认策略为ACCEPT，否则很可能将自己与服务器之间的连接断开，那就只有联系机房管理员清除了。</p>
<h1 id="添加AAAA域名解析"><a href="#添加AAAA域名解析" class="headerlink" title="添加AAAA域名解析"></a>添加AAAA域名解析</h1><p>进入阿里云的管理控制台，进入云解析DNS，选择相应的域名，添加一条AAAA解析，记录值填写之前记录的<code>Client IPv6 Address</code>中记录的IPv6地址。保存后等待几分钟，等DNS服务器刷新记录。</p>
<p>注意：AAAA解析的记录值填用于中转的IPv6地址，即网卡he-ipv6中的<code>Scope:Global</code>对应的IPv6地址，而不是由第一步生成的服务器本身的外网IPv6地址。</p>
<h1 id="验证IPv6网络是否有效"><a href="#验证IPv6网络是否有效" class="headerlink" title="验证IPv6网络是否有效"></a>验证IPv6网络是否有效</h1><p>在<a href="http://ipv6-test.com/validate.php" target="_blank" rel="external">ipv6-test</a>网站中输入域名验证，若<code>AAAA DNS record</code>和<code>IPv6 web server</code>都验证通过就可以判断IPv6网络是有效的，也可以使用国外的服务器使用命令<code>ping6</code>或命令<code>curl -6</code>查看是否有返回数据。</p>
<p>注意：不建议使用国内网络测试服务器IPv6环境是否有效，因为国内大多数服务器不支持IPv6，测试者所在的网络也不一定支持IPv6网络，因此建议使用国外服务器进行测试。</p>
]]></content>
      
        <categories>
            
            <category> 服务器/后台 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[CORS跨站请求与https服务器配置]]></title>
      <url>http://lizonghang.github.io/2016/09/27/CORS%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%B8%8Ehttps%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="CORS跨站资源共享"><a href="#CORS跨站资源共享" class="headerlink" title="CORS跨站资源共享"></a>CORS跨站资源共享</h1><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>很多习惯了自己做网站的后台开发者在初次与前端或移动端合作开发时，常常遇到这么一个问题: 后台所开发出的 API 都是经过 Postman 或其他接口测试工具测试过，确认提供的这些 API 并没有异常后，将这些 API 整理成文档发给前端，但是前端的小伙伴并不能成功访问到这些接口，而是会报错: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">XMLHttpRequest cannot load http://www.desckie.com/iwantrent/getAllProduct</div><div class="line">/. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested re</div><div class="line">source. Origin &apos;http://www.puahome.com&apos; is therefore not allowed access.</div></pre></td></tr></table></figure>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这是由于浏览器安全的基石是”同源政策”，同源指是协议相同、域名相同、端口相同。同源政策的目的是为了保证用户信息的安全，防止恶意网站窃取数据。因此现在我们用 JS 或 AJAX 进行跨站请求时，由于浏览器的同源原则，使得 <code>XMLHttpRequest</code> 不能跨域通讯。</p>
<p>为了实现跨域有多种做法，其中一种较为优雅的是使用 <code>JSONP</code> 方案，但 <code>JSONP</code> 仅限于 <code>GET</code> 方法，局限性较大。</p>
<p>报错信息中有这么一句话: <code>No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</code>。请求的资源中没有 <code>‘Access-Control-Allow-Origin’</code> 请求头，它指定服务器端允许进行跨域资源访问的来源域，允许任何域的 Javascript 访问资源的方式为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Accesss-Control-Allow-Origin: *</div></pre></td></tr></table></figure>
<p>或指定具体的域可访问，如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://foo.example.com</div></pre></td></tr></table></figure>
<p>如此一来，除了 foo.example.com ，其他站点都不能跨站访问本站的资源。那么如何添加请求头呢？</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="直接处理请求头"><a href="#直接处理请求头" class="headerlink" title="直接处理请求头"></a>直接处理请求头</h3><p>在 Django 后台中我们可以通过简单的方式添加请求头，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">response[&apos;Access-Control-Allow-Origin&apos;] = &apos;*&apos;</div><div class="line">return response</div></pre></td></tr></table></figure>
<p>这也是实现跨站登录最基本的实现，但不推荐这种跨站访问方式。</p>
<h3 id="CORS跨站资源共享-1"><a href="#CORS跨站资源共享-1" class="headerlink" title="CORS跨站资源共享"></a>CORS跨站资源共享</h3><p>在 Django 中有CORS-header开源的中间件，利用这些现成的中间件，我们只需要在 settings.py 中做一些简单的配置即可实现 CORS 跨站资源共享，使得服务器端 API 完全开放，使得前后台能够较为独立的工作。</p>
<p>django-cors-headers开源项目地址为: <a href="https://github.com/ottoyiu/django-cors-headers/" target="_blank" rel="external">https://github.com/ottoyiu/django-cors-headers/</a></p>
<p>使用方法如下:</p>
<ol>
<li>安装django-cors-headers</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install django-cors-headers</div></pre></td></tr></table></figure>
<ol>
<li>将 corsheaders 加入 installed apps:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">INSTALLED_APPS = (</div><div class="line">    ...</div><div class="line">    &apos;corsheaders&apos;,</div><div class="line">    ...</div><div class="line">)</div></pre></td></tr></table></figure>
<ol>
<li>添加中间件类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">MIDDLEWARE_CLASSES = (</div><div class="line">    ...</div><div class="line">    &apos;corsheaders.middleware.CorsMiddleware&apos;,</div><div class="line">    &apos;django.middleware.common.CommonMiddleware&apos;,</div><div class="line">    ...</div><div class="line">)</div></pre></td></tr></table></figure>
<p><strong>Note</strong>: CorsMiddleware needs to come before Django’s CommonMiddleware if you are using Django’s <code>USE_ETAGS = True</code> setting, otherwise the CORS headers will be lost from the 304 not-modified responses, causing errors in some browsers.</p>
<ol>
<li>添加配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CORS_ORIGIN_ALLOW_ALL = True</div><div class="line">CORS_URLS_REGEX = r&apos;^/api/.*$&apos;</div><div class="line">CORS_ALLOW_METHODS = (&apos;GET&apos;, &apos;POST&apos;, &apos;PUT&apos;, &apos;DELETE&apos;, &apos;HEAD&apos;, &apos;PATCH&apos;, &apos;OPTIONS&apos;)</div></pre></td></tr></table></figure>
<p>生产环境中推荐使用白名单，此处为测试才设为全域。按照需要可以设置其他配置，具体设置见 <a href="https://github.com/ottoyiu/django-cors-headers/#configuration。" target="_blank" rel="external">https://github.com/ottoyiu/django-cors-headers/#configuration。</a></p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>重新用 JS 或 AJAX 跨站访问，没有出现 No ‘Access-Control-Allow-Origin’ header 报错。</p>
<h1 id="HTTPS-Nginx服务器部署"><a href="#HTTPS-Nginx服务器部署" class="headerlink" title="HTTPS Nginx服务器部署"></a>HTTPS Nginx服务器部署</h1><h2 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h2><p>跨站访问的问题解决了，再次测试又出现了新的错误，错误信息如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[blocked] The page at https://www.baidu.com/… was not allowed to display insecure content from http://www.desckie.com/iwantrent/getAllProduct/.</div></pre></td></tr></table></figure>
<h2 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h2><p>从报错信息上我们可以判断出，请求的网页被作为不安全的网页给浏览器阻塞了，原因就出在使用的协议为 http 协议。http 协议传输的数据在网络上为明文传输，容易被中间人窃取导致用户信息泄露，因此 http 协议实际上是不安全的。https 协议是 http 的安全版，即 http 下加入 SSL 层。要解决这个问题我们需要将协议更改为 https 协议。以 Nginx 服务器为例。</p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="申请-SSL-证书"><a href="#申请-SSL-证书" class="headerlink" title="申请 SSL 证书"></a>申请 SSL 证书</h3><p>这里我们使用自行颁发的免费 SSL 证书，它虽然能实现加密传输功能，但这类证书是不受浏览器信任的。用户在进入该网站时可能会出现提示: 此网站的安全证书有问题。但向专业机构申请 SSL 证书不仅需要出示相关证件，而且还要付费，所以我们这里就使用自行颁发的 SSL 证书。</p>
<ol>
<li>openssl genrsa -des3 -out api.bz.key 1024</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-96-46-ubuntu:~$ openssl genrsa -des3 -out api.bz.key 1024</div><div class="line">Generating RSA private key, 1024 bit long modulus</div><div class="line">............................++++++</div><div class="line">..............++++++</div><div class="line">e is 65537 (0x10001)</div><div class="line">Enter pass phrase for api.bz.key:</div><div class="line">Verifying - Enter pass phrase for api.bz.key:输入密码</div></pre></td></tr></table></figure>
<ol>
<li>openssl req -new -key api.bz.key -out api.bz.csr</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-96-46-ubuntu:~$ openssl req -new -key api.bz.key -out api.bz.csr</div><div class="line">Enter pass phrase for api.bz.key: 刚刚设置的密码</div><div class="line">You are about to be asked to enter information that will be incorporated</div><div class="line">into your certificate request.</div><div class="line">What you are about to enter is what is called a Distinguished Name or a DN.</div><div class="line">There are quite a few fields but you can leave some blank</div><div class="line">For some fields there will be a default value,</div><div class="line">If you enter &apos;.&apos;, the field will be left blank.</div><div class="line">-----</div><div class="line">Country Name (2 letter code) [AU]:CN</div><div class="line">State or Province Name (full name) [Some-State]:Beijing</div><div class="line">Locality Name (eg, city) []:Beijing</div><div class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:API.BZ</div><div class="line">Organizational Unit Name (eg, section) []:API.BZ</div><div class="line">Common Name (e.g. server FQDN or YOUR name) []:*.api.bz</div><div class="line">Email Address []:admin@api.bz</div><div class="line"></div><div class="line">Please enter the following &apos;extra&apos; attributes</div><div class="line">to be sent with your certificate request</div><div class="line">A challenge password []: 回车</div><div class="line">An optional company name []: 回车</div></pre></td></tr></table></figure>
<ol>
<li>openssl rsa -in api.bz.key -out api.bz_nopass.key</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-96-46-ubuntu:~$ openssl rsa -in api.bz.key -out api.bz_nopass.key</div><div class="line">Enter pass phrase for api.bz.key:</div><div class="line">writing RSA key</div></pre></td></tr></table></figure>
<ol>
<li>openssl req -new -x509 -days 3650 -key api.bz_nopass.key -out api.bz.crt</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-96-46-ubuntu:~$ openssl req -new -x509 -days 3650 -key api.bz_nopass.key -out api.bz.crt</div><div class="line">You are about to be asked to enter information that will be incorporated</div><div class="line">into your certificate request.</div><div class="line">What you are about to enter is what is called a Distinguished Name or a DN.</div><div class="line">There are quite a few fields but you can leave some blank</div><div class="line">For some fields there will be a default value,</div><div class="line">If you enter &apos;.&apos;, the field will be left blank.</div><div class="line">-----</div><div class="line">Country Name (2 letter code) [AU]:CN</div><div class="line">State or Province Name (full name) [Some-State]:Beijing</div><div class="line">Locality Name (eg, city) []:Beijing</div><div class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:API.BZ</div><div class="line">Organizational Unit Name (eg, section) []:API.BZ</div><div class="line">Common Name (e.g. server FQDN or YOUR name) []:*.api.bz</div><div class="line">Email Address []:admin@api.bz</div></pre></td></tr></table></figure>
<p>到这里 SSL 证书就申请好了，此时应该有四个文件，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-96-46-ubuntu:~$ ls</div><div class="line">api.bz.crt  api.bz.csr  api.bz.key  api.bz_nopass.key ...</div></pre></td></tr></table></figure>
<p>我们要用的是 <code>api.bz.crt</code> 和 <code>api.bz_nopass.key</code> 两个文件。</p>
<h3 id="更改-Nginx-配置"><a href="#更改-Nginx-配置" class="headerlink" title="更改 Nginx 配置"></a>更改 Nginx 配置</h3><p>在配置文件 nginx.conf 中的 server 字段中有这么一段被注释的 HTTPS 配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># HTTPS server</div><div class="line">#</div><div class="line"># server &#123;</div><div class="line">#   listen 443;</div><div class="line">#   server_name localhost;</div><div class="line">#</div><div class="line">#   root html;</div><div class="line">#   index index.html index.htm;</div><div class="line">#</div><div class="line">#   ssl on;</div><div class="line">#   ssl_certificate cert.pem;</div><div class="line">#   ssl_certificate_key cert.key;</div><div class="line">#</div><div class="line">#   ssl_session_timeout 5m;</div><div class="line">#</div><div class="line">#   ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">#   ssl_ciphers &quot;HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES&quot;;</div><div class="line">#   ssl_prefer_server_ciphers on;</div><div class="line">#</div><div class="line">#   location / &#123;</div><div class="line">#       try_files $uri $uri/ =404;</div><div class="line">#   &#125;</div><div class="line">#&#125;</div></pre></td></tr></table></figure>
<p>我们不需要使用其中所有的配置，根据 SSL 证书的路径修改相应的配置项(省去了注释项):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">        listen 443;</div><div class="line">        server_name sms.api.bz;</div><div class="line"></div><div class="line">        ssl on;</div><div class="line">        ssl_certificate /root/api.bz.crt;</div><div class="line">        ssl_certificate_key /root/api.bz_nopass.key;</div><div class="line">        </div><div class="line">        location / &#123;</div><div class="line">                include /etc/nginx/uwsgi_params;</div><div class="line">                uwsgi_pass 127.0.0.1:8077;</div><div class="line">                include /etc/nginx/mime.types;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        location ~* \.*(gif|png|jpg|jpeg|css|js|ttf|less)$ &#123;</div><div class="line">                root /root/RentMe;</div><div class="line">                access_log /root/nginx_access.log;</div><div class="line">                error_log /root/nginx_error.log;</div><div class="line">                include /etc/nginx/mime.types;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 location 可以从 HTTP 的配置项中复制过来。修改完成后，验证配置文件有效性并重启 nginx 服务器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@iZ28zgwg61iZ:~# /usr/sbin/nginx -t</div><div class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</div><div class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</div><div class="line">root@iZ28zgwg61iZ:~# /usr/sbin/nginx -s reload</div></pre></td></tr></table></figure>
<p>随后使用 https 方式进入你的网站，会先提示网站的安全证书有问题，无需理会。到这里网站就从 http 协议更换成 https 协议了，之后就可以用 https 方式更安全的访问网站。</p>
<h2 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h2><p>下图是从 leancloud.cn 通过 js 跨站访问的截图，没有出现跨站访问错误和安全警告，如图:</p>
<p><img src="/images/https.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 服务器/后台 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Getting Started With Videos]]></title>
      <url>http://lizonghang.github.io/2016/08/16/Getting-Started-With-Videos/</url>
      <content type="html"><![CDATA[<h1 id="Capture-Video-from-Camera"><a href="#Capture-Video-from-Camera" class="headerlink" title="Capture Video from Camera"></a>Capture Video from Camera</h1><p>To capture a video, you need to create a VideoCapture object. Its argument can be either the device index or the name of a video file. Device index is just the number to specify which camera. Normally one camera will be connected (as in my case). So I simply pass 0 (or -1). You can select the second camera by passing 1 and so on. After that, you can capture frame-by-frame. But at the end, don’t forget to release the capture. You can press ESC to quit.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">cap = cv2.VideoCapture(0)</div><div class="line">while True:</div><div class="line">    ret, frame = cap.read()</div><div class="line">    cv2.imshow(&apos;recording&apos;, frame)</div><div class="line">    if cv2.waitKey(25) == 27:</div><div class="line">        break</div><div class="line">cap.release()</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p><code>cap.read()</code> returns a bool (True/False). If frame is read correctly, it will be True. So you can check end of the video by checking this return value.</p>
<p>Sometimes, <code>cap</code> may not have initialized the capture. In that case, this code shows error. You can check whether it is initialized or not by the method <code>cap.isOpened()</code>. Otherwise open it using <code>cap.open()</code>.</p>
<p>You can also access some of the features of this video using <code>cap.get(propId)</code> method where propId is a number from 0 to 18. Each number denotes a property of the video (if it is applicable to that video) and full details can be seen in  <a href="http://docs.opencv.org/2.4/modules/highgui/doc/reading_and_writing_images_and_video.html#videocapture-get" target="_blank" rel="external">Property Identifier</a>. Some of these values can be modified using <code>cap.set(propId, value)</code>. Value is the new value you want.</p>
<p>For example, I can check the frame width and height by <code>cap.get(3)</code> and <code>cap.get(4)</code>. It gives me 640x480 by default. But I want to modify it to 320x240. Just use <code>ret = cap.set(3,320)</code> and <code>ret = cap.set(4,240)</code>.</p>
<p><strong>Note</strong>：If you are getting error, make sure camera is working fine using any other camera application (like Cheese in Linux).</p>
<h1 id="Playing-Video-from-file"><a href="#Playing-Video-from-file" class="headerlink" title="Playing Video from file"></a>Playing Video from file</h1><p>It is same as capturing from Camera, just change camera index with video file name. Also while displaying the frame, use appropriate time for cv2.waitKey(). If it is too less, video will be very fast and if it is too high, video will be slow (Well, that is how you can display videos in slow motion). 25 milliseconds will be OK in normal cases.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">cap = cv2.VideoCapture(&apos;video.mp4&apos;)</div><div class="line">while cap.isOpened():</div><div class="line">    ret, frame = cap.read()</div><div class="line">    cv2.imshow(&apos;playing&apos;, frame)</div><div class="line">    if cv2.waitKey(25) == 27:</div><div class="line">        break</div><div class="line">cap.release()</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p><strong>Note</strong>：Make sure proper versions of ffmpeg or gstreamer is installed. Sometimes, it is a headache to work with Video Capture mostly due to wrong installation of ffmpeg/gstreamer.</p>
<p><strong>Note</strong>：On Mac, you may get trouble while reading frame from a video file or writing frame to file, With no exception occurred but no data read out or write in. I have installed ffmpeg by homebrew, however not work for me. The OpenCV version on my Mac is 2.4.13. I have no idea about it. However, I tried it on Linux and it works without ffmpeg. The OpenCV version on Linux is 2.4.8. If you get the same trouble, maybe you can try uninstall OpenCV and install OpenCV3.x or OpenCV 2.4.8, it may works.</p>
<h1 id="Saving-a-Video"><a href="#Saving-a-Video" class="headerlink" title="Saving a Video"></a>Saving a Video</h1><p>Create a <code>VideoWriter</code> object and specify the output filename. Then specify the FourCC code. Then number of frames per second (fps) and frame size should be passed. And last one is isColor flag. If it is True, encoder expect color frame, otherwise it works with grayscale frame.</p>
<p>FourCC is a 4-byte code used to specify the video codec. The list of available codes can be found in <a href="http://www.fourcc.org/codecs.php" target="_blank" rel="external">fourcc.org</a>. It is platform dependent. </p>
<p>FourCC code is passed as below：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># for OpenCV 2.4.x version</div><div class="line">cv2.cv.CV_FOURCC(&apos;M&apos;,&apos;J&apos;,&apos;P&apos;,&apos;G&apos;)</div><div class="line">cv2.cv.CV_FOURCC(*&apos;M‌​JPG&apos;)</div><div class="line"># for OpenCV 3.0 version</div><div class="line">cv2.VideoWriter_fourcc(&apos;M&apos;,&apos;J&apos;,&apos;P&apos;,&apos;G&apos;)</div><div class="line">cv2.VideoWriter_fourcc(*&apos;MJPG&apos;)</div></pre></td></tr></table></figure>
<p>Below code capture from video file and saves part of it.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import sys</div><div class="line"></div><div class="line">cap = cv2.VideoCapture(&apos;video.avi&apos;)</div><div class="line">fourcc = cv2.cv.CV_FOURCC(*&apos;XVID&apos;)</div><div class="line">fps = 25</div><div class="line">ret, frame = cap.read()</div><div class="line">height, width = frame.shape[:2]</div><div class="line">out = cv2.VideoWriter(&apos;output.avi&apos;, fourcc, fps, (width, height))</div><div class="line"></div><div class="line">startTime = 60 # start at 60s</div><div class="line">endTime = 70 # end at 70s</div><div class="line"></div><div class="line">totalTime = cap.get(cv2.cv.CV_CAP_PROP_FRAME_COUNT) / fps</div><div class="line">if startTime &gt;= totalTime or endTime &gt; totalTime or startTime &gt; endTime:</div><div class="line">    print &apos;Invalid time settings&apos;</div><div class="line">    sys.exit(0)</div><div class="line"></div><div class="line">startFrame = startTime * fps</div><div class="line">stopFrame = endTime * fps</div><div class="line">cap.set(cv2.cv.CV_CAP_PROP_POS_FRAMES, startFrame) # read from startFrame</div><div class="line">duration = stopFrame - startFrame</div><div class="line"></div><div class="line">while duration and cap.isOpened():</div><div class="line">    ret, frame = cap.read()</div><div class="line">    cv2.imshow(&apos;preview&apos;, frame)</div><div class="line">    out.write(frame)</div><div class="line">    if cv2.waitKey(1000/fps) == 27:</div><div class="line">        break</div><div class="line">    duration -= 1</div><div class="line"></div><div class="line">cap.release()</div><div class="line">out.release()</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[BadApple视频转字符动画]]></title>
      <url>http://lizonghang.github.io/2016/08/06/BadApple%E8%A7%86%E9%A2%91%E8%BD%AC%E5%AD%97%E7%AC%A6%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&emsp;&emsp;实现 badapple.mp4 视频转字符动画，在终端显示字符动画。原理比较简单，使用终端命令 <code>ffmpeg</code> 从视频中抽取帧保存为图片，使用函数 <code>image2txt()</code> 将图片转化为字符画，最后使用终端命令 <code>cat</code> 输出字符动画。<br>&emsp;&emsp;源代码、帧图片、txt文本集可以从<a href="https://github.com/Lizonghang/Python-BadApple" target="_blank" rel="external">Github</a>中获取，badapple.mp4 可以从<a href="http://yun.baidu.com/s/1cLvjHG" target="_blank" rel="external">百度云</a>获取。通常视频是以 1 秒 24 帧图片组成的，为了节省时间与容量，采样的帧图片为 1 秒 10 帧，最终字符动画播放流畅，对质量无明显影响。若依旧要采用 1 秒 24 帧，可以修改 getImage.py 中的参数，修改方法见下文。<br>&emsp;&emsp;需要确保已经安装有第三方库 <code>PIL</code> 与 <code>numpy</code>，以及 <code>ffmpeg</code> 插件(可通过 Homebrew 安装)。</p>
<h1 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h1><p>本项目完整的包内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">badapple</div><div class="line">├── README.md</div><div class="line">├── getImage.py</div><div class="line">├── image2txt.py</div><div class="line">├── play.py</div><div class="line">├── images</div><div class="line">│   └── *.png</div><div class="line">└── txt</div><div class="line">    └── *.txt</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;getImage.py 用于从视频中提取帧图片，提取的帧图片存放于 images/ 文件夹，有 2190 张帧图片，若文件夹中已存在帧图片可不运行该程序。若要调整每帧图片数可调整变量 <code>crop_time</code> 累加的数值，清空已存在的图片集，修改视频路径(<code>videoPath</code>)、帧图片目录路径(<code>imagePath</code>)，再运行 getImage.py。由于调用的 <code>ffmpeg</code> 命令会输出很多信息，若要屏蔽这些信息可以修改 <code>os.system()</code> 中的命令，更换标准输出到文件。只需确保有对应图片生成即可。<br>&emsp;&emsp;image2txt.py 用于将图片转化为一定尺寸的字符画，从 images/ 文件夹中提取图片并转化为 txt 文本存放于 txt/ 文件夹。默认要求的终端尺寸为 300x75 ，若屏幕不能支持该大小，可以将参数 <code>charWidth</code> 修改为自定义的每行显示字符数，调整后若运行 play.py 要求终端大小为 (charWidth)x(charWidth/4) 。<br>&emsp;&emsp;play.py 用于获取 txt 文本集与依次显示 txt 文本集，以达到在终端播放字符动画的效果。运行之前请修改视频目录(<code>videoPath</code>)、txt文件夹目录(<code>txt_dir_path</code>)、images文件夹目录(<code>img_dir_path</code>)。若选择默认的终端大小 300x75 运行该程序，请先注释掉 <code>getTxt(img_dir_path, txt_dir_path)</code>，然后运行 play.py。若选择自定义的终端大小运行该程序，需要自行调整终端大小为 (charWidth)x(charWidth/4)，不注释 <code>getTxt(img_dir_path, txt_dir_path)</code>，然后运行 play.py，这需要稍等 10~60 秒。随后就能在终端显示字符动画。</p>
<p><strong>注意</strong>：自定义的 <code>charWidth</code> 过小则会降低播放质量，过大则会出现终端闪烁现象。需要根据实际情况调整 <code>charWidth</code>。<br><strong>注意</strong>：若修改了每帧播放的图片数目，则需要修改 play.py 中的 <code>time.sleep()</code> 数值，这是一个经验数值，用于和视频播放速度同步，修改该数值可加速或减缓字符动画播放速率。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="getImage-py"><a href="#getImage-py" class="headerlink" title="getImage.py"></a>getImage.py</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line"></div><div class="line">def getImage(videoPath, imagePath):</div><div class="line">    img_count = 1</div><div class="line">    crop_time = 0.0</div><div class="line">    while crop_time &lt;= 219.0:</div><div class="line">        os.system(&apos;ffmpeg -i %s -f image2 -ss %s -vframes 1 %s.png&apos; % (videoPath, str(crop_time), imagePath + str(img_count)))</div><div class="line">        img_count += 1</div><div class="line">        print &apos;Geting Image &apos; + str(img_count) + &apos;.png&apos; + &apos; from time &apos; + str(crop_time)</div><div class="line">        crop_time += 0.1</div><div class="line">    print &apos;Image Collected&apos;</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    videoPath = &apos;/Users/mac/Desktop/badapple.avi&apos;</div><div class="line">    imagePath = &apos;/Users/mac/Desktop/badapple/images/&apos;</div><div class="line">    getImage(videoPath, imagePath)</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;该模块用于从视频文件中抽取帧图片，<code>crop_time</code> 为抽取帧的时间，单位为秒，默认从 0 秒开始抽取，直到截取时间到达视频结束时间(219秒)。抽取帧图片使用了终端命令 <code>ffmpeg</code> 。输入文件为 badapple.mp4，输出格式为 <code>image2</code> 图片格式，截取时间为 0.0 秒，帧数为 1 ，输出图片为 1.png ： <code>ffmpeg -i badapple.mp4 -f image2 -ss 0.0 -vframes 1 1.png</code>。<br>&emsp;&emsp;<code>crop_time += 0.1</code> 中的累加数值表示 1 秒获取 1/0.1 张帧图片，调整该值将改变每秒获取的帧数目。<br>&emsp;&emsp;图片存储从 1.png 开始依次累增，直到 2190.png。<br>&emsp;&emsp;<code>videoPath</code> 为视频文件路径， <code>imagePath</code> 为图片文件夹路径。该模块可直接运行，运行之前先确认路径正确。如果已经有图片集，不需要运行该模块。</p>
<h2 id="image2txt-py"><a href="#image2txt-py" class="headerlink" title="image2txt.py"></a>image2txt.py</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line">import numpy</div><div class="line"></div><div class="line">def image2txt(inputFile, outputFile):</div><div class="line">    im = Image.open(inputFile).convert(&apos;L&apos;)</div><div class="line">    charWidth = 300</div><div class="line">    im = im.resize((charWidth, charWidth / 4))</div><div class="line">    target_width, target_height = im.size</div><div class="line">    data = numpy.array(im)[:target_height, :target_width]</div><div class="line">    f = open(outputFile, &apos;w&apos;)</div><div class="line">    for row in data:</div><div class="line">        for pixel in row:</div><div class="line">            if pixel &gt; 127:</div><div class="line">                f.write(&apos;#&apos;)</div><div class="line">            else:</div><div class="line">                f.write(&apos; &apos;)</div><div class="line">        f.write(&apos;\n&apos;)</div><div class="line">    f.close()</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;该模块用于将图片转化为字符画，转化前先将图片转化为灰度图，并将图片“变扁”以适应输出字符画与原画的比例，经验数据高度应为宽度的 1/4 。随后将大于阈值的像素写入’#’，小于阈值的像素写入’ ‘，默认阈值为 127。输出时，’#’ 表示白色，’ ‘ 表示黑色。写入的 txt 文件名需要与对应图片文件名对应，如 ‘1.png’ 对应 ‘1.txt’。转化后的 txt 文件存放于 txt/ 文件夹中。<br>&emsp;&emsp;<code>charWidth</code> 表示终端每行输出的字符数，数值需要根据实际需求调整，默认适应的终端大小为 300x75。</p>
<h2 id="play-py"><a href="#play-py" class="headerlink" title="play.py"></a>play.py</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import sys, os</div><div class="line">import image2txt</div><div class="line">import time</div><div class="line"></div><div class="line">def getTxt(imagePath, txtPath):</div><div class="line">    img_count = 1</div><div class="line">    while img_count &lt;= len(os.listdir(imagePath)):</div><div class="line">        imageFile = imagePath + str(img_count) + &apos;.png&apos;</div><div class="line">        txtFile = txtPath + str(img_count) + &apos;.txt&apos;</div><div class="line">        image2txt.image2txt(imageFile, txtFile)</div><div class="line">        print &apos;txt &apos; + str(img_count) + &apos; collected.&apos;</div><div class="line">        img_count += 1</div><div class="line"></div><div class="line">def play(txtPath):</div><div class="line">    txt_count = 1</div><div class="line">    while txt_count &lt;= len(os.listdir(txtPath)):</div><div class="line">        os.system(&apos;cat &apos; + txtPath + str(txt_count) + &apos;.txt&apos;)</div><div class="line">        time.sleep(1.0/11.25)</div><div class="line">        txt_count += 1</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    txt_dir_path = &apos;/Users/mac/Desktop/badapple/txt/&apos;</div><div class="line">    img_dir_path = &apos;/Users/mac/Desktop/badapple/images/&apos;</div><div class="line">    getTxt(img_dir_path, txt_dir_path)</div><div class="line">    play(txt_dir_path)</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;该模块是主要模块，用于在终端播放字符动画。播放前先按照 <code>charWidth</code> 的数值将帧图片集转换为字符集(若使用默认的 300x75 则忽略该步骤，注释掉函数 <code>getTxt(…)</code> 即可；若使用自定义比例，需要 10~60 秒等待时间)。然后使用终端命令 <code>cat</code> 依次输出各个 txt 文本中的字符画，输出的时间间隔是经验数值，可根据实际播放速度调整，加速或减缓播放速率以和原视频同步。<br>&emsp;&emsp;运行该模块前需要确保 txt/ 文件夹路径与 images/ 文件夹路径正确。</p>
<h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>&emsp;&emsp;左边是终端窗口，右边是 Quicktime Player，显示屏是电视显示屏。效果展示在<a href="https://pan.baidu.com/s/1geQMXvP" target="_blank" rel="external">百度云</a></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[自动化测试模型]]></title>
      <url>http://lizonghang.github.io/2016/08/04/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;一个自动化测试框架就是一个集成体系，在这一体系中包含测试功能的函数库、测试数据源、测试对象识别标准、以及多种可重用的模块。自动化测试框架在发展的过程中经历了几个阶段：模块驱动测试、数据驱动测试、对象驱动测试。</p>
<h1 id="自动化测试模型"><a href="#自动化测试模型" class="headerlink" title="自动化测试模型"></a>自动化测试模型</h1><p>&emsp;&emsp;自动化测试模型是自动化测试架构的基础，自动化测试的发展也经历了不同的阶段，不断有新的模型（概念）被提出，了解和使用这些自动化模型有利于构建一个灵活可维护的自动化架构。</p>
<h2 id="线性测试"><a href="#线性测试" class="headerlink" title="线性测试"></a>线性测试</h2><p>&emsp;&emsp;通过录制或编写脚本，一个脚本完成一个场景（一组完整功能操作），通过对脚本的回放来进行自动化测试。这是早期进行自动化测试的一种形式。例如在<a href="/2016/08/03/Selenium模拟操作实例/">模拟登陆实例</a>中的脚本就是线性测试形式。它的优势是每个脚本都是独立的，任何一个脚本文件可以单独运行。缺点是用例的开发与维护成本很高：</p>
<ul>
<li>一个用例对应一个脚本。如果登陆发送变化，例如用户名的属性发生改变，就不得不对每个脚本进行修改。测试用例形成规模，大量的工作被用于脚本的维护，从而失去自动化的意义。</li>
<li>这种模式下数据和脚本是混合在一起的，如果数据发生改变就需要修改脚本。这种模式下，脚本没有可重复使用的概念。</li>
</ul>
<h2 id="模块化与类库"><a href="#模块化与类库" class="headerlink" title="模块化与类库"></a>模块化与类库</h2><p>&emsp;&emsp;在脚本中有很多内容是重复的，于是可以将重复的部分写成公共模块，在需要的时候进行调用，这样就提高了编写脚本的效率。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># login.py</div><div class="line">def login():</div><div class="line">    driver.find_element_by_id(&quot;username&quot;).send_keys(&quot;username&quot;)</div><div class="line">    driver.find_element_by_id(&quot;password&quot;).send_keys(&quot;password&quot;)</div><div class="line">    driver.find_element_by_id(&quot;btnLogin&quot;).click()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># quit.py</div><div class="line">def quit():</div><div class="line">    driver.find_element_by_id(&quot;btnQuit&quot;).click()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">import login, quit</div><div class="line">driver = webdriver.Chrome()</div><div class="line">driver.get(&apos;http://www.ooxx.com&apos;)</div><div class="line">login.login()</div><div class="line">quit.quit()</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过上述不完整样例发现，可以将脚本中相同的部分代码独立出来形成模块或库。这样做有两方面优点：</p>
<ul>
<li>提高了开发效率，不用重复编写相同的脚本。之后需要时调用已写好的模块即可。</li>
<li>方便代码的维护。如果某个模块发生变化，只需要修改对应模块的代码即可。</li>
</ul>
<h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h2><p>&emsp;&emsp;数据驱动是自动化的进步，数据的改变驱动自动化的执行，从而引起测试结果的改变。简单的说，通过输入数据的不同引起输出结果的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">import time</div><div class="line">values = [&apos;selenium&apos;, &apos;webdriver&apos;]</div><div class="line">for search in values:</div><div class="line">    driver = webdriver.Chrome()</div><div class="line">    driver.get(http://www.baidu.com)</div><div class="line">    driver.find_element_by_id(&apos;kw&apos;).send_keys(search, Keys.RETURN)</div><div class="line">    time.sleep(3)</div><div class="line">    driver.close()</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取的数据源可能是数组、字典、函数、CSV或TXT文件，上面的例子实现了数据与脚本的分离，实现了参数化。同样的脚本执行不同的数据得到不同的结果，从而增强了脚本的复用性。</p>
<h2 id="关键字驱动"><a href="#关键字驱动" class="headerlink" title="关键字驱动"></a>关键字驱动</h2><p>&emsp;&emsp;关键词驱动就是通过关键字的改变引起测试结果改变。QTP、robot framework 等都是以关键字驱动为主的自动化工具，因为这类工具的易用性，‘填表’式的关键字驱动帮助封装了很多底层的东西，测试人员只需要考虑三个问题：做什么、对谁做、怎么做。可以将 Selenium IDE 看做一种关键字驱动的自动化工具，Selenium IDE 脚本分：命令（command）、对象（target）、值（value），通过这样的格式去描述不同的对象，从而引起结果的改变。</p>
<h1 id="登陆模块化"><a href="#登陆模块化" class="headerlink" title="登陆模块化"></a>登陆模块化</h1><p>&emsp;&emsp;在目前的脚本中有很多代码是可以模块化的，比如登陆模块。几乎每一个用例的执行都需要登陆脚本，那么久可以将登陆脚本独立到单独的文件调用。以<a href="/2016/08/03/Selenium模拟操作实例/#模拟百度登入登出">模拟百度登入登出</a>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># login.py</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.common.exceptions import NoSuchElementException</div><div class="line"></div><div class="line">def login(self):</div><div class="line">    driver = self.driver</div><div class="line">    driver.find_element_by_id(&apos;u1&apos;).find_element_by_name(&apos;tj_login&apos;).click()</div><div class="line">    try:</div><div class="line">        usernameInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__userName&apos;)</div><div class="line">        passwordInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__password&apos;)</div><div class="line">        usernameInput.clear()</div><div class="line">        passwordInput.clear()</div><div class="line">        usernameInput.send_keys(self.username)</div><div class="line">        passwordInput.send_keys(self.password)</div><div class="line">        driver.find_element_by_id(&apos;TANGRAM__PSP_8__submit&apos;).submit()</div><div class="line">    except NoSuchElementException as msg:</div><div class="line">        return False</div><div class="line">    return True</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"># baidu.py</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.action_chains import ActionChains</div><div class="line">from selenium.webdriver.common.by import By</div><div class="line">from selenium.webdriver.support.ui import WebDriverWait</div><div class="line">from selenium.webdriver.support import expected_conditions as EC</div><div class="line">import unittest, time</div><div class="line">import login</div><div class="line"></div><div class="line">class Login(unittest.TestCase):</div><div class="line"></div><div class="line">    def setUp(self):</div><div class="line">        self.driver = webdriver.Chrome()</div><div class="line">        self.driver.implicitly_wait(5)</div><div class="line">        self.username = &apos;username&apos;</div><div class="line">        self.password = &apos;password&apos;</div><div class="line"></div><div class="line">    def test_login(self):</div><div class="line">        driver = self.driver</div><div class="line">        driver.get(&apos;https://www.baidu.com&apos;)</div><div class="line">        if login.login(self):</div><div class="line">            ActionChains(driver).move_to_element(driver.find_element_by_id(&apos;s_username_top&apos;)).perform()</div><div class="line">            ActionChains(driver).move_to_element(driver.find_element_by_class_name(&apos;quit&apos;)).click().perform()</div><div class="line">            ActionChains(driver).move_to_element(driver.find_elements_by_xpath(&apos;//div[@class=&quot;button-wrap&quot;]/a&apos;)[2]).click().perform()</div><div class="line">            time.sleep(3)</div><div class="line"></div><div class="line">    def tearDown(self):</div><div class="line">        self.driver.quit()</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    unittest.main()</div></pre></td></tr></table></figure>
<h1 id="数据驱动-1"><a href="#数据驱动-1" class="headerlink" title="数据驱动"></a>数据驱动</h1><h2 id="数据参数化"><a href="#数据参数化" class="headerlink" title="数据参数化"></a>数据参数化</h2><p>&emsp;&emsp;在上面关于数据驱动的介绍中已经示例了使用数组进行参数化设置，这里将通过读取 txt 文件中的数据来实现参数化。</p>
<p>创建一个 data.txt 文件，文件内有三行数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">selenium</div><div class="line">webdriver</div><div class="line">bokeyuan</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过 for 循环，search 可以每次获取到文件中的一行数据，在定位到百度搜索框后将数据传入 send_keys()。这样通过循环调用，直到文件中的所有内容被读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">import time</div><div class="line"></div><div class="line">source = open(&apos;data.txt&apos;)</div><div class="line">values = source.readlines()</div><div class="line">source.close()</div><div class="line">for search in values:</div><div class="line">    driver = webdriver.Chrome()</div><div class="line">    driver.get(&apos;http://www.baidu.com&apos;)</div><div class="line">    driver.find_element_by_id(&apos;kw&apos;).send_keys(search, Keys.RETURN)</div><div class="line">    time.sleep(2)</div><div class="line">    driver.close()</div></pre></td></tr></table></figure>
<h2 id="登录参数化-读取txt文件"><a href="#登录参数化-读取txt文件" class="headerlink" title="登录参数化(读取txt文件)"></a>登录参数化(读取txt文件)</h2><p>&emsp;&emsp;按照上述思路，对自动化脚本中用户名、密码进行参数化。创建 userdata.txt 文件，存放用户名和密码，假设存放格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">username1 password1</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;在之前编写的 login.py 文件基础上作如下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">from selenium.common.exceptions import NoSuchElementException</div><div class="line"></div><div class="line">source = open(&apos;userdata.txt&apos;)</div><div class="line">username, password = source.readlines()[0].split()</div><div class="line">source.close()</div><div class="line"></div><div class="line">def login(self):</div><div class="line">    driver = self.driver</div><div class="line">    driver.find_element_by_id(&apos;u1&apos;).find_element_by_name(&apos;tj_login&apos;).click()</div><div class="line">    try:</div><div class="line">        usernameInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__userName&apos;)</div><div class="line">        passwordInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__password&apos;)</div><div class="line">        usernameInput.clear()</div><div class="line">        passwordInput.clear()</div><div class="line">        usernameInput.send_keys(username)</div><div class="line">        passwordInput.send_keys(password)</div><div class="line">        driver.find_element_by_id(&apos;TANGRAM__PSP_8__submit&apos;).submit()</div><div class="line">    except NoSuchElementException as msg:</div><div class="line">        return False</div><div class="line">    return True</div></pre></td></tr></table></figure>
<h2 id="登录参数化-函数"><a href="#登录参数化-函数" class="headerlink" title="登录参数化(函数)"></a>登录参数化(函数)</h2><p>&emsp;&emsp;函数可以预先给参数化赋值，借助这个特性，可以通过调用函数对用户名和密码进行参数化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># userinfo.py</div><div class="line">def Tester_Li(username=&apos;testusername&apos;, password=&apos;testpassword&apos;):</div><div class="line">    return username, password</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过给函数参数赋予默认值并返回的方法可以在函数中存储一些信息。再次修改 login.py 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># login.py</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.common.exceptions import NoSuchElementException</div><div class="line">import userinfo</div><div class="line"></div><div class="line">username, password = userinfo.Tester_Li()</div><div class="line"></div><div class="line">def login(self):</div><div class="line">    driver = self.driver</div><div class="line">    driver.find_element_by_id(&apos;u1&apos;).find_element_by_name(&apos;tj_login&apos;).click()</div><div class="line">    try:</div><div class="line">        usernameInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__userName&apos;)</div><div class="line">        passwordInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__password&apos;)</div><div class="line">        usernameInput.clear()</div><div class="line">        passwordInput.clear()</div><div class="line">        usernameInput.send_keys(username)</div><div class="line">        passwordInput.send_keys(password)</div><div class="line">        driver.find_element_by_id(&apos;TANGRAM__PSP_8__submit&apos;).submit()</div><div class="line">    except NoSuchElementException as msg:</div><div class="line">        return False</div><div class="line">    return True</div></pre></td></tr></table></figure>
<h2 id="登录参数化-读取字典"><a href="#登录参数化-读取字典" class="headerlink" title="登录参数化(读取字典)"></a>登录参数化(读取字典)</h2><p>&emsp;&emsp;使用一个函数来存储字典，假设文件名为 userinfo.py：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># userinfo.py</div><div class="line">def getUserInfo():</div><div class="line">    data = &#123;</div><div class="line">    &apos;Tester_Li&apos;: &#123;&apos;username&apos;: &apos;Li_username&apos;, &apos;password&apos;: &apos;Li_password&apos;&#125;,</div><div class="line">    &apos;Tester_Wang&apos;: &#123;&apos;username&apos;: &apos;Wang_username&apos;, &apos;password&apos;: &apos;Wang_password&apos;&#125;,</div><div class="line">    &#125;</div><div class="line">    return data</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># login.py</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.common.exceptions import NoSuchElementException</div><div class="line">import userinfo</div><div class="line"></div><div class="line">info_dict = userinfo.getUserInfo()[&apos;Tester_Li&apos;]</div><div class="line">username = info_dict[&apos;username&apos;]</div><div class="line">password = info_dict[&apos;password&apos;]</div><div class="line"></div><div class="line">def login(self):</div><div class="line">    driver = self.driver</div><div class="line">    driver.find_element_by_id(&apos;u1&apos;).find_element_by_name(&apos;tj_login&apos;).click()</div><div class="line">    try:</div><div class="line">        usernameInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__userName&apos;)</div><div class="line">        passwordInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__password&apos;)</div><div class="line">        usernameInput.clear()</div><div class="line">        passwordInput.clear()</div><div class="line">        usernameInput.send_keys(username)</div><div class="line">        passwordInput.send_keys(password)</div><div class="line">        driver.find_element_by_id(&apos;TANGRAM__PSP_8__submit&apos;).submit()</div><div class="line">    except NoSuchElementException as msg:</div><div class="line">        return False</div><div class="line">    return True</div></pre></td></tr></table></figure>
<h2 id="表单参数化-CSV"><a href="#表单参数化-CSV" class="headerlink" title="表单参数化(CSV)"></a>表单参数化(CSV)</h2><p>&emsp;&emsp;假设自动化脚本中要参数化一张表单，表单需要填写用户名、邮箱、年龄、性别等信息，就适合用读取 CSV 文件的方法来解决。创建 userinfo.csv 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">laowang,123456@126.com,23,男,</div><div class="line">xiaoli,123123@qq.com, 18, 女,</div><div class="line">xiaomin,456123@gmail.com, 29,女,</div></pre></td></tr></table></figure>
<p>使用 csv 库来读取 CSV 文件中的数据并格式化输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># encoding: utf-8</div><div class="line">import csv</div><div class="line">for user in csv.reader(file(&apos;userinfo.csv&apos;, &apos;rb&apos;)):</div><div class="line">    print &apos;Name: %s, Mail: %s, Age: %s, Sex: %s&apos; % tuple(user[0:4])</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Name: laowang, Mail: 123456@126.com, Age: 23, Sex: 男</div><div class="line">Name: xiaoli, Mail: 123123@qq.com, Age:  18, Sex:  女</div><div class="line">Name: xiaomin, Mail: 456123@gmail.com, Age:  29, Sex: 女</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;csv.reader() 用于读取 CSV 文件，每一次循环的 user 变量是一个列表，可以通过 user[index] 来读取其中的数据，上面将 user 中的数据抽取出来并转换为元组来简化代码。通过 csv 读取文件比较灵活，可以循环读取每一条数据，又不局限每次读取数据的个数。</p>
]]></content>
      
        <categories>
            
            <category> 软件测试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Selenium模拟操作实例]]></title>
      <url>http://lizonghang.github.io/2016/08/03/Selenium%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<h1 id="模拟百度登入登出"><a href="#模拟百度登入登出" class="headerlink" title="模拟百度登入登出"></a>模拟百度登入登出</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">from selenium.webdriver.common.by import By</div><div class="line">from selenium.webdriver.common.action_chains import ActionChains</div><div class="line">from selenium.webdriver.common.alert import Alert</div><div class="line">from selenium.webdriver.support.ui import WebDriverWait</div><div class="line">from selenium.webdriver.support import expected_conditions as EC</div><div class="line">import time</div><div class="line"></div><div class="line">driver = webdriver.Chrome()</div><div class="line">driver.get(&apos;https://www.baidu.com&apos;)</div><div class="line">try:</div><div class="line">    driver.find_element_by_id(&apos;u1&apos;).find_element_by_name(&apos;tj_login&apos;).click()</div><div class="line">    WebDriverWait(driver, 3).until(EC.presence_of_element_located((By.ID, &apos;TANGRAM__PSP_8__userName&apos;)))</div><div class="line">    driver.find_element_by_id(&apos;TANGRAM__PSP_8__userName&apos;).send_keys(&apos;username&apos;)</div><div class="line">    driver.find_element_by_id(&apos;TANGRAM__PSP_8__password&apos;).send_keys(&apos;password&apos;)</div><div class="line">    driver.find_element_by_id(&apos;TANGRAM__PSP_8__submit&apos;).submit()</div><div class="line">    WebDriverWait(driver, 3).until(EC.presence_of_element_located((By.ID, &apos;s_username_top&apos;)))</div><div class="line">    ActionChains(driver).move_to_element(driver.find_element_by_id(&apos;s_username_top&apos;)).perform()</div><div class="line">    ActionChains(driver).move_to_element(driver.find_element_by_class_name(&apos;quit&apos;)).click().perform()</div><div class="line">    WebDriverWait(driver, 3).until(EC.presence_of_element_located((By.CLASS_NAME, &apos;button-wrap&apos;)))</div><div class="line">    ActionChains(driver).move_to_element(driver.find_elements_by_xpath(&apos;//div[@class=&quot;button-wrap&quot;]/a&apos;)[2]).click().perform()</div><div class="line">    time.sleep(3)</div><div class="line">finally:</div><div class="line">    driver.quit()</div></pre></td></tr></table></figure>
<h1 id="模拟问卷星发布问卷"><a href="#模拟问卷星发布问卷" class="headerlink" title="模拟问卷星发布问卷"></a>模拟问卷星发布问卷</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"># encoding: utf-8</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">from selenium.webdriver.common.by import By</div><div class="line">from selenium.webdriver.support.ui import WebDriverWait</div><div class="line">from selenium.webdriver.support import expected_conditions as EC</div><div class="line">from selenium.common.exceptions import NoSuchElementException</div><div class="line">from selenium.webdriver.support.select import Select</div><div class="line">from selenium.webdriver.common.alert import Alert</div><div class="line">import time, sys</div><div class="line"></div><div class="line"># settings</div><div class="line">username = &apos;username&apos;</div><div class="line">password = &apos;password&apos;</div><div class="line"></div><div class="line">driver = webdriver.Chrome()</div><div class="line">driver.implicitly_wait(5)</div><div class="line">driver.get(&apos;http://www.baidu.com&apos;)</div><div class="line">driver.find_element_by_id(&apos;kw&apos;).send_keys(u&apos;问卷星&apos;, Keys.RETURN)</div><div class="line">driver.find_element_by_xpath(&apos;//div[@id=&quot;1&quot;]/h3&apos;).click()</div><div class="line">driver.switch_to_window(driver.window_handles[1])</div><div class="line">driver.find_element_by_id(&apos;ctl00_liLogin&apos;).click()</div><div class="line">time.sleep(1)</div><div class="line">username = driver.find_element_by_id(&apos;ctl00_ContentPlaceHolder1_UserName&apos;)</div><div class="line">password = driver.find_element_by_id(&apos;ctl00_ContentPlaceHolder1_Password&apos;)</div><div class="line">username.clear()</div><div class="line">password.clear()</div><div class="line">username.send_keys(username)</div><div class="line">password.send_keys(password, Keys.RETURN)</div><div class="line"></div><div class="line"># 登陆时可能出现验证码</div><div class="line">try:</div><div class="line">    driver.find_element_by_xpath(&apos;//div[@id=&quot;ctl01_ContentPlaceHolder1_divInfo&quot;]/div/div/span/a&apos;).click()</div><div class="line">except NoSuchElementException:</div><div class="line">    print u&apos;出现验证码，程序退出&apos;</div><div class="line">    sys.exit(0)</div><div class="line"></div><div class="line">driver.find_element_by_xpath(&apos;//ul[@class=&quot;CR-Obox&quot;]/li/a&apos;).click()</div><div class="line">driver.find_elements_by_xpath(&apos;//div[@id=&quot;divSearchResult&quot;]/ul/li&apos;)[0].click()</div><div class="line">driver.find_element_by_class_name(&apos;MOM-bottom&apos;).click()</div><div class="line"></div><div class="line"># 新建问卷时可能出现验证码</div><div class="line">try:</div><div class="line">    driver.find_element_by_id(&apos;hrefFiQ&apos;).click()</div><div class="line">except NoSuchElementException:</div><div class="line">    print u&apos;出现验证码，程序退出&apos;</div><div class="line">    sys.exit(0)</div><div class="line"></div><div class="line">select = Select(driver.find_element_by_xpath(&apos;//select[@id=&quot;ddlActivity&quot;]&apos;))</div><div class="line">print u&apos;新建的问卷名为: &apos;, select.first_selected_option.text</div><div class="line">driver.find_element_by_xpath(&apos;//ul[@class=&quot;BS-menu&quot;]/li&apos;).click()</div><div class="line">driver.find_elements_by_xpath(&apos;//tr&apos;)[0].find_element_by_class_name(&apos;delete&apos;).click()</div><div class="line">Alert(driver).accept()</div><div class="line">driver.find_elements_by_xpath(&apos;//ul[@class=&quot;BS-menu&quot;]/li&apos;)[-1].click()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 软件测试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Selenium自动化测试]]></title>
      <url>http://lizonghang.github.io/2016/07/31/Selenium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>require:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install selenium</div></pre></td></tr></table></figure>
<p>如果要选择 Chrome 作为测试浏览器，需要先安装 chromedriver，Mac 用户可使用 Homebrew 下载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo chmod +t /private/tmp/</div><div class="line">$ brew install chromedriver</div></pre></td></tr></table></figure>
<h1 id="简单用例"><a href="#简单用例" class="headerlink" title="简单用例"></a>简单用例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">import time</div><div class="line"># The instance of Chrome WebDriver is created.</div><div class="line">driver = webdriver.Chrome()</div><div class="line"># The driver.get() method will navigate to a page given by the URL. WebDriver will wait until the page has fully loaded (that is, the “onload” event has fired) before returning control to your test or script. It’s worth noting that if your page uses a lot of AJAX on load then WebDriver may not know when it has completely loaded.</div><div class="line">driver.get(&apos;http://www.python.org&apos;)</div><div class="line">print driver.title</div><div class="line"># WebDriver offers a number of ways to find elements using one of the find_element_by_* methods. For example, the input text element can be located by its name attribute using find_element_by_name method. Detailed explanation of finding elements is available in the Locating Elements chapter</div><div class="line">elem = driver.find_element_by_name(&apos;q&apos;)</div><div class="line"># Next we are sending keys, this is similar to entering keys using your keyboard. Special keys can be send using Keys class imported from selenium.webdriver.common.keys. To be safe, we’ll first clear any prepopulated text in the input field (e.g. “Search”) so it doesn’t affect our search results</div><div class="line">elem.clear()</div><div class="line">elem.send_keys(&apos;pycon&apos;)</div><div class="line">elem.send_keys(Keys.RETURN)</div><div class="line">print driver.page_source</div><div class="line">time.sleep(5)</div><div class="line"># Finally, the browser window is closed. You can also call quit method instead of close. The quit will exit entire browser whereas close` will close one tab, but if just one tab was open, by default most browser will exit entirely.</div><div class="line">driver.close()</div></pre></td></tr></table></figure>
<p>这段程序会打开浏览器，访问 <a href="http://www.python.org" target="_blank" rel="external">http://www.python.org</a> 并搜索 pycon，等待 5s 后关闭浏览器。</p>
<h1 id="用Selenium写测试单元"><a href="#用Selenium写测试单元" class="headerlink" title="用Selenium写测试单元"></a>用Selenium写测试单元</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">import unittest</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">import time</div><div class="line"></div><div class="line">class PythonOrgSearch(unittest.TestCase):</div><div class="line">    def setUp(self):</div><div class="line">        self.driver = webdriver.Chrome()</div><div class="line"></div><div class="line">    def test_search_in_python_org(self):</div><div class="line">        driver = self.driver</div><div class="line">        driver.get(&apos;http://www.python.org&apos;)</div><div class="line">        self.assertIn(&apos;Python&apos;, driver.title)</div><div class="line">        elem = driver.find_element_by_name(&apos;q&apos;)</div><div class="line">        elem.send_keys(&apos;pycon&apos;)</div><div class="line">        elem.send_keys(Keys.RETURN)</div><div class="line">        assert &apos;No results found.&apos; not in driver.page_source</div><div class="line">        time.sleep(5)</div><div class="line"></div><div class="line">    def tearDown(self):</div><div class="line">        self.driver.quit()</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    unittest.main()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 软件测试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Python录音]]></title>
      <url>http://lizonghang.github.io/2016/07/30/Python%E5%BD%95%E9%9F%B3/</url>
      <content type="html"><![CDATA[<p>require:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ brew install portaudio</div><div class="line">$ sudo pip install pyaudio</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">import wave, pyaudio</div><div class="line"></div><div class="line"># Settings</div><div class="line">CHUNK = 1024</div><div class="line">FORMAT = pyaudio.paInt16</div><div class="line">RATE = 8000</div><div class="line">CHANNELS = 1</div><div class="line">RECORD_SECONDS = 5</div><div class="line"></div><div class="line"># Record Function</div><div class="line">def recordWave():</div><div class="line">    pa = pyaudio.PyAudio()</div><div class="line">    stream = pa.open(format=FORMAT,</div><div class="line">                     channels=CHANNELS,</div><div class="line">                     rate=RATE,</div><div class="line">                     input=True,</div><div class="line">                     frames_per_buffer=CHUNK)</div><div class="line"></div><div class="line">    print &apos;Recording...&apos;</div><div class="line"></div><div class="line">    buffer = []</div><div class="line">    for i in range(0, int(RATE/CHUNK*RECORD_SECONDS)):</div><div class="line">        audio_data = stream.read(CHUNK)</div><div class="line">        buffer.append(audio_data)</div><div class="line"></div><div class="line">    print &apos;Record Done&apos;</div><div class="line"></div><div class="line">    stream.stop_stream()</div><div class="line">    stream.close()</div><div class="line">    pa.terminate()</div><div class="line"></div><div class="line">    wf = wave.open(&apos;record.wav&apos;, &apos;wb&apos;)</div><div class="line">    wf.setnchannels(CHANNELS)</div><div class="line">    wf.setsampwidth(pa.get_sample_size(FORMAT))</div><div class="line">    wf.setframerate(RATE)</div><div class="line">    wf.writeframes(b&apos;&apos;.join(buffer))</div><div class="line">    wf.close()</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    recordWave()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Python生成验证码]]></title>
      <url>http://lizonghang.github.io/2016/07/30/Python%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;对于识别验证码的程序来说最难的部分是验证码字符的切割和特征码的建立。很多验证码加了很多干扰素和干扰线，不仅影响用户体验还达不到防止破解的很好的效果。若要使验证码难于被程序识别，需要注意：</p>
<ul>
<li>字符粘连，最后所有字符都有粘连的部分</li>
<li>不使用规则字符，验证码的各个部分使用不同比例的缩放或者旋转</li>
</ul>
<p>&emsp;&emsp;一般实现以上两点或这两点的变性，破解程序就很难识别。为了不影响用户体验，还需要注意形状相似字符的区分。本文以较简易的椒盐、干扰线和旋转来实现常用的一类验证码。</p>
<h1 id="字体素材"><a href="#字体素材" class="headerlink" title="字体素材"></a>字体素材</h1><p><img src="/images/font.png" alt=""></p>
<h1 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># Settings</div><div class="line">parser = argparse.ArgumentParser()</div><div class="line">parser.add_argument(&apos;input&apos;, help=&apos;font image source&apos;)</div><div class="line">parser.add_argument(&apos;fontwidth&apos;, help=&apos;width of the font&apos;)</div><div class="line">parser.add_argument(&apos;fontheight&apos;, help=&apos;height of the font&apos;)</div><div class="line">parser.add_argument(&apos;-o&apos;, help=&apos;target image path&apos;, default=&apos;./authcode.png&apos;)</div><div class="line">parser.add_argument(&apos;-l&apos;, help=&apos;authcode length&apos;, default=4)</div><div class="line">parser.add_argument(&apos;-s&apos;, help=&apos;salt counts&apos;, default=200)</div><div class="line">args = parser.parse_args()</div><div class="line">fontImgPath = args.input</div><div class="line">fontWidth = int(args.fontwidth)</div><div class="line">fontHeight = int(args.fontheight)</div><div class="line">targetImgPath = args.o</div><div class="line">codeLength = int(args.l)</div><div class="line">saltNum = int(args.s)</div><div class="line">base = (&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,</div><div class="line">      &apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;,</div><div class="line">      &apos;K&apos;,&apos;L&apos;,&apos;M&apos;,&apos;N&apos;,&apos;O&apos;,&apos;P&apos;,&apos;Q&apos;,&apos;R&apos;,&apos;S&apos;,&apos;T&apos;,</div><div class="line">      &apos;U&apos;,&apos;V&apos;,&apos;W&apos;,&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;)</div></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>fontImgPath - 必选，字体图片路径</li>
<li>fontWidth - 必选，字体图片中字体宽度</li>
<li>fontHeight - 必选，字体图片中字体高度</li>
<li>targetImgPath - 可选，生成验证码存放路径，默认为当前路径，图片名 authcode.png</li>
<li>codeLength - 可选，生成验证码中字符数目，默认为 4 个字符</li>
<li>saltNum - 可选，生成验证码中椒盐现象数目，默认为 200</li>
<li>base - 字符集合，必须与字体图片素材中的顺序匹配</li>
</ul>
<h1 id="生成基本验证码图片"><a href="#生成基本验证码图片" class="headerlink" title="生成基本验证码图片"></a>生成基本验证码图片</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Generate Authcode Image</div><div class="line">def getAuthcode(base, fontImgPath, codeLength, fontWidth, fontHeight):</div><div class="line">    code = &apos;&apos;</div><div class="line">    fontImg = Image.open(fontImgPath)</div><div class="line">    codeImg = Image.new(&apos;RGBA&apos;, (fontWidth*codeLength, fontHeight+6), (255,255,255,0))</div><div class="line">    for k in range(codeLength):</div><div class="line">        randInt = random.randint(0,len(base)-1)</div><div class="line">        code = &apos;&apos;.join((code, base[randInt]))</div><div class="line">        img_s = fontImg.crop((randInt*fontWidth,0,(randInt+1)*fontWidth,fontHeight))</div><div class="line">        img_s = img_s.rotate(random.randint(-30,30))</div><div class="line">        codeImg.paste(img_s, (k*fontWidth,3))</div><div class="line">    return codeImg, code</div></pre></td></tr></table></figure>
<p>首先创建新的 RGBA 格式空白图片，其宽为字体宽度与验证码字符个数之积，高为字体高度+6px。依次随机选取字体集合中的一个字符，从字体素材图片中截取相应字符并旋转 -30° ~ 30°，粘贴到新建的图片中。最后将新建的图片与验证码字符串返回。</p>
<h1 id="干扰素"><a href="#干扰素" class="headerlink" title="干扰素"></a>干扰素</h1><h2 id="椒盐现象"><a href="#椒盐现象" class="headerlink" title="椒盐现象"></a>椒盐现象</h2><p>在指定图片中添加指定个数的干扰点，干扰点颜色随机，位置随机（但不能影响验证码字符）。图像操作直接改变原图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Add Salt</div><div class="line">def addSalt(image, saltNum):</div><div class="line">    width, height = image.size</div><div class="line">    count = 0</div><div class="line">    while count &lt; saltNum:</div><div class="line">        randX = random.randint(0, width-1)</div><div class="line">        randY = random.randint(0, height-1)</div><div class="line">        if image.getpixel((randX, randY))[-1] == 0:</div><div class="line">            image.putpixel((randX, randY), (random.randint(100,255), random.randint(100,255), random.randint(100,255), 255))</div><div class="line">            count += 1</div><div class="line">        else:</div><div class="line">            continue</div></pre></td></tr></table></figure>
<h2 id="干扰线"><a href="#干扰线" class="headerlink" title="干扰线"></a>干扰线</h2><p>在指定图片中添加 2 条位置随机的干扰线（数目可改变，但会影响用户体验）。此处在图片上半部分与下半部分各添加一条黑色干扰线，并带有一定倾斜度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">## Add Lines</div><div class="line">def addLines(image):</div><div class="line">    width, height = image.size</div><div class="line">    draw = ImageDraw.Draw(image)</div><div class="line">    for k in range(2):</div><div class="line">        randHeight = (height/2)*(k%2)+random.randint(5, (height-1)/2-5)</div><div class="line">        startPoint = (0, randHeight)</div><div class="line">        if random.random() &lt; 0.5:</div><div class="line">            endPoint = (width-1, randHeight+random.randint(0,5))</div><div class="line">        else:</div><div class="line">            endPoint = (width-1, randHeight-random.randint(0,5))</div><div class="line">        draw.line((startPoint, endPoint), fill=(0,0,0,255))</div><div class="line">    del draw</div></pre></td></tr></table></figure>
<h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">from PIL import Image, ImageDraw</div><div class="line">import random, argparse</div><div class="line"></div><div class="line"># Settings</div><div class="line">parser = argparse.ArgumentParser()</div><div class="line">parser.add_argument(&apos;input&apos;, help=&apos;font image source&apos;)</div><div class="line">parser.add_argument(&apos;fontwidth&apos;, help=&apos;width of the font&apos;)</div><div class="line">parser.add_argument(&apos;fontheight&apos;, help=&apos;height of the font&apos;)</div><div class="line">parser.add_argument(&apos;-o&apos;, help=&apos;target image path&apos;, default=&apos;./authcode.png&apos;)</div><div class="line">parser.add_argument(&apos;-l&apos;, help=&apos;authcode length&apos;, default=4)</div><div class="line">parser.add_argument(&apos;-s&apos;, help=&apos;salt counts&apos;, default=200)</div><div class="line">args = parser.parse_args()</div><div class="line">fontImgPath = args.input</div><div class="line">fontWidth = int(args.fontwidth)</div><div class="line">fontHeight = int(args.fontheight)</div><div class="line">targetImgPath = args.o</div><div class="line">codeLength = int(args.l)</div><div class="line">saltNum = int(args.s)</div><div class="line">base = (&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,</div><div class="line">      &apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;,</div><div class="line">      &apos;K&apos;,&apos;L&apos;,&apos;M&apos;,&apos;N&apos;,&apos;O&apos;,&apos;P&apos;,&apos;Q&apos;,&apos;R&apos;,&apos;S&apos;,&apos;T&apos;,</div><div class="line">      &apos;U&apos;,&apos;V&apos;,&apos;W&apos;,&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;)</div><div class="line"></div><div class="line"># Generate Authcode Image</div><div class="line">def getAuthcode(base, fontImgPath, codeLength, fontWidth, fontHeight):</div><div class="line">    code = &apos;&apos;</div><div class="line">    fontImg = Image.open(fontImgPath)</div><div class="line">    codeImg = Image.new(&apos;RGBA&apos;, (fontWidth*codeLength, fontHeight+6), (255,255,255,0))</div><div class="line">    for k in range(codeLength):</div><div class="line">        randInt = random.randint(0,len(base)-1)</div><div class="line">        code = &apos;&apos;.join((code, base[randInt]))</div><div class="line">        img_s = fontImg.crop((randInt*fontWidth,0,(randInt+1)*fontWidth,fontHeight))</div><div class="line">        img_s = img_s.rotate(random.randint(-30,30))</div><div class="line">        codeImg.paste(img_s, (k*fontWidth,3))</div><div class="line">    return codeImg, code</div><div class="line"></div><div class="line"># Add Salt</div><div class="line">def addSalt(image, saltNum):</div><div class="line">    width, height = image.size</div><div class="line">    count = 0</div><div class="line">    while count &lt; saltNum:</div><div class="line">        randX = random.randint(0, width-1)</div><div class="line">        randY = random.randint(0, height-1)</div><div class="line">        if image.getpixel((randX, randY))[-1] == 0:</div><div class="line">            image.putpixel((randX, randY), (random.randint(100,255), random.randint(100,255), random.randint(100,255), 255))</div><div class="line">            count += 1</div><div class="line">        else:</div><div class="line">            continue</div><div class="line"></div><div class="line">## Add Lines</div><div class="line">def addLines(image):</div><div class="line">    width, height = image.size</div><div class="line">    draw = ImageDraw.Draw(image)</div><div class="line">    for k in range(2):</div><div class="line">        randHeight = (height/2)*(k%2)+random.randint(5, (height-1)/2-5)</div><div class="line">        startPoint = (0, randHeight)</div><div class="line">        if random.random() &lt; 0.5:</div><div class="line">            endPoint = (width-1, randHeight+random.randint(0,5))</div><div class="line">        else:</div><div class="line">            endPoint = (width-1, randHeight-random.randint(0,5))</div><div class="line">        draw.line((startPoint, endPoint), fill=(0,0,0,255))</div><div class="line">    del draw</div><div class="line"></div><div class="line"># Main</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    authcode, code = getAuthcode(base, fontImgPath, codeLength, fontWidth, fontHeight)</div><div class="line">    addSalt(authcode, saltNum)</div><div class="line">    addLines(authcode)</div><div class="line">    authcode.save(targetImgPath, &apos;PNG&apos;)</div><div class="line">    print &apos;Generate Authcode: &apos;,code</div></pre></td></tr></table></figure>
<h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python generate_authcode.py font.png 19 20 -o authcode.png -l 4 -s 200</div></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Generate Authcode:  3PHU</div></pre></td></tr></table></figure>
<p>生成验证码图片：</p>
<p><img src="/images/authcode.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[socket网络通信——UNIX域套接字]]></title>
      <url>http://lizonghang.github.io/2016/07/26/socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94UNIX%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
      <content type="html"><![CDATA[<p>从程序员的角度来看，使用 UNIX 域套接字和 TCP/IP 套接字存在两个根本区别。首先，套接字的地址是文件系统上的一个路径，而不是一个包含服务器名和端口的元组。其次，文件系统中创建的表示套接字的节点会持久保存，即时套接字关闭也仍然存在，所以每次服务器启动时都需要将其删除。只需在设置部分做一些修改就可以把前面的回应服务器例子更新为使用 UDS。</p>
<h1 id="UNIX域套接字"><a href="#UNIX域套接字" class="headerlink" title="UNIX域套接字"></a>UNIX域套接字</h1><p>注意：sock 的创建已经从 <code>socket.AF_INET</code> 改变为 <code>socket.AF_UNIX</code>，并且服务器地址是文件系统中的一个节点。运行以下代码后，将会在指定位置创建一个 readonly 文件，文件类型为 socket 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">import os</div><div class="line"></div><div class="line">server_address = &apos;/Users/mac/Desktop/uds_socket&apos;</div><div class="line">try:</div><div class="line">    os.unlink(server_address)</div><div class="line">except OSError:</div><div class="line">    if os.path.exists(server_address)</div><div class="line">        raise</div><div class="line"></div><div class="line"># Create a UDS socket</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">print &apos;Starting up on %s&apos; % server_address</div><div class="line">sock.bind(server_address)</div><div class="line">sock.listen(1)</div><div class="line"></div><div class="line">while True:</div><div class="line">    print &apos;Waiting for a connection ...&apos;</div><div class="line">    connection, client_address = sock.accept()</div><div class="line">    try:</div><div class="line">        print &apos;Connection from &apos;, client_address</div><div class="line">        while True:</div><div class="line">            data = connection.recv(16)</div><div class="line">            print &apos;Received &quot;%s&quot;&apos; % data</div><div class="line">            if data:</div><div class="line">                print &apos;Sending data back to the client&apos;</div><div class="line">                connection.sendall(data)</div><div class="line">            else:</div><div class="line">                print &apos;No data from %s&apos; % server_address</div><div class="line">                break</div><div class="line">    finally:</div><div class="line">        connection.close()</div></pre></td></tr></table></figure>
<p>还需要修改客户设置来使用 UDS，要假设套接字的相应文件系统节点存在，因为服务器要通过绑定这个地址来创建套接字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">import sys</div><div class="line"></div><div class="line">sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</div><div class="line">server_address = &apos;/Users/mac/Desktop/uds_socket&apos;</div><div class="line"></div><div class="line">print &apos;Connecting to %s ...&apos; % server_address</div><div class="line">try:</div><div class="line">    sock.connect(server_address)</div><div class="line">except socket.error, msg:</div><div class="line">    print msg</div><div class="line">    sys.exit(1)</div><div class="line"></div><div class="line"># Send data</div><div class="line">try:</div><div class="line">    message = &apos;This is the message, it will be repeated.&apos;</div><div class="line">    print &apos;Sending &quot;%s&quot;&apos; % message</div><div class="line">    sock.sendall(message)</div><div class="line">    amount_received = 0</div><div class="line">    amount_expected = len(message)</div><div class="line">    while amount_received &lt; amount_expected:</div><div class="line">        data = sock.recv(16)</div><div class="line">        amount_received += len(data)</div><div class="line">        print &apos;Received &quot;%s&quot;&apos; % data</div><div class="line">finally:</div><div class="line">    sock.close()</div></pre></td></tr></table></figure>
<p>程序输出基本上相同，但对地址信息有适当的更新。服务器显示接收的消息并发回给客户端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Starting up on /Users/mac/Desktop/uds_socket</div><div class="line">Waiting for a connection ...</div><div class="line">Connection from</div><div class="line">Received &quot;This is the mess&quot;</div><div class="line">Sending data back to the client</div><div class="line">Received &quot;age, it will be &quot;</div><div class="line">Sending data back to the client</div><div class="line">Received &quot;repeated.&quot;</div><div class="line">Sending data back to the client</div><div class="line">Received &quot;&quot;</div><div class="line">No data from /Users/mac/Desktop/uds_socket</div><div class="line">Waiting for a connection ...</div></pre></td></tr></table></figure>
<p>客户端采用增量方式逐部分接收消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Connecting to /Users/mac/Desktop/uds_socket ...</div><div class="line">Sending &quot;This is the message, it will be repeated.&quot;</div><div class="line">Received &quot;This is the mess&quot;</div><div class="line">Received &quot;age, it will be &quot;</div><div class="line">Received &quot;repeated.&quot;</div></pre></td></tr></table></figure>
<h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><p>由于 UDS 套接字由文件系统上的一个节点表示，所以可以使用标准文件系统权限来控制对服务器的访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls -l /Users/mac/Desktop/uds_socket</div><div class="line">srwxr-xr-x  1 Hang  staff  0  7 26 21:35 /Users/mac/Desktop/uds_socket</div></pre></td></tr></table></figure>
<p>如果客户作为一个用户运行而不是作为 root，则会导致一个错误，因为进程没有打开套接字的权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ python server.py</div><div class="line">Connecting to /Users/mac/Desktop/uds_socket</div><div class="line">[Errno 13] Permission denied</div></pre></td></tr></table></figure>
<h1 id="父进程与子进程通信"><a href="#父进程与子进程通信" class="headerlink" title="父进程与子进程通信"></a>父进程与子进程通信</h1><p>在 Unix 下，<code>socketpair()</code> 函数对于建立 UDS 套接字完成进程间通信很有用。它会创建一对连接的套接字，在创建子进程之后，可以用来在父进程和子进程之间通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">import os</div><div class="line"></div><div class="line">parent, child = socket.socketpair()</div><div class="line">pid = os.fork()</div><div class="line">if pid:</div><div class="line">    print &apos;In parent, sending message&apos;</div><div class="line">    child.close()</div><div class="line">    parent.sendall(&apos;message from parent&apos;)</div><div class="line">    response = parent.recv(1024)</div><div class="line">    print &apos;Response from child: &apos;, response</div><div class="line">    parent.close()</div><div class="line">else:</div><div class="line">    print &apos;In child, waiting for message&apos;</div><div class="line">    parent.close()</div><div class="line">    message = child.recv(1024)</div><div class="line">    print &apos;Message from parent: &apos;, message</div><div class="line">    child.sendall(&apos;message from child&apos;)</div><div class="line">    child.close()</div></pre></td></tr></table></figure>
<p>默认地会创建一个 UDS 套接字，不过调用者还可以传递地址簇、套接字类型，甚至协议选项来控制如何创建套接字。</p>
<p>运行输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">In parent, sending message</div><div class="line">In child, waiting for message</div><div class="line">Message from parent:  message from parent</div><div class="line">Response from child:  message from child</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 网络通信 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[socket网络通信——UDP客户和服务器]]></title>
      <url>http://lizonghang.github.io/2016/07/26/socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94UDP%E5%AE%A2%E6%88%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>用户数据报协议（user datagram protocol，UDP）的工作方式与 TCP/IP 不同。TCP 是一个面向流（stream-oriented）的协议，确保所有数据以正确的顺序传输。UDP 是一个面向消息（message-oriented）的协议。UDP 不需要一个长期活动的连接，所以建立 UDP 套接字要简单些。另一方面，UDP 消息必须放在一个数据包中（对于IPv4，意味着它们可以包含 65507 字节，因为 65535 字节大小的数据包还包括首部信息），而且无法得到 TCP 提供的传输保障。</p>
<h1 id="回应服务器"><a href="#回应服务器" class="headerlink" title="回应服务器"></a>回应服务器</h1><p>由于实际上并没有连接，服务器不需要监听和接受连接。它只需要使用 <code>bind()</code> 将其套接字与一个端口关联，然后等待各个消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"># Create a UDP socket</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</div><div class="line"># Bind the socket to the port</div><div class="line">sock.bind((&apos;localhost&apos;, 10000))</div></pre></td></tr></table></figure>
<p>使用 <code>recvfrom()</code> 从套接字读取消息，这个函数会返回数据，还会返回发出这个数据的客户地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">while True:</div><div class="line">    print &apos;Waiting to receive message ...&apos;</div><div class="line">    data, address = sock.recvfrom(4096)</div><div class="line">    print &apos;Received %s bytes from %s&apos; % (len(data), address)</div><div class="line">    print &apos;Data: &apos;, data</div><div class="line">    if data:</div><div class="line">        sent = sock.sendto(data, address)</div><div class="line">        print &apos;sent data &quot;%s&quot; back to %s&apos; % (data, address)</div></pre></td></tr></table></figure>
<h1 id="回应客户"><a href="#回应客户" class="headerlink" title="回应客户"></a>回应客户</h1><p>UDP 回应客户与服务器类似，但是不使用 <code>bind()</code> 将套接字关联到一个地址。它使用 <code>sendto()</code> 将消息直接传送到服务器，并使用 <code>recvfrom()</code> 接收响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"># Create a UDP socket</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</div><div class="line">message = &apos;This is the message, it will be repeat later.&apos;</div><div class="line">try:</div><div class="line">    print &apos;Send message: &apos;, message</div><div class="line">    sent = sock.sendto(message, (&apos;localhost&apos;, 10000))</div><div class="line">    print &apos;Waiting to receive callback message ...&apos;</div><div class="line">    data, server = sock.recvfrom(4096)</div><div class="line">    print &apos;Received callback message: &apos;, data</div><div class="line">finally:</div><div class="line">    sock.close()</div><div class="line">    print &apos;Socket closed&apos;</div></pre></td></tr></table></figure>
<h1 id="客户与服务器"><a href="#客户与服务器" class="headerlink" title="客户与服务器"></a>客户与服务器</h1><p>运行这个服务器将会生成以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Waiting to receive message ...</div><div class="line">Received 45 bytes from (&apos;127.0.0.1&apos;, 60844)</div><div class="line">Data:  This is the message, it will be repeat later.</div><div class="line">sent data &quot;This is the message, it will be repeat later.&quot; back to (&apos;127.0.0.1&apos;, 60844)</div><div class="line">Waiting to receive message ...</div></pre></td></tr></table></figure>
<p>客户端输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Send message:  This is the message, it will be repeat later.</div><div class="line">Waiting to receive callback message ...</div><div class="line">Received callback message:  This is the message, it will be repeat later.</div><div class="line">Socket closed</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 网络通信 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[轮廓检测]]></title>
      <url>http://lizonghang.github.io/2016/07/25/%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B/</url>
      <content type="html"><![CDATA[<h1 id="轮廓检测"><a href="#轮廓检测" class="headerlink" title="轮廓检测"></a>轮廓检测</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">im = cv2.imread(&apos;star.png&apos;)</div><div class="line">im = im.copy()</div><div class="line">gray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</div><div class="line">ret, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)</div><div class="line">contours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</div><div class="line">cv2.drawContours(im, contours, -1, (0,0,255), 3)</div><div class="line">cv2.imshow(&apos;img&apos;, im)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>需要注意的是 <code>cv2.findContours()</code> 函数接受的参数为二值图，所以读取的图像要先转成灰度图，再转成二值图。</p>
<p>原图：</p>
<p><img src="/images/star.png" alt=""></p>
<p>检测结果：</p>
<p><img src="/images/star-edge.jpg" alt=""></p>
<p>注意，<code>cv2.findContours()</code> 函数会修改输入的图像。</p>
<h1 id="cv2-findContours"><a href="#cv2-findContours" class="headerlink" title="cv2.findContours()"></a>cv2.findContours()</h1><p>函数原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">contours, hierarchy = cv2.findContours(image, mode, method[, contours[, hierarchy[, offset]]])</div></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>image - 输入图像</li>
<li>mode - 轮廓的检索模式。<code>cv2.RETR_EXTERNAL</code> 只检测外轮廓；<code>RETR_LIST</code> 检测的轮廓不建立等级关系；<code>RETR_CCOMP</code> 建立两个等级的轮廓，上一层为外边界，内层为内孔的边界。如果内孔内还有连通物体，则这个物体的边界也在顶层；<code>RETR_TREE</code> 建立一个等级树结构的轮廓。</li>
<li>method - 轮廓的近似办法。<code>cv2.CHAIN_APPROX_NONE</code> 存储所有的轮廓点，相邻的两个点的像素位置差不超过 1 ，即 max(abs(x1-x2), abs(y1-y2)) == 1；<code>cv2.CHAIN_APPROX_SIMP</code> 压缩水平方向、垂直方向、对角线方向的元素，只保留该方向的终点坐标。例如一个矩形轮廓只需要 4 个点来保存轮廓信息；<code> cv2.CHAIN_APPROX_TC89_L1</code>，CV_CHAIN_APPROX_TC89_KCOS 使用 teh-Chinl chain 近似算法。</li>
<li>contours - 返回的轮廓</li>
<li>hierarchy - 每条轮廓对应的属性</li>
</ul>
<h2 id="返回值contour"><a href="#返回值contour" class="headerlink" title="返回值contour"></a>返回值contour</h2><p><code>cv2.findContours()</code> 函数首先返回一个 list，list 中每个元素都是图像中的一个轮廓，用 numpy 中的 ndarray 表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print type(contours)</div><div class="line">print type(contours[0])</div><div class="line">print len(contours)</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;type &apos;list&apos;&gt;</div><div class="line">&lt;type &apos;numpy.ndarray&apos;&gt;</div><div class="line">2</div></pre></td></tr></table></figure>
<p>可以验证上述信息。可以看到本例中有两条轮廓，一个是五角星的，一个是矩形的。每个轮廓是一个 ndarray，每个 ndarray 是轮廓上的点的集合。</p>
<p>由于知道返回的轮廓有两个，因此可以通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cv2.drawContours(im, contours, 0, (0,0,255), 3)</div><div class="line">cv2.drawContours(im, contours, 1, (0,255,0), 3)</div></pre></td></tr></table></figure>
<p>分别绘制两个轮廓。同时使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print len(contours[0])</div><div class="line">print len(contours[1])</div></pre></td></tr></table></figure>
<p>输出两个轮廓中存储的点的个数。可见五角星只有 5 个元素，这是因为轮廓中并不是存储轮廓上所有点，而是只存储可以用直线描述轮廓的点的个数，比如一个矩形只需要 4 个顶点就可以描述轮廓。</p>
<h2 id="返回值hierarchy"><a href="#返回值hierarchy" class="headerlink" title="返回值hierarchy"></a>返回值hierarchy</h2><p>该函数还返回一个可选的 hierarchy 结果，这是一个 ndarray，其中元素个数和轮廓个数相同，每个轮廓 <code>contours[i]</code> 对应 4 个 hierarchy 元素 <code>hierarchy[i][0] ~ hierarchy[i][3]</code>，分别表示后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号，如果没有对应项，则该值为负数。通过如下查看各属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print type(hierarchy)</div><div class="line">print hierarchy.ndim</div><div class="line">print hierarchy[0].ndim</div><div class="line">print hierarchy.shape</div></pre></td></tr></table></figure>
<h1 id="轮廓的绘制"><a href="#轮廓的绘制" class="headerlink" title="轮廓的绘制"></a>轮廓的绘制</h1><p>OpenCV 通过 <code>cv2.drawContours()</code> 在图像上绘制轮廓。函数原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset ]]]]])</div></pre></td></tr></table></figure>
<ul>
<li>image - 在选定的图像上绘制轮廓</li>
<li>contours - 轮廓本身，是一个 list</li>
<li>contourIdx - 指定绘制哪条轮廓，如果为 -1 则绘制所有轮廓</li>
<li>后续参数比较显而易见，其中 thickness 表明轮廓线宽度，如果为 -1 （<code>cv2.FILLED</code>），则为填充模式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cv2.drawContours(im, contours, -1, (0,0,255), 2)</div><div class="line">cv2.imshow(&apos;image&apos;, im)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[霍夫变换检测直线]]></title>
      <url>http://lizonghang.github.io/2016/07/25/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E6%A3%80%E6%B5%8B%E7%9B%B4%E7%BA%BF/</url>
      <content type="html"><![CDATA[<h1 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h1><p>Hough 变换是经典的检测直线的算法，最初用来检测图像中的直线，也可以将其扩展，以检测图像中简单的结构。</p>
<p>OpenCV 提供了两种用于直线检测的 Hough 变换形式，其中基本的版本是 <code>cv2.HoughLines()</code>。输入一幅含有点集的二值图，其中一些点相互联系组成直线。通常这是通过如 Canny 算子获得的一幅边缘图像。<code>cv2.HoughLines()</code> 函数输出 <code>[float, float]</code> 形式的 ndarray，其中每个值表示检测到的线(ρ , θ)中浮点点值的参数。下面的例子先用 Canny 算子获得图像边缘，然后使用 Hough 变换检测直线。其中 <code>cv2.HoughLines()</code> 函数的参数3和4对应直线搜索的步长。在本例中，函数将通过步长为 1 的半径和步长为 π/180 的角来搜索所有可能的直线。最后一个参数是经过某一点曲线的数量的阈值，超过这个阈值就表示这个交点所代表的参数对 (ρ , θ) 在原图像为一条直线。</p>
<p>示例图像如下：</p>
<p><img src="/images/street.jpg" alt=""></p>
<p>直线检测代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;street.jpg&apos;)</div><div class="line">im = cv2.GaussianBlur(im, (3,3), 0)</div><div class="line">edges = cv2.Canny(im, 50, 150, apertureSize=3)</div><div class="line">lines = cv2.HoughLines(edges, 1, np.pi/180, 260)</div><div class="line">result = im.copy()</div><div class="line">for line in lines[0]:</div><div class="line">    rho = line[0]</div><div class="line">    theta= line[1]</div><div class="line">    if  (theta &lt; (np.pi/4. )) or (theta &gt; (3.*np.pi/4.0)):</div><div class="line">        pt1 = (int(rho/np.cos(theta)),0)</div><div class="line">        pt2 = (int((rho-result.shape[0]*np.sin(theta))/np.cos(theta)),result.shape[0])</div><div class="line">        cv2.line( result, pt1, pt2, (0,0,255))</div><div class="line">    else:</div><div class="line">        pt1 = (0,int(rho/np.sin(theta)))</div><div class="line">        pt2 = (result.shape[1], int((rho-result.shape[1]*np.cos(theta))/np.sin(theta)))</div><div class="line">        cv2.line(result, pt1, pt2, (0,0,255), 1)</div><div class="line"></div><div class="line">cv2.imshow(&apos;Hough&apos;, result)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/images/hough.jpg" alt=""></p>
<h1 id="概率霍夫变换"><a href="#概率霍夫变换" class="headerlink" title="概率霍夫变换"></a>概率霍夫变换</h1><p>前面例子得到的结果图片，其中 Hough 变换看起来就像在图像中查找对齐的边界像素点集合，但这样会在一些情况下导致虚假检测，如像素偶然对齐或多条直线穿过同样的对齐像素造成的多重检测。</p>
<p>要避免这样的问题，并检测图像中分段的直线（而不是贯穿整个图像的直线），就出现了概率 Hough 变换。在 OpenCV 中用函数 <code>cv2.HoughLinesP()</code> 实现。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;street.jpg&apos;)</div><div class="line">im = cv2.GaussianBlur(im, (3,3), 0)</div><div class="line">edges = cv2.Canny(im, 50, 150, apertureSize=3)</div><div class="line">result = im.copy()</div><div class="line">minLineLength = 100</div><div class="line">maxLineGap = 50</div><div class="line">lines = cv2.HoughLinesP(edges, 1, np.pi/180, 200, minLineLength, maxLineGap)</div><div class="line">for x1,y1,x2,y2 in lines[0]:</div><div class="line">    cv2.line(result, (x1,y1), (x2,y2), (0,0,255), 2)</div><div class="line"></div><div class="line">cv2.imshow(&apos;HoughP&apos;, result)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/images/houghP.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Laplacian算子]]></title>
      <url>http://lizonghang.github.io/2016/07/25/Laplacian%E7%AE%97%E5%AD%90/</url>
      <content type="html"><![CDATA[<p>图像中的边缘区域像素值会发生“跳跃”，对这些像素求导，其一阶导数在边缘位置为极值，这是 Sobel 算子的原理。如果对像素值求二阶导数，会发现边缘处的二阶导数值为 0 。Laplace 函数实现的方法是先用 Sobel 算子计算二阶 x 和 y 导数，再求和：</p>
<p><img src="/images/laplace_arg.jpg" alt=""></p>
<p>在 OpenCV-Python 中，Laplace 算子的函数原型如下，和 Sobel 算子中的参数基本一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.Laplacian(src, ddepth[, dst[, ksize[, scale[, delta[, borderType]]]]])</div></pre></td></tr></table></figure>
<p>测试图像：</p>
<p><img src="/images/tower.jpg" alt=""></p>
<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;tower.jpg&apos;)</div><div class="line">gray_lap = cv2.Laplacian(im, cv2.CV_16S, ksize=3)</div><div class="line">dst = cv2.convertScaleAbs(gray_lap)</div><div class="line"></div><div class="line">cv2.imshow(&apos;laplacian&apos;, dst)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/tower-lap.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Sobel算子]]></title>
      <url>http://lizonghang.github.io/2016/07/24/Sobel%E7%AE%97%E5%AD%90/</url>
      <content type="html"><![CDATA[<p>Sobel 算子是一种过滤器，但它带有方向。在 OpenCV-Python 中，使用 Sobel 算子的函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.Sobel(src, ddepth, dx, dy[, dst[, ksize[, scale[, delta[, borderType]]]]])</div></pre></td></tr></table></figure>
<p>必选参数：</p>
<ul>
<li>src - 需要处理的图像。</li>
<li>ddepth - 图像深度。-1 表示采用与原图像相同的深度。目标图像深度≥原图像深度。</li>
<li>dx, dy - 求导阶数，0 表示不求导。</li>
</ul>
<p>可选参数：</p>
<ul>
<li>ksize - Sobel 算子大小，必须为 1、3、5、7。</li>
<li>scale - 缩放导数的比例常数，默认情况下不伸缩。</li>
<li>delta - 可选增量，会加到最终 dst 中，默认情况下不额外增加。</li>
<li>borderType - 判断图像边界的模式。默认值为 <code>cv2.BORDER_DEFAULT。</code></li>
</ul>
<p>Sobel 函数使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lion.jpg&apos;)</div><div class="line">im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</div><div class="line"></div><div class="line">x = cv2.Sobel(im, cv2.CV_16S, 1, 0)</div><div class="line">y = cv2.Sobel(im, cv2.CV_16S, 0, 1)</div><div class="line"></div><div class="line">absX = cv2.convertScaleAbs(x)</div><div class="line">absY = cv2.convertScaleAbs(y)</div><div class="line"></div><div class="line">dst = cv2.addWeighted(absX, 0.5, absY, 0.5, 0)</div><div class="line"></div><div class="line">cv2.imshow(&apos;origin&apos;, im)</div><div class="line">cv2.imshow(&quot;absX&quot;, absX)</div><div class="line">cv2.imshow(&quot;absY&quot;, absY)</div><div class="line">cv2.imshow(&quot;Result&quot;, dst)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>由于 Sobel 函数求导数后会有负值，还会有大于 255 的值，而原图像是 uint8 ，所以 Sobel 建立的图像位数不够，会有截断。因此要使用 16 位有符号的数据类型，即 <code>cv2.CV_16S</code>。</p>
<p>处理后要用 <code>cv2.convertScaleAbs()</code> 将其转回原来的 uint8 形式，否则无法显示图像。 <code>cv2.convertScaleAbs()</code> 的原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.convertScaleAbs(src[, dst[, alpha[, beta]]])</div></pre></td></tr></table></figure>
<p>其中可选参数 <code>alpha</code> 是伸缩系数， <code>beta</code> 是加到结果上的一个值。结果返回 uint8 类型的图片。</p>
<p>由于 Sobel 算子是在两个方向计算的，最后要使用 <code>cv2.addWeighted()</code> 函数将其组合起来。函数原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.addWeighted(src1, alpha, src2, beta, gamma[, dst[, dtype]])</div></pre></td></tr></table></figure>
<p>其中 <code>alpha</code> 是第一幅图片中元素的权重， <code>beta</code> 是第二个图片中元素的权重， <code>gamma</code> 是加到最后结果上的一个值。</p>
<p>原图：</p>
<p><img src="/images/lion.jpg" alt=""></p>
<p>absX：</p>
<p><img src="/images/absX.jpg" alt=""></p>
<p>absY：</p>
<p><img src="/images/absY.jpg" alt=""></p>
<p>Result：</p>
<p><img src="/images/sobel.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[滤波]]></title>
      <url>http://lizonghang.github.io/2016/07/24/%E6%BB%A4%E6%B3%A2/</url>
      <content type="html"><![CDATA[<h1 id="滤波简介"><a href="#滤波简介" class="headerlink" title="滤波简介"></a>滤波简介</h1><p>过滤是信号和图像处理中基本的任务，目的是根据应用环境的不同，选择性的提取图像中某些认为重要的信号。过滤可以移除图像中的噪音、提取感兴趣的可视特征、允许图像重采样等等。</p>
<p>当观察一张图片时，我们观察的是图像中有多少灰度级（或颜色）及其分布。根据灰度分布的不同来区分不同的图像。也有其他方面可以对图像进行分析，例如观察图像中灰度的变化。某些图像中包含大量强度不变的区域（如蓝天），而在其他图像中的灰度变化可能会非常快（如包含许多小物体的拥挤的图像）。因此，观察图像中这些变化的频率就构成了另一条分类图像的方法，这个观点称为频域。而通过观察图像灰度分布来分类图像称为空间域。</p>
<p>频域分析将图像分成从低频到高频的不同部分。低频对应图像强度变化小的区域，而高频是图像强度变化非常大的区域。目前存在若干种转换方法，如傅里叶变换或余弦变换，可以用来清晰地显示图像的频率。由于图像是一个二维实体，所以其频率由水平频率和竖直频率共同组成。</p>
<p>在频率分析领域的框架中，滤波器是一个用来增强图像中某个波段或频率并阻塞（或降低）其他频率波段的操作。低通滤波器是消除图像中的高频部分，保留低频部分。高通滤波器消除低频部分，保留高频部分。</p>
<p>这里只介绍在 OpenCV-Python 中实现的初级滤波操作，之后介绍更复杂的滤波原理及实现。</p>
<p>以下图为例：</p>
<p><img src="/images/lena.jpg" alt=""></p>
<h1 id="低通滤波平滑图像"><a href="#低通滤波平滑图像" class="headerlink" title="低通滤波平滑图像"></a>低通滤波平滑图像</h1><h2 id="初级低通滤波"><a href="#初级低通滤波" class="headerlink" title="初级低通滤波"></a>初级低通滤波</h2><p>低通滤波器的目标是降低图像的变化率。如将每个像素替换为该像素周围像素的均值，这样就可以平滑并替代那些强度变化明显的区域。在 OpenCV 中可以通过 <code>cv2.blur()</code> 来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.blur(im, (5,5))</div></pre></td></tr></table></figure>
<p>其中 <code>dst</code> 是函数处理后返回的图像，第一个参数是待处理图像，第二个参数是低通滤波器的大小。其后含有几个可选参数用来设置滤波器的细节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">blured = cv2.blur(im, (5,5))</div><div class="line"></div><div class="line">cv2.namedWindow(&apos;Origin&apos;, cv2.WINDOW_NORMAL)</div><div class="line">cv2.namedWindow(&apos;Blur&apos;, cv2.WINDOW_NORMAL)</div><div class="line">cv2.imshow(&apos;Origin&apos;, im)</div><div class="line">cv2.imshow(&apos;Blur&apos;, blured)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/blur.png" alt=""></p>
<p>这种滤波器又称为 boxfilter，所以也可使用 <code>cv2.boxFilter()</code> 完成相同的工作。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.boxFilter(im, -1, (5,5))</div></pre></td></tr></table></figure>
<p>该函数与 <code>cv2.blur()</code> 效果完全相同，第二个参数 -1 表示输出图像使用的深度与输入图像相同。</p>
<h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><p>在某些情况下需要对一个像素的周围像素给予更多的重视。因此可用分配权重来重新计算这些周围点的值，可以通过高斯函数的权重方案来解决。<code>cv2.GaussianBlur()</code> 可作为滤波器，用以下方式调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.GaussianBlur(im, (5,5), 1.5)</div></pre></td></tr></table></figure>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>低通滤波与高斯滤波不同之处在于：低通滤波中，滤波器中每个像素的权重是相同的，即滤波器是线性的。而高斯滤波器中像素的权重与其距中心像素的距离成比例。</p>
<h1 id="中值滤波消除噪点"><a href="#中值滤波消除噪点" class="headerlink" title="中值滤波消除噪点"></a>中值滤波消除噪点</h1><p>中值滤波器对于消除椒盐现象很有用。调用方法与调用其他滤波器类似，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.medianBlur(im, 5)</div></pre></td></tr></table></figure>
<p>函数返回处理结果，第一个参数是待处理图像，第二个参数是孔径尺寸，是一个大于 1 的奇数。比如上面就会使用 5x5 领域组成一个数值集，对其进行处理，当前像素被均值替换。</p>
<p>若在某个像素周围有白色或黑色的像素，这些白色或黑色的像素不会选择作为中值（最大或最小值排除），而是被替换为领域值。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;saltImg.jpg&apos;)</div><div class="line">median = cv2.medianBlur(im, 5)</div><div class="line"></div><div class="line">cv2.namedWindow(&apos;Salt&apos;, cv2.WINDOW_NORMAL)</div><div class="line">cv2.namedWindow(&apos;Median&apos;, cv2.WINDOW_NORMAL)</div><div class="line">cv2.imshow(&apos;Salt&apos;, im)</div><div class="line">cv2.imshow(&apos;Median&apos;, median)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindow()</div></pre></td></tr></table></figure>
<p>处理结果如下：</p>
<p><img src="/images/median.png" alt=""></p>
<p>由于中值滤波不会处理最大和最小值，所以不会受噪声影响。相反，如果直接采用 <code>cv2.blur()</code> 进行均值滤波，则不会区分这些噪声点，滤波后的图像会受到噪声的影响。</p>
<p>中值滤波器在处理边缘也有优势，但中值滤波器会清除掉某些区域的纹理，如头发纹理。</p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[形态学处理]]></title>
      <url>http://lizonghang.github.io/2016/07/23/%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="定义结构元素"><a href="#定义结构元素" class="headerlink" title="定义结构元素"></a>定义结构元素</h1><p>形态学处理核心是定义结构元素，在 OpenCV-Python 中，可以使用其自带的 <code>getStructuringElement</code> 函数，也可以直接使用 NumPy 的 <code>ndarray</code> 来定义一个结构元素。首先看用 <code>getStructuringElement</code> 函数定义的结构元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element = cv2.getStructuringElement(cv2.MORPH_CROSS, (5,5))</div></pre></td></tr></table></figure>
<p>这就定义了一个 5x5 的十字形结构元素，如下：</p>
<p><img src="/images/cross.jpg" alt=""></p>
<p>也可以用 NumPy 定义结构元素，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NpKernel = numpy.uint8(numpy.zeros((5,5)))</div><div class="line">for i in range(5):</div><div class="line">    NpKernel[2, i] = 1</div><div class="line">    NpKernel[i, 2] = 1</div></pre></td></tr></table></figure>
<p>两者定义的结构元素完全一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print element</div><div class="line">[[0 0 1 0 0]</div><div class="line"> [0 0 1 0 0]</div><div class="line"> [1 1 1 1 1]</div><div class="line"> [0 0 1 0 0]</div><div class="line"> [0 0 1 0 0]]</div><div class="line">&gt;&gt;&gt; print NpKernel</div><div class="line">[[0 0 1 0 0]</div><div class="line"> [0 0 1 0 0]</div><div class="line"> [1 1 1 1 1]</div><div class="line"> [0 0 1 0 0]</div><div class="line"> [0 0 1 0 0]]</div></pre></td></tr></table></figure>
<p>用 OpenCV-Python 内置的常量定义椭圆（MORPH_ELLIPSE）和十字形结构（MORPH_CROSS）元素要简单一些，如果定义矩形（MORPH_RECT）和自定义结构元素，则用两者差不多。</p>
<p>测试图片：</p>
<p><img src="/images/origin.jpg" alt=""></p>
<h1 id="腐蚀和膨胀"><a href="#腐蚀和膨胀" class="headerlink" title="腐蚀和膨胀"></a>腐蚀和膨胀</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># encoding: utf-8</div><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;origin.jpg&apos;)</div><div class="line"># OpenCV定义结构元素</div><div class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))</div><div class="line"></div><div class="line"># 腐蚀图像</div><div class="line">eroded = cv2.erode(im, kernel)</div><div class="line">cv2.imshow(&apos;Eroded Image&apos;, eroded)</div><div class="line"></div><div class="line"># 膨胀图像</div><div class="line">dilated = cv2.dilate(im, kernel)</div><div class="line">cv2.imshow(&apos;Dilated Image&apos;, dilated)</div><div class="line"></div><div class="line"># 原图像</div><div class="line">cv2.imshow(&apos;Origin Image&apos;, im)</div><div class="line"></div><div class="line"># NumPy定义结构元素</div><div class="line">NpKernel = np.uint8(np.ones((3,3)))</div><div class="line"></div><div class="line"># 腐蚀图像</div><div class="line">Nperoded = cv2.erode(im, NpKernel)</div><div class="line">cv2.imshow(&apos;Eroded by NumPy kernel&apos;, Nperoded)</div><div class="line"></div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>腐蚀和膨胀的处理很简单，只需要设置好结构元素，然后分别调用 <code>cv2.erode()</code> 和 <code>cv2.dilate()</code> 函数即可。其中第一个参数是需要处理的图像，第二个参数是结构元素。函数返回处理后的图像。</p>
<p>结果如下：</p>
<p><img src="/images/erode-dilate.jpg" alt=""></p>
<h1 id="开运算和闭运算"><a href="#开运算和闭运算" class="headerlink" title="开运算和闭运算"></a>开运算和闭运算</h1><p>开运算和闭运算时将腐蚀和膨胀按照一定的次序进行处理，但这两者不可逆，即进行开运算后进行闭运算不能得到原来的图像。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># encoding: utf-8</div><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;origin.jpg&apos;)</div><div class="line"># OpenCV定义结构元素</div><div class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5))</div><div class="line"></div><div class="line"># 闭运算</div><div class="line">closed = cv2.morphologyEx(im, cv2.MORPH_CLOSE, kernel)</div><div class="line">cv2.imshow(&apos;Close&apos;, closed)</div><div class="line"></div><div class="line"># 开运算</div><div class="line">opened = cv2.morphologyEx(im, cv2.MORPH_OPEN, kernel)</div><div class="line">cv2.imshow(&apos;Open&apos;, opened)</div><div class="line"></div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>闭运算用来连接被误分为许多小块的对象，而开运算用于移除由图像噪音形成的斑点。因此，某些情况下可以连续运用这两种运算。如对一幅二值图连续使用闭运算和开运算，将获得图像中的主要对象。同样，如果想要消除图像中的噪声，也可以对图像先用开运算后用闭运算，不过这样也会消除一些破碎的对象。</p>
<p>对原始图像分别进行开运算和闭运算的结果如下：</p>
<p><img src="/images/open.jpg" alt=""><br><img src="/images/close.jpg" alt=""></p>
<h1 id="用形态学运算检测边和角点"><a href="#用形态学运算检测边和角点" class="headerlink" title="用形态学运算检测边和角点"></a>用形态学运算检测边和角点</h1><p>仅作为介绍形态学处理的例子，实际使用时建议使用 Canny 或 Harris 等算法</p>
<h2 id="检测边缘"><a href="#检测边缘" class="headerlink" title="检测边缘"></a>检测边缘</h2><p>形态学检测边缘的原理为：在膨胀时图像中的物体会想向周围扩张；腐蚀时图像中的物体会收缩。比较这两幅图像，由于其变化的区域只发生在边缘，所以将两幅图像相减，得到的就是图像中物体的边缘。</p>
<p>以下图为例：</p>
<p><img src="/images/lampo.jpg" alt=""></p>
<p>边缘检测代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#encoding: utf-8</div><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lampo.jpg&apos;)</div><div class="line"># 转换颜色模式为灰度图</div><div class="line">im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</div><div class="line"># OpenCV 3x3结构元素</div><div class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))</div><div class="line"># 膨胀图像</div><div class="line">dilated = cv2.dilate(im, kernel)</div><div class="line"># 腐蚀图像</div><div class="line">eroded = cv2.erode(im, kernel)</div><div class="line"># 两幅图像相减得到边缘，第一个参数是膨胀图像，第二个参数是腐蚀图像</div><div class="line">edges = cv2.absdiff(dilated, eroded)</div><div class="line"># edges是灰度图，二值化处理以更清楚观察结果</div><div class="line">retval, edges = cv2.threshold(edges, 50, 100, cv2.THRESH_BINARY)</div><div class="line"># 反转颜色</div><div class="line">edges = cv2.bitwise_not(edges)</div><div class="line"></div><div class="line">cv2.imshow(&apos;origin&apos;, im)</div><div class="line">cv2.imshow(&apos;edges&apos;, edges)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/lampo-edge.jpg" alt=""></p>
<h2 id="检测拐角"><a href="#检测拐角" class="headerlink" title="检测拐角"></a>检测拐角</h2><p>拐角检测与边缘检测的原理相同，不同的是先用十字形的结构元素膨胀像素，这种情况下图像中只会在边缘处扩张，而角点不发生变化。接着用菱形的结构元素腐蚀原图像，导致只有在拐角处才会收缩，而直线边缘都未发生变化。第二步是用 X 形膨胀原图像，角点膨胀比边要多。这样第二次用方块腐蚀时，角点恢复原状，而边要腐蚀得更多。所以当两幅图像相减时，只保留了拐角处。</p>
<p>以下图为例：</p>
<p><img src="/images/building.jpg" alt=""></p>
<p>拐角检测代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#encoding: utf-8</div><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;building.jpg&apos;)</div><div class="line"># 转换颜色模式为灰度图</div><div class="line">im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</div><div class="line"># 构造 5x5 的结构元素，分别为十字形、菱形、方形和X形</div><div class="line">cross = cv2.getStructuringElement(cv2.MORPH_CROSS, (5,5))</div><div class="line">diamond = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5))</div><div class="line">diamond[0,0], diamond[0,1], diamond[1,0], diamond[4,4], diamond[4,3], diamond[3,4], diamond[4,0], diamond[4,1], diamond[3,0], diamond[0,3], diamond[0,4], diamond[1,4] = 0,0,0,0,0,0,0,0,0,0,0,0</div><div class="line">square = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5))</div><div class="line">x = cv2.getStructuringElement(cv2.MORPH_CROSS, (5,5))</div><div class="line"># 使用十字形结构元素膨胀图像</div><div class="line">detect1 = cv2.dilate(im, cross)</div><div class="line"># 使用菱形结构元素腐蚀图像</div><div class="line">detect1 = cv2.erode(detect1, diamond)</div><div class="line"># 使用X结构元素膨胀图像</div><div class="line">detect2 = cv2.dilate(im, x)</div><div class="line"># 使用方形结构元素腐蚀图像</div><div class="line">detect2 = cv2.erode(detect2, square)</div><div class="line"># 将两幅图像相减获得角</div><div class="line">horn = cv2.absdiff(detect2, detect1)</div><div class="line"># 使用阈值获得二值图</div><div class="line">retval, horn = cv2.threshold(horn, 40, 255, cv2.THRESH_BINARY)</div><div class="line"># 在原图上用半径为5的圆将点标出</div><div class="line">for j in range(horn.size):</div><div class="line">    y = j / horn.shape[0]</div><div class="line">    x = j % horn.shape[0]</div><div class="line">    if horn[x,y] == 255:</div><div class="line">        cv2.circle(im, (y,x), 5, (255,0,0))</div><div class="line"># 显示修改后的原图</div><div class="line">cv2.imshow(&apos;Horn Detect&apos;, im)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>由于封装的缘故，OpenCV 中函数参数中使用的坐标系和 NumPy 和 ndarray 的坐标系是不同的，在标点时可以看出。通过上面的代码可以检测图像中的拐角并标出，效果图如下：</p>
<p><img src="/images/horn.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Canny边缘检测]]></title>
      <url>http://lizonghang.github.io/2016/07/22/Canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</url>
      <content type="html"><![CDATA[<h1 id="Canny函数原型"><a href="#Canny函数原型" class="headerlink" title="Canny函数原型"></a>Canny函数原型</h1><p>OpenCV-Python 中 Canny 函数的原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">edge = cv2.Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient]]])</div></pre></td></tr></table></figure>
<ul>
<li>第一个参数是需要处理的原图像，该图像必须为单通道的灰度图</li>
<li>第二个参数是阈值1</li>
<li>第三个参数是阈值2</li>
</ul>
<p>其中较大的阈值2用于检测图像中明显的边缘，但一般情况下检测的效果不大完美，边缘检测出来是断断续续的。所以用较小的阈值1将这些间断的边缘连接起来。</p>
<p>可选参数中 <code>apertureSize</code> 就是 Sobel 算子的大小。而 <code>L2gradient</code> 参数是一个布尔值，若为真则使用更精确的 L2 范数进行计算（即两个方向的导数的平方和再开方），否则使用 L1 范数（直接将两个方向导数的绝对值相加）。</p>
<p>函数返回一幅二值图，其中包含检测出的边缘。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>Canny 函数使用只需要指定最大和最小阈值即可。以下图为例：</p>
<p><img src="/images/tower.jpg" alt=""></p>
<p>使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line">import cv2</div><div class="line">im = cv2.imread(&apos;tower.jpg&apos;)</div><div class="line">im = cv2.GaussianBlur(im, (3,3), 0)</div><div class="line">canny = cv2.Canny(im, 30, 100)</div><div class="line">cv2.imwrite(&apos;canny.jpg&apos;, canny)</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/canny.jpg" alt=""></p>
<p>可以调整阈值以改变边缘效果。</p>
<p>由于 Canny 只能处理灰度图，所以需要先将读取的图像转成灰度图。然后使用高斯平滑处理原图像以降噪。最后调用 Canny 函数，指定最大和最小阈值，其中 <code>apertureSize</code> 默认为 3。</p>
<h1 id="动态调整阈值"><a href="#动态调整阈值" class="headerlink" title="动态调整阈值"></a>动态调整阈值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">def CannyThreshold(lowThreshold):</div><div class="line">    detected_edges = cv2.GaussianBlur(gray, (3,3), 0) # Denoise</div><div class="line">    detected_edges = cv2.Canny(detected_edges, lowThreshold, lowThreshold*ratio,apertureSize=kernel_size) # Canny Edge Detect</div><div class="line">    dst = cv2.bitwise_and(im, im, mask=detected_edges) # Get Edge Image With Color</div><div class="line">    cv2.imshow(&apos;canny&apos;, dst)</div><div class="line"></div><div class="line"># Settings</div><div class="line">lowThreshold = 0 # Track Bar Start from State-0</div><div class="line">max_lowThreshold = 100 # Track Bar End with State-100</div><div class="line">ratio = 3 # threshold2 = threshold1 * ratio</div><div class="line">kernel_size = 3 # Size of Sobel</div><div class="line"></div><div class="line"># Running</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    im = cv2.imread(&apos;tower.jpg&apos;) # Read From File</div><div class="line">    gray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY) # GBR Convert To Gray</div><div class="line">    cv2.namedWindow(&apos;canny&apos;) # Create New Window</div></pre></td></tr></table></figure>
<p>得到的局部效果图如下：</p>
<p><img src="/images/canny_dial.jpg" alt=""></p>
<p>上图中有一个滑动条，拖动可改变 Canny 边缘检测效果，可以自行尝试一下。</p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[直方图的计算与显示]]></title>
      <url>http://lizonghang.github.io/2016/07/22/%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E8%AE%A1%E7%AE%97%E4%B8%8E%E6%98%BE%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>与 C++ 中一样，在 Python 中调用的 OpenCV 直方图计算函数为 <code>cv2.calcHist()</code>。</p>
<p><code>cv2.calcHist()</code> 的原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.calcHist(images, channels, mask, histSize, ranges[, hist[, accumlate ]])</div></pre></td></tr></table></figure>
<p>下面为一个简单例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">hist = cv2.calcHist(</div><div class="line">    [im],</div><div class="line">    [0], #使用的通道</div><div class="line">    None, #没有使用mask</div><div class="line">    [256], #HistSize</div><div class="line">    [0.0, 255.0] #直方图柱的范围</div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li>其中第一个参数 <code>images</code> 必须用方括号括起</li>
<li>第二个参数 <code>channels</code> 是用于计算直方图的通道，这里使用灰度图计算直方图，所以就直接使用第一个通道</li>
<li>第三个参数 <code>mask</code> 没有使用，用 <code>None</code></li>
<li>第四个参数 <code>histSize</code> 表示这个直方图分成多少份（即多少个直方柱）</li>
<li>第五个参数 <code>ranges</code> 表示直方图中各个像素的值， <code>[0.0, 255.0]</code> 表示直方图能表示像素值从 0.0 到 255.0 的像素</li>
<li>由于直方图作为函数结果返回了，所以 <code>hist</code> 没有意义</li>
<li><code>accumulate</code> 是一个布尔值，用来表示直方图是否叠加</li>
</ul>
<h1 id="彩色图像不同通道的直方图"><a href="#彩色图像不同通道的直方图" class="headerlink" title="彩色图像不同通道的直方图"></a>彩色图像不同通道的直方图</h1><p>以下图为例：</p>
<p><img src="/images/lena.jpg" alt=""></p>
<p>首先读取并分离各通道：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r,g,b = cv2.split(im)</div></pre></td></tr></table></figure>
<p>接着计算每个通道的直方图，这里将其封装成一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def calcAndDrawHist(image, color):</div><div class="line">    hist = cv2.calcHist([image], [0], None, [256], [0.0, 255.0])</div><div class="line">    minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(hist)</div><div class="line">    histImg = numpy.zeros([256,256,3], numpy.uint8)</div><div class="line">    hpt = int(0.9*256)</div><div class="line">    for h in range(256):</div><div class="line">        intensity = int(hist[h] * hpt / maxVal)</div><div class="line">        cv2.line(histImg, (h,256), (h,256-intensity), color)</div><div class="line">    return histImg</div></pre></td></tr></table></figure>
<p>在主函数中调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">    r, g, b = cv2.split(im)</div><div class="line">    histImgR = calcAndDrawHist(r, [255, 0, 0])</div><div class="line">    histImgG = calcAndDrawHist(g, [0, 255, 0])</div><div class="line">    histImgB = calcAndDrawHist(b, [0, 0, 255])</div><div class="line">    cv2.imwrite(&apos;/Users/mac/Desktop/histImgR.jpg&apos;, histImgR)</div><div class="line">    cv2.imwrite(&apos;/Users/mac/Desktop/histImgG.jpg&apos;, histImgG)</div><div class="line">    cv2.imwrite(&apos;/Users/mac/Desktop/histImgB.jpg&apos;, histImgB)</div></pre></td></tr></table></figure>
<p>得到的三个通道的直方图如下：</p>
<p><img src="/images/histImgR.jpg" alt=""><br><img src="/images/histImgG.jpg" alt=""><br><img src="/images/histImgB.jpg" alt=""></p>
<p>也可不分离通道，用折线来描绘直方图的边界，可在一个图中同时绘出三个通道的直方图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">h = numpy.zeros((256,256,3))</div><div class="line">bins = numpy.arange(256).reshape(256,1)</div><div class="line">color = [(255,0,0),(0,255,0),(0,0,255)]</div><div class="line">for ch,color in enumerate(color):</div><div class="line">    originHist = cv2.calcHist([im], [ch], None, [256], [0,256])</div><div class="line">    cv2.normalize(originHist, originHist, 0, 255*0.9, cv2.NORM_MINMAX)</div><div class="line">    hist = numpy.int32(numpy.around(originHist))</div><div class="line">    pts = numpy.column_stack((bins, hist))</div><div class="line">    cv2.polylines(h, [pts], False, color)</div><div class="line">h = numpy.flipud(h)</div><div class="line">cv2.imwrite(&apos;colorhist.jpg&apos;, h)</div></pre></td></tr></table></figure>
<p>结果如下图所示：</p>
<p><img src="/images/colorhist.jpg" alt=""></p>
<ul>
<li>for 循环是对三个通道遍历一次，每次绘制相应通道的直方图的折线。for 循环的第一行是计算对应通道的直方图。</li>
<li>这里直接调用了 OpenCV 的归一化函数，该函数将直方图的范围限定在 0~255×0.9 之间。</li>
<li><code>hist = numpy.int32(numpy.around(originHist))</code> 先将生成的原始直方图中的每个元素四舍六入五凑偶取整（cv2.calcHist函数得到的是 float32 类型的数组），接着将整数部分转成 <code>numpy.int32</code> 类型。即61.123先转成61.0，再转成61。这里必须使用 <code>numpy.int32()</code> 进行转换，numpy 的转换函数可以对数组中的每个元素都进行转换，而Python的转换函数只能转换一个元素，如果使用 Python 的转换函数，将导致 <code>only length-1 arrays can be converted to Python scalars</code> 错误。</li>
<li><code>pts = numpy.column_stack((bins,hist))</code> 是将直方图中每个bin的值转成相应的坐标。比如hist[0] =3，…，hist[126] = 178，…，hist[255] = 5；而bins的值为[[0],[1],[2]…,[255]]。使用 <code>np.column_stack</code> 将其组合成[0, 3]、[126, 178]、[255, 5]这样的坐标作为元素组成的数组。</li>
<li><code>cv2.polylines()</code> 函数根据这些点绘制出折线，&lt;/code&gt;False&lt;/code&gt; 参数指出这个折线不需要闭合。第四个参数指定了折线的颜色。</li>
<li><code>h = numpy.flipud(h)</code> 反转绘制好的直方图。因为绘制时，[0,0]在图像的左上角。</li>
</ul>
<h1 id="NumPy的直方图计算"><a href="#NumPy的直方图计算" class="headerlink" title="NumPy的直方图计算"></a>NumPy的直方图计算</h1><p>使用 NumPy 的直方图计算函数 <code>numpy.histogram()</code> 也能实现相同的效果，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">➜  Desktop vim cv.py</div><div class="line">➜  Desktop ls</div><div class="line">import numpy</div><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">h = numpy.zeros((300,256,3))</div><div class="line">bins = numpy.arange(257)</div><div class="line">bin = bins[0:-1]</div><div class="line">color = [(255,0,0),(0,255,0),(0,0,255)]</div><div class="line"></div><div class="line">for ch,color in enumerate(color):</div><div class="line">    item = im[:,:,ch]</div><div class="line">    N,bins = numpy.histogram(item, bins)</div><div class="line">    v = N.max()</div><div class="line">    N = numpy.int32(numpy.around((N*255)/v))</div><div class="line">    N = N.reshape(256,1)</div><div class="line">    pts = numpy.column_stack((bin,N))</div><div class="line">    cv2.polylines(h, [pts], False, color)</div><div class="line">h = numpy.flipud(h)</div><div class="line">cv2.imwrite(&apos;colorhist_np.jpg&apos;, h)</div></pre></td></tr></table></figure>
<p>效果图和上图相同。</p>
<p>通过 NumPy 和 matplotlib 可以更方便的绘制出直方图，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import numpy</div><div class="line">import cv2</div><div class="line">import matplotlib.pyplot as plt</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">bins = numpy.arange(257)</div><div class="line">item = im[:,:,1] # G通道直方图</div><div class="line">hist, bins = numpy.histogram(item, bins)</div><div class="line">width = 0.7*(bins[1]-bins[0])</div><div class="line">center = (bins[:-1]+bins[1:])/2</div><div class="line">plt.bar(center, hist, align=&apos;center&apos;, width=width)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/plt.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenCV像素与通道]]></title>
      <url>http://lizonghang.github.io/2016/07/21/OpenCV%E5%83%8F%E7%B4%A0%E4%B8%8E%E9%80%9A%E9%81%93/</url>
      <content type="html"><![CDATA[<h1 id="访问像素"><a href="#访问像素" class="headerlink" title="访问像素"></a>访问像素</h1><p>像素的访问和访问 numpy 中 ndarray 的方法完全一样，灰度图为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">img[j,i] = 255</div></pre></td></tr></table></figure>
<p>其中 j，i 分别表示图像的行和列。对于RGB图像第三个数表示通道，为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img[j,i,0] = 255</div><div class="line">img[j,i,1] = 255</div><div class="line">img[j,i,2] = 255</div></pre></td></tr></table></figure>
<p>下面通过对图像添加人工的椒盐现象来说明 OpenCV 中需要注意的一些问题。</p>
<p>实验图如下：</p>
<p><img src="/images/lena.jpg" alt=""></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy</div><div class="line"></div><div class="line">def salt(img, n):</div><div class="line">    for k in range(n):</div><div class="line">        i = int(numpy.random.random() * img.shape[1])</div><div class="line">        j = int(numpy.random.random() * img.shape[0])</div><div class="line">        if img.ndim == 2:</div><div class="line">            img[j,i] = 255</div><div class="line">        elif img.ndim == 3:</div><div class="line">            img[j,i,0] = 255</div><div class="line">            img[j,i,1] = 255</div><div class="line">            img[j,i,2] = 255</div><div class="line">    return img</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    img = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">    saltImg = salt(img, 1000)</div><div class="line">    cv2.imshow(&apos;SaltImage&apos;, saltImg)</div><div class="line">    cv2.waitKey(0)</div><div class="line">    cv2.destroyAllWindows()</div><div class="line">    cv2.imwrite(&apos;/Users/mac/Desktop/saltImg.jpg&apos;, saltImg)</div></pre></td></tr></table></figure>
<p>处理后能得到类似下面这样带有模拟椒盐现象的图片：</p>
<p><img src="/images/saltImg.jpg" alt=""></p>
<p>需要注意的是：</p>
<ul>
<li>与 C++ 不同，在 Python 中灰度图的 <code>img.ndim = 2</code>，而 C++ 中灰度图图像的通道数 <code>img.channel() = 1</code></li>
<li>这里使用了 numpy 的随机数， Python自身也有一个随机数生成函数。<code>numpy.random</code> 模块中拥有更多的方法，而 Python 自带的 <code>random</code> 只是一个轻量级的模块。不过需要注意的是 <code>numpy.random.seed()</code> 不是线程安全的，而 Python 自带的 <code>random.seed()</code> 是线程安全的。如果使用随机数时需要用到多线程，建议使用 Python 自带的 <code>random()</code> 和 <code>random.seed()，或者构建一个本地的 <code>numpy.random.Random</code> 类的实例。</code></li>
</ul>
<h1 id="分离、合并通道"><a href="#分离、合并通道" class="headerlink" title="分离、合并通道"></a>分离、合并通道</h1><p>由于 OpenCV-Python 和 NumPy 结合的很紧，所以即可使用 OpenCV自带的 <code>split</code>函数，也可以直接操作 Numpy 数组来分离通道。</p>
<h2 id="OpenCV分离通道"><a href="#OpenCV分离通道" class="headerlink" title="OpenCV分离通道"></a>OpenCV分离通道</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r, g, b = cv2.split(im)</div><div class="line">cv2.imshow(&apos;Red&apos;, r)</div><div class="line">cv2.imshow(&apos;Green&apos;, g)</div><div class="line">cv2.imshow(&apos;Blue&apos;, b)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>其中 <code>cv2.split()</code> 返回 RGB 三个通道，如果只想返回其中一个通道，可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">r = cv2.split(im)[0]</div><div class="line">g = cv2.split(im)[1]</div><div class="line">b = cv2.split(im)[2]</div></pre></td></tr></table></figure>
<h2 id="NumPy分离通道"><a href="#NumPy分离通道" class="headerlink" title="NumPy分离通道"></a>NumPy分离通道</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r = numpy.zeros((im.shape[0], im.shape[1]), dtype=im.dtype)</div><div class="line">g = numpy.zeros((im.shape[0], im.shape[1]), dtype=im.dtype)</div><div class="line">b = numpy.zeros((im.shape[0], im.shape[1]), dtype=im.dtype)</div><div class="line">r[:,:] = im[:,:,0]</div><div class="line">g[:,:] = im[:,:,1]</div><div class="line">b[:,:] = im[:,:,2]</div><div class="line">cv2.imshow(&apos;Red&apos;, r)</div><div class="line">cv2.imshow(&apos;Green&apos;, g)</div><div class="line">cv2.imshow(&apos;Blue&apos;, b)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>注意先要开辟一个相同大小的图片出来。这是由于 numpy 中数组的复制有三种方式，详见<a href="/2016/07/20/numpy深入探讨/#复制和镜像">NumPy数组复制</a>。</p>
<h1 id="合并通道"><a href="#合并通道" class="headerlink" title="合并通道"></a>合并通道</h1><h2 id="OpenCV合并通道"><a href="#OpenCV合并通道" class="headerlink" title="OpenCV合并通道"></a>OpenCV合并通道</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r,g,b = cv2.split(im)</div><div class="line">mergeImg = cv2.merge([r,g,b])</div><div class="line">cv2.imshow(&apos;merge&apos;, mergeImg)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<h2 id="Numpy合并通道"><a href="#Numpy合并通道" class="headerlink" title="Numpy合并通道"></a>Numpy合并通道</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r,g,b = cv2.split(im)</div><div class="line">merged = numpy.dstack([r,g,b])</div><div class="line">cv2.imshow(&apos;merge&apos;, merged)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<h2 id="合并效果"><a href="#合并效果" class="headerlink" title="合并效果"></a>合并效果</h2><p>实际使用时建议用 OpenCV 自带的合并函数，在效果上存在一点歧义，有人测试出二者的 <code>strides</code> 属性不同，而实际测出的却相同。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r,g,b = cv2.split(im)</div><div class="line">mergedByCV2 = numpy.dstack([r,g,b])</div><div class="line">mergedByNumpy = cv2.merge([r,g,b])</div><div class="line">print &apos;merged by opencv2.0: &apos;, mergedByCV2.strides</div><div class="line">print &apos;merged by numpy: &apos;, mergedByNumpy.strides</div></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">merged by opencv2.0:  (1500, 3, 1)</div><div class="line">merged by numpy:  (1500, 3, 1)</div></pre></td></tr></table></figure>
<p>NumPy 数组的 <code>strides</code> 属性表示的是在每个维数上以字节计算的步长。如下例（int64）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(6)</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([0, 1, 2, 3, 4, 5])</div><div class="line">&gt;&gt;&gt; a.strides</div><div class="line">(8,)</div><div class="line">&gt;&gt;&gt; b = numpy.arange(12).reshape((3,4))</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [ 4,  5,  6,  7],</div><div class="line">       [ 8,  9, 10, 11]])</div><div class="line">&gt;&gt;&gt; b.strides</div><div class="line">(32, 8)</div><div class="line">&gt;&gt;&gt; c = numpy.arange(27).reshape(3,3,3)</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([[[ 0,  1,  2],</div><div class="line">        [ 3,  4,  5],</div><div class="line">        [ 6,  7,  8]],</div><div class="line"></div><div class="line">       [[ 9, 10, 11],</div><div class="line">        [12, 13, 14],</div><div class="line">        [15, 16, 17]],</div><div class="line"></div><div class="line">       [[18, 19, 20],</div><div class="line">        [21, 22, 23],</div><div class="line">        [24, 25, 26]]])</div><div class="line">&gt;&gt;&gt; c.strides</div><div class="line">(72, 24, 8)</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[numpy深入探讨]]></title>
      <url>http://lizonghang.github.io/2016/07/20/numpy%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/</url>
      <content type="html"><![CDATA[<p>前两篇文章对NumPy数组做了基本的介绍，本篇文章对NumPy数组进行较深入的探讨。首先介绍自定义类型的数组，接着数组的组合，最后介绍数组复制方面的问题。</p>
<h1 id="自定义结构数组"><a href="#自定义结构数组" class="headerlink" title="自定义结构数组"></a>自定义结构数组</h1><p>通过 NumPy 也可以定义像 C 语言那样的结构类型。在 NumPy中定义结构的方法如下：</p>
<p>定义结构类型名称；定义字段名称；标明字段数据类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">student = numpy.dtype(&#123;&apos;names&apos;: [&apos;name&apos;, &apos;age&apos;, &apos;weight&apos;], &apos;formats&apos;: [&apos;S32&apos;, &apos;i&apos;, &apos;f&apos;]&#125;, align=True)</div></pre></td></tr></table></figure>
<p>这里 <code>student</code> 是自定义结构类型的名称，使用 <code>dtype()</code> 函数创建，在第一个参数中， <code>‘names’</code> 和 <code>‘formats’</code> 不能改变， <code>names</code>中列出的是结构中的字段名称， <code>formats</code> 中列出的是对应字段的数据类型。<code>S32</code>表示 32 字节长度的字符串， <code>i</code> 表示 32 位的整数， <code>f</code> 表示 32 位长度的浮点数。最后一个参数为 <code>True</code> 时，表示要求进行内存对齐。</p>
<p>字段中使用 NumPy 的字符编码来表示数据类型。更详细的数据类型见下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>字符编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数</td>
<td>i</td>
</tr>
<tr>
<td>无符号整数</td>
<td>u</td>
</tr>
<tr>
<td>单精度浮点数</td>
<td>f</td>
</tr>
<tr>
<td>双精度浮点数</td>
<td>d</td>
</tr>
<tr>
<td>布尔值</td>
<td>b</td>
</tr>
<tr>
<td>复数</td>
<td>D</td>
</tr>
<tr>
<td>字符串</td>
<td>S</td>
</tr>
<tr>
<td>Unicode</td>
<td>U</td>
</tr>
<tr>
<td>Void</td>
<td>V</td>
</tr>
</tbody>
</table>
</div>
<p>在定义好结构类型之后，就可以定义以该类型为元素的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = numpy.array([(&apos;Zhang&apos;, 32, 65.5), (&apos;Wang&apos;, 24, 55.2)], dtype=student)</div></pre></td></tr></table></figure>
<p>除了在每个元素中依次列出对应字段的数据外，还需要在 <code>array</code> 函数中指定对应的数据类型。</p>
<h1 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h1><p>首先创建两个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(9).reshape(3,3)</div><div class="line">&gt;&gt;&gt; b = 2 * a</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[0, 1, 2],</div><div class="line">       [3, 4, 5],</div><div class="line">       [6, 7, 8]])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  2,  4],</div><div class="line">       [ 6,  8, 10],</div><div class="line">       [12, 14, 16]])</div></pre></td></tr></table></figure>
<h2 id="水平组合"><a href="#水平组合" class="headerlink" title="水平组合"></a>水平组合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.hstack((a,b))</div><div class="line">array([[ 0,  1,  2,  0,  2,  4],</div><div class="line">       [ 3,  4,  5,  6,  8, 10],</div><div class="line">       [ 6,  7,  8, 12, 14, 16]])</div></pre></td></tr></table></figure>
<p>也可通过 <code>concatenate</code> 函数并指定相应的轴来获得这一效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.concatenate((a,b), axis=1)</div><div class="line">array([[ 0,  1,  2,  0,  2,  4],</div><div class="line">       [ 3,  4,  5,  6,  8, 10],</div><div class="line">       [ 6,  7,  8, 12, 14, 16]])</div></pre></td></tr></table></figure>
<h2 id="垂直组合"><a href="#垂直组合" class="headerlink" title="垂直组合"></a>垂直组合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.vstack((a,b))</div><div class="line">array([[ 0,  1,  2],</div><div class="line">       [ 3,  4,  5],</div><div class="line">       [ 6,  7,  8],</div><div class="line">       [ 0,  2,  4],</div><div class="line">       [ 6,  8, 10],</div><div class="line">       [12, 14, 16]])</div></pre></td></tr></table></figure>
<p>同样可通过 <code>concatenate</code> 函数并指定相应的轴来获得这一效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.concatenate((a,b), axis=0)</div><div class="line">array([[ 0,  1,  2],</div><div class="line">       [ 3,  4,  5],</div><div class="line">       [ 6,  7,  8],</div><div class="line">       [ 0,  2,  4],</div><div class="line">       [ 6,  8, 10],</div><div class="line">       [12, 14, 16]])</div></pre></td></tr></table></figure>
<h2 id="深度组合"><a href="#深度组合" class="headerlink" title="深度组合"></a>深度组合</h2><p>另外还有深度方面的组合函数 <code>dstack</code>，顾名思义，就是在数组的第三个轴（即深度）上组合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.dstack((a,b))</div><div class="line">array([[[ 0,  0],</div><div class="line">        [ 1,  2],</div><div class="line">        [ 2,  4]],</div><div class="line"></div><div class="line">       [[ 3,  6],</div><div class="line">        [ 4,  8],</div><div class="line">        [ 5, 10]],</div><div class="line"></div><div class="line">       [[ 6, 12],</div><div class="line">        [ 7, 14],</div><div class="line">        [ 8, 16]]])</div></pre></td></tr></table></figure>
<p>仔细观察发现对应的元素都组合成一个新的列表，该列表作为新的数组的元素。</p>
<h2 id="行组合"><a href="#行组合" class="headerlink" title="行组合"></a>行组合</h2><p>行组合可将多个一维数组作为新数组的每一行进行组合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(2)</div><div class="line">&gt;&gt;&gt; b = a + 2</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([0, 1])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([2, 3])</div><div class="line">&gt;&gt;&gt; numpy.row_stack((a,b))</div><div class="line">array([[0, 1],</div><div class="line">       [2, 3]])</div></pre></td></tr></table></figure>
<h2 id="列组合"><a href="#列组合" class="headerlink" title="列组合"></a>列组合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a</div><div class="line">array([0, 1])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([2, 3])</div><div class="line">&gt;&gt;&gt; numpy.column_stack((a,b))</div><div class="line">array([[0, 2],</div><div class="line">       [1, 3]])</div></pre></td></tr></table></figure>
<h1 id="分割数组"><a href="#分割数组" class="headerlink" title="分割数组"></a>分割数组</h1><p>分割数组的函数有 <code>hsplit</code>、<code>vsplit</code>、<code>dsplit</code>、<code>split</code>。可将数组分割成相同大小的子数组，或指定原数组分割的位置。</p>
<h2 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.hsplit(a, 3)</div><div class="line">[array([[0],</div><div class="line">       [3],</div><div class="line">       [6]]), array([[1],</div><div class="line">       [4],</div><div class="line">       [7]]), array([[2],</div><div class="line">       [5],</div><div class="line">       [8]])]</div></pre></td></tr></table></figure>
<p>也可以调用 <code>split</code> 函数并指定 <code>axis=1</code> 来获得这样的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.split(a, 3, axis=1)</div></pre></td></tr></table></figure>
<h2 id="垂直分割"><a href="#垂直分割" class="headerlink" title="垂直分割"></a>垂直分割</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.vsplit(a, 3)</div><div class="line">[array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])]</div></pre></td></tr></table></figure>
<p>也可以调用 <code>split</code> 函数并指定 <code>axis=0</code> 来获得这样的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.split(a, 3, axis=0)</div></pre></td></tr></table></figure>
<h2 id="深度分割"><a href="#深度分割" class="headerlink" title="深度分割"></a>深度分割</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = numpy.arange(27).reshape(3,3,3)</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([[[ 0,  1,  2],</div><div class="line">        [ 3,  4,  5],</div><div class="line">        [ 6,  7,  8]],</div><div class="line"></div><div class="line">       [[ 9, 10, 11],</div><div class="line">        [12, 13, 14],</div><div class="line">        [15, 16, 17]],</div><div class="line"></div><div class="line">       [[18, 19, 20],</div><div class="line">        [21, 22, 23],</div><div class="line">        [24, 25, 26]]])</div><div class="line">&gt;&gt;&gt; numpy.dsplit(c, 3)</div><div class="line">[array([[[ 0],</div><div class="line">        [ 3],</div><div class="line">        [ 6]],</div><div class="line"></div><div class="line">       [[ 9],</div><div class="line">        [12],</div><div class="line">        [15]],</div><div class="line"></div><div class="line">       [[18],</div><div class="line">        [21],</div><div class="line">        [24]]]), array([[[ 1],</div><div class="line">        [ 4],</div><div class="line">        [ 7]],</div><div class="line"></div><div class="line">       [[10],</div><div class="line">        [13],</div><div class="line">        [16]],</div><div class="line"></div><div class="line">       [[19],</div><div class="line">        [22],</div><div class="line">        [25]]]), array([[[ 2],</div><div class="line">        [ 5],</div><div class="line">        [ 8]],</div><div class="line"></div><div class="line">       [[11],</div><div class="line">        [14],</div><div class="line">        [17]],</div><div class="line"></div><div class="line">       [[20],</div><div class="line">        [23],</div><div class="line">        [26]]])]</div></pre></td></tr></table></figure>
<h1 id="复制和镜像"><a href="#复制和镜像" class="headerlink" title="复制和镜像"></a>复制和镜像</h1><p>当运算和处理数组时，它们的数据有时被拷贝到新的数组，有时不是。有三种情况：</p>
<h2 id="完全不复制"><a href="#完全不复制" class="headerlink" title="完全不复制"></a>完全不复制</h2><p>简单的赋值，而不复制数组对象或它们的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(12)</div><div class="line">&gt;&gt;&gt; b = a # 不创建新对象</div><div class="line">&gt;&gt;&gt; b is a</div><div class="line">True</div><div class="line">&gt;&gt;&gt; b.shape = (3,4)</div><div class="line">&gt;&gt;&gt; a.shape</div><div class="line">(3, 4)</div></pre></td></tr></table></figure>
<p>Python 传递不定对象作为参考，所以函数调用不拷贝数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def f(x):</div><div class="line">...     print id(x)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; id(a)</div><div class="line">4560419696</div><div class="line">&gt;&gt;&gt; f(a)</div><div class="line">4560419696</div></pre></td></tr></table></figure>
<h2 id="视图（View）和浅复制"><a href="#视图（View）和浅复制" class="headerlink" title="视图（View）和浅复制"></a>视图（View）和浅复制</h2><p>不同的数组对象分享同一个数据。视图方法创造一个新的数组对象指向同一数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = a.view()</div><div class="line">&gt;&gt;&gt; c is a</div><div class="line">False</div><div class="line">&gt;&gt;&gt; c.base is a </div><div class="line">True</div><div class="line">&gt;&gt;&gt; c.flags.owndata</div><div class="line">False</div><div class="line">&gt;&gt;&gt; c.shape = (2,6) # a的形状不变</div><div class="line">&gt;&gt;&gt; a.shape</div><div class="line">(3, 4)</div><div class="line">&gt;&gt;&gt; c[0,4] = 12 # a的数据改变</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [12,  5,  6,  7],</div><div class="line">       [ 8,  9, 10, 11]])</div></pre></td></tr></table></figure>
<p>切片数组返回它的一个视图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = a[:, 1:3]</div><div class="line">&gt;&gt;&gt; s[:] = 10 # s[:]是s的镜像，共享数据</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 0, 10, 10,  3],</div><div class="line">       [12, 10, 10,  7],</div><div class="line">       [ 8, 10, 10, 11]])</div></pre></td></tr></table></figure>
<h2 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h2><p>完全复制数组和它的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = a.copy()</div><div class="line">&gt;&gt;&gt; d is a</div><div class="line">False</div><div class="line">&gt;&gt;&gt; d.base is a</div><div class="line">False</div><div class="line">&gt;&gt;&gt; d[0,0] = 99</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 0, 10, 10,  3],</div><div class="line">       [12, 10, 10,  7],</div><div class="line">       [ 8, 10, 10, 11]])</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[numpy数组操作]]></title>
      <url>http://lizonghang.github.io/2016/07/20/numpy%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h1 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.array([20,30,40,50])</div><div class="line">&gt;&gt;&gt; b = numpy.arange(4)</div><div class="line">&gt;&gt;&gt; c = a - b</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([20, 29, 38, 47])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([0, 1, 2, 3])</div><div class="line">&gt;&gt;&gt; b**2</div><div class="line">array([0, 1, 4, 9])</div><div class="line">&gt;&gt;&gt; 10*numpy.sin(a)</div><div class="line">array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])</div><div class="line">&gt;&gt;&gt; a &lt; 35</div><div class="line">array([ True,  True, False, False], dtype=bool)</div></pre></td></tr></table></figure>
<p>NumPy 中的乘法运算符按元素逐个计算，矩阵乘法可以使用 dot 函数或创建矩阵对象实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; A = numpy.array([[1,1],[0,1]])</div><div class="line">&gt;&gt;&gt; B = numpy.array([[2,0],[3,4]])</div><div class="line">&gt;&gt;&gt; A*B</div><div class="line">array([[2, 0],</div><div class="line">       [0, 4]])</div><div class="line">&gt;&gt;&gt; numpy.dot(A,B)</div><div class="line">array([[5, 4],</div><div class="line">       [3, 4]])</div></pre></td></tr></table></figure>
<p>当数组中存储的是不同类型的元素时，数组将使用占用更多位的数据类型作为其本身的数据类型，也就是偏向更精确的数据类型，这种行为叫做 upcast：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.ones(3, dtype=numpy.int32)</div><div class="line">&gt;&gt;&gt; b = numpy.linspace(0, numpy.pi, 3)</div><div class="line">&gt;&gt;&gt; b.dtype.name</div><div class="line">&apos;float64&apos;</div><div class="line">&gt;&gt;&gt; c = a + b</div><div class="line">&gt;&gt;&gt; c.dtype.name</div><div class="line">&apos;float64&apos;</div><div class="line">&gt;&gt;&gt; d = numpy.exp(c*1j)</div><div class="line">&gt;&gt;&gt; d.dtype.name</div><div class="line">&apos;complex128&apos;</div></pre></td></tr></table></figure>
<p>许多非数组运算，如计算数组所有元素之和，都作为 ndarray 类的方法来实现，使用时需要用 ndarray 类的实例来调用这些方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.random.random((2,3))</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 0.68091784,  0.41612706,  0.86948767],</div><div class="line">       [ 0.78411139,  0.25901918,  0.6092565 ]])</div><div class="line">&gt;&gt;&gt; a.sum()</div><div class="line">3.6189196384603322</div><div class="line">&gt;&gt;&gt; a.min()</div><div class="line">0.2590191823646294</div><div class="line">&gt;&gt;&gt; a.max()</div><div class="line">0.86948766685829515</div></pre></td></tr></table></figure>
<p>这些运算将数组看作是一维线性列表。但可通过指定 axis 参数（即数组的行）对指定的轴做相应的运算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = numpy.arange(12).reshape(3,4)</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [ 4,  5,  6,  7],</div><div class="line">       [ 8,  9, 10, 11]])</div><div class="line">&gt;&gt;&gt; b.sum(axis=0)</div><div class="line">array([12, 15, 18, 21])</div><div class="line">&gt;&gt;&gt; b.min(axis=1)</div><div class="line">array([0, 4, 8])</div><div class="line">&gt;&gt;&gt; b.cumsum(axis=1)</div><div class="line">array([[ 0,  1,  3,  6],</div><div class="line">       [ 4,  9, 15, 22],</div><div class="line">       [ 8, 17, 27, 38]])</div></pre></td></tr></table></figure>
<h1 id="索引，切片和迭代"><a href="#索引，切片和迭代" class="headerlink" title="索引，切片和迭代"></a>索引，切片和迭代</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(10)**3</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])</div><div class="line">&gt;&gt;&gt; a[2]</div><div class="line">8</div><div class="line">&gt;&gt;&gt; a[2:5]</div><div class="line">array([ 8, 27, 64])</div><div class="line">&gt;&gt;&gt; a[:6:2] = -1000</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([-1000,     1, -1000,    27, -1000,   125,   216,   343,   512,   729])</div><div class="line">&gt;&gt;&gt; a[::-1]</div><div class="line">array([  729,   512,   343,   216,   125, -1000,    27, -1000,     1, -1000])</div></pre></td></tr></table></figure>
<p>多维数组可以每个轴有一个索引，这些索引由一个逗号分割的元组给出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def f(x,y):</div><div class="line">...     return 10*x+y</div><div class="line">...</div><div class="line">&gt;&gt;&gt; b = numpy.fromfunction(f, (5,4), dtype=int)</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line">&gt;&gt;&gt; b[2,3]</div><div class="line">23</div><div class="line">&gt;&gt;&gt; b[0:5,1]</div><div class="line">array([ 1, 11, 21, 31, 41])</div><div class="line">&gt;&gt;&gt; b[:,1]</div><div class="line">array([ 1, 11, 21, 31, 41])</div><div class="line">&gt;&gt;&gt; b[1:3,:]</div><div class="line">array([[10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23]])</div></pre></td></tr></table></figure>
<p>b[i] 中括号中的表达式被当做 i 和一系列 : 来代表剩下的轴。NumPy 允许使用 b[i, …]。’…’代表许多产生一个完整的索引元组必要的分号。如果 x 是秩为 5 的数组，那么：</p>
<ul>
<li>x[1,2,…] 等同于 x[1,2,:,:,:]</li>
<li>x[…,3] 等同于 x[:,:,:,:,3]</li>
<li>x[4,…,5,:] 等同于 x[4,:,:,5,:]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = numpy.arange(12).reshape((3,4))</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [ 4,  5,  6,  7],</div><div class="line">       [ 8,  9, 10, 11]])</div><div class="line">&gt;&gt;&gt; c.shape</div><div class="line">(3, 4)</div><div class="line">&gt;&gt;&gt; c[1,...]</div><div class="line">array([4, 5, 6, 7])</div><div class="line">&gt;&gt;&gt; c[...,2]</div><div class="line">array([ 2,  6, 10])</div></pre></td></tr></table></figure>
<p>如果想对数组中每个元素都进行处理，可以使用 <code>flat</code> 属性，该属性是一个数组元素迭代器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line">&gt;&gt;&gt; for element in b.flat:</div><div class="line">...     print element,</div><div class="line">...</div><div class="line">0 1 2 3 10 11 12 13 20 21 22 23 30 31 32 33 40 41 42 43</div></pre></td></tr></table></figure>
<h1 id="形状操作"><a href="#形状操作" class="headerlink" title="形状操作"></a>形状操作</h1><p>可以用多种方式修改数组的形状：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line">&gt;&gt;&gt; b.shape</div><div class="line">(5, 4)</div><div class="line"></div><div class="line">&gt;&gt;&gt; b.ravel() # 平坦化数组</div><div class="line">array([ 0,  1,  2,  3, 10, 11, 12, 13, 20, 21, 22, 23, 30, 31, 32, 33, 40,</div><div class="line">       41, 42, 43])</div><div class="line"></div><div class="line">&gt;&gt;&gt; b.shape = (10,2)</div><div class="line">&gt;&gt;&gt; b.transpose()</div><div class="line">array([[ 0,  2, 10, 12, 20, 22, 30, 32, 40, 42],</div><div class="line">       [ 1,  3, 11, 13, 21, 23, 31, 33, 41, 43]])</div></pre></td></tr></table></figure>
<p><code>reshape()</code> 函数改变调用数组的形状并返回该数组，而 <code>resize()</code> 函数改变调用数组自身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line"></div><div class="line">&gt;&gt;&gt; b.reshape((2,10))</div><div class="line">array([[ 0,  1,  2,  3, 10, 11, 12, 13, 20, 21],</div><div class="line">       [22, 23, 30, 31, 32, 33, 40, 41, 42, 43]])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line"></div><div class="line">&gt;&gt;&gt; b.resize((2,10))</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3, 10, 11, 12, 13, 20, 21],</div><div class="line">       [22, 23, 30, 31, 32, 33, 40, 41, 42, 43]])</div></pre></td></tr></table></figure>
<p>如果在 <code>reshape()</code> 操作中指定一个维度为 -1，那么其准确维度将根据实际情况计算得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line">&gt;&gt;&gt; b.reshape((4,-1))</div><div class="line">array([[ 0,  1,  2,  3, 10],</div><div class="line">       [11, 12, 13, 20, 21],</div><div class="line">       [22, 23, 30, 31, 32],</div><div class="line">       [33, 40, 41, 42, 43]])</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[numpy数组初探]]></title>
      <url>http://lizonghang.github.io/2016/07/20/numpy%E6%95%B0%E7%BB%84%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<h1 id="NumPy数组"><a href="#NumPy数组" class="headerlink" title="NumPy数组"></a>NumPy数组</h1><p>Numpy 数组是一个多维数组对象，称为 ndarray，由实际的数据和描述这些数据的元数据组成。大部分操作仅针对元数据，而不改变底层实际的数据。</p>
<p>关于 NumPy 数组需要知道：NumPy 数组的下标从 0 开始；同一个 NumPy 数组中的所有元素的类型必须是相同的。</p>
<h1 id="NumPy-数组属性"><a href="#NumPy-数组属性" class="headerlink" title="NumPy 数组属性"></a>NumPy 数组属性</h1><p>NumPy 数组的维数称为秩（rank），每一个线性的数组称为一个轴（axes），秩其实是描述轴的数量。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中的每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴，第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。</p>
<p>NumPy 的数组中比较重要的 ndarray 对象属性有：</p>
<ul>
<li><code>ndarray.ndim</code> - 数组的维数/秩。最常见为二维数组。</li>
<li><code>ndarray.shape</code> - 数组的维度。为一个表示数组在每个维度上大小的整数元组。例如二维数组中，表示数组的“行数”和“列数”。<code>ndarray.shape</code> 返回一个元组，这个元组的长度就是维度的数目，即 <code>ndim</code> 属性。</li>
<li><code>ndarray.size</code> - 数组元素的总个数，等于 <code>shape</code> 属性中元组元素的乘积。</li>
<li><code>ndarray.dtype</code> - 表示数组中元素类型的对象，可使用标准的 Python 类型创建或指定 <code>dtype</code>。</li>
<li><code>ndarray.itemsize</code> - 数组中每个元素的字节大小。例如一个元素类型为 float64 的数组 <code>itemsize</code> 属性值为 8，一个元素类型为 complex32 的数组 <code>itemsize</code> 属性为 4。</li>
<li><code>ndarray.data</code> - 包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</li>
</ul>
<h1 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h1><h2 id="numpy-array"><a href="#numpy-array" class="headerlink" title="numpy.array()"></a>numpy.array()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import numpy</div><div class="line">&gt;&gt;&gt; a = numpy.array([2,3,4])</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([2, 3, 4])</div><div class="line">&gt;&gt;&gt; a.dtype</div><div class="line">dtype(&apos;int64&apos;)</div><div class="line">&gt;&gt;&gt; b = numpy.array([1.2, 3.5, 5.1])</div><div class="line">&gt;&gt;&gt; b.dtype</div><div class="line">dtype(&apos;float64&apos;)</div></pre></td></tr></table></figure>
<p>使用 <code>numpy.array()</code> 函数创建时，参数必须是由方括号括起的列表，而不能使用多个数值作为参数调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.array(1,2,3,4)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: only 2 non-keyword arguments accepted</div></pre></td></tr></table></figure>
<p>可使用双重序列表示二维的数组，三重序列表示三维数组，以此类推：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = numpy.array([(1.5,2,3),(4,5,6)])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 1.5,  2. ,  3. ],</div><div class="line">       [ 4. ,  5. ,  6. ]])</div></pre></td></tr></table></figure>
<p>可以在创建时显式指定数组中元素的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = numpy.array([[1,2],[3,4]], dtype=complex)</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([[ 1.+0.j,  2.+0.j],</div><div class="line">       [ 3.+0.j,  4.+0.j]])</div></pre></td></tr></table></figure>
<h2 id="numpy-zeros-、numpy-ones-、numpy-empty"><a href="#numpy-zeros-、numpy-ones-、numpy-empty" class="headerlink" title="numpy.zeros()、numpy.ones()、numpy.empty()"></a>numpy.zeros()、numpy.ones()、numpy.empty()</h2><p>通常刚开始时数组的元素未知，而数组的大小已知。因此 NumPy 提供了一些使用占位符创建数组的函数。这些函数有助于满足除了数组扩展的需要，同时降低了高昂的运算开销。</p>
<p>用函数 <code>numpy.zeros()</code> 可创建一个全是 0 的数组，用函数 <code>numpy.ones()</code> 可创建一个全为 1 的数组，函数 <code>numpy.empty()</code> 创建一个内容随机并且依赖于内存状态的数组。默认创建的数组类型（dtype）都是 float64。</p>
<p>可以用 <code>d.dtype.itemsize</code> 来查看数组中元素占用的字节数目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = numpy.zeros((3,4))</div><div class="line">&gt;&gt;&gt; d.dtype</div><div class="line">dtype(&apos;float64&apos;)</div><div class="line">&gt;&gt;&gt; d</div><div class="line">array([[ 0.,  0.,  0.,  0.],</div><div class="line">       [ 0.,  0.,  0.,  0.],</div><div class="line">       [ 0.,  0.,  0.,  0.]])</div><div class="line">&gt;&gt;&gt; d.dtype.itemsize</div><div class="line">8</div></pre></td></tr></table></figure>
<p>也可以自己制定数组中元素的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.ones((2,3,4), dtype=numpy.int8)</div><div class="line">array([[[1, 1, 1, 1],</div><div class="line">        [1, 1, 1, 1],</div><div class="line">        [1, 1, 1, 1]],</div><div class="line"></div><div class="line">       [[1, 1, 1, 1],</div><div class="line">        [1, 1, 1, 1],</div><div class="line">        [1, 1, 1, 1]]], dtype=int8)</div><div class="line">&gt;&gt;&gt; numpy.empty((2,3))</div><div class="line">array([[ 0.,  0.,  0.],</div><div class="line">       [ 0.,  0.,  0.]])</div></pre></td></tr></table></figure>
<h2 id="numpy-arange"><a href="#numpy-arange" class="headerlink" title="numpy.arange()"></a>numpy.arange()</h2><p>NumPy 提供一个类似 <code>arange()</code> 的函数返回一个数列形式的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.arange(10,30,5)</div><div class="line">array([10, 15, 20, 25])</div><div class="line">&gt;&gt;&gt; numpy.arange(0,2,0.5)</div><div class="line">array([ 0. ,  0.5,  1. ,  1.5])</div></pre></td></tr></table></figure>
<h2 id="numpy-linspace"><a href="#numpy-linspace" class="headerlink" title="numpy.linspace()"></a>numpy.linspace()</h2><p>当 <code>numpy.arange()</code> 使用浮点数参数时，由于浮点数精度有限，通常无法预测获得的元素个数。因此，最好使用函数 <code>numpy.linspace()</code> 去接收我们想要的元素个数来代替用 <code>range</code> 来指定步长：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.linspace(-1, 0, 5)</div><div class="line">array([-1.  , -0.75, -0.5 , -0.25,  0.  ])</div></pre></td></tr></table></figure>
<p>数组中的元素是通过下标来访问的，可以以切片的形式访问数组中多个元素。</p>
<h1 id="NumPy基本数据类型"><a href="#NumPy基本数据类型" class="headerlink" title="NumPy基本数据类型"></a>NumPy基本数据类型</h1><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>用一个字节存储的布尔类型</td>
<td>True / False</td>
</tr>
<tr>
<td>int8</td>
<td>整数</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>int16</td>
<td>整数</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td>int32</td>
<td>整数</td>
<td>-2^31 ~ 2^31-1</td>
</tr>
<tr>
<td>int64</td>
<td>整数</td>
<td>-2^63 ~ 2^63-1</td>
</tr>
<tr>
<td>uint8</td>
<td>无符号整数</td>
<td>0 ~ 255</td>
</tr>
<tr>
<td>uint16</td>
<td>无符号整数</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td>uint32</td>
<td>无符号整数</td>
<td>0 ~ 2^32-1</td>
</tr>
<tr>
<td>uint64</td>
<td>无符号整数</td>
<td>0 ~ 2^64-1</td>
</tr>
<tr>
<td>float16</td>
<td>半精度浮点数16位</td>
<td>正负号1位，指数5位，精度10位</td>
</tr>
<tr>
<td>float32</td>
<td>单精度浮点数32位</td>
<td>正负号1位，指数8位，精度23位</td>
</tr>
<tr>
<td>float64</td>
<td>双精度浮点数64位</td>
<td>正负号1位，指数11位，精度52位</td>
</tr>
<tr>
<td>float</td>
<td>双精度浮点数64位</td>
<td>正负号1位，指数11位，精度52位</td>
</tr>
<tr>
<td>complex64</td>
<td>复数</td>
<td>分别用两个32位浮点数表示实部和虚部</td>
</tr>
<tr>
<td>complex128</td>
<td>复数</td>
<td>分别用两个64位浮点数表示实部和虚部</td>
</tr>
<tr>
<td>complex</td>
<td>复数</td>
<td>分别用两个64位浮点数表示实部和虚部</td>
</tr>
</tbody>
</table>
</div>
<h2 id="NumPy类型转换"><a href="#NumPy类型转换" class="headerlink" title="NumPy类型转换"></a>NumPy类型转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.float64(42)</div><div class="line">42.0</div><div class="line">&gt;&gt;&gt; numpy.int8(42.0)</div><div class="line">42</div><div class="line">&gt;&gt;&gt; numpy.bool(42)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; numpy.bool(42.0)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; numpy.float(True)</div><div class="line">1.0</div></pre></td></tr></table></figure>
<p>许多函数的参数中可以指定参数的类型，这个类型参数是可选的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.arange(7, dtype=numpy.uint16)</div><div class="line">array([0, 1, 2, 3, 4, 5, 6], dtype=uint16)</div></pre></td></tr></table></figure>
<h1 id="输出数组"><a href="#输出数组" class="headerlink" title="输出数组"></a>输出数组</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(6)</div><div class="line">&gt;&gt;&gt; print a</div><div class="line">[0 1 2 3 4 5]</div><div class="line"></div><div class="line">&gt;&gt;&gt; b = numpy.arange(12).reshape(4,3)</div><div class="line">&gt;&gt;&gt; print b</div><div class="line">[[ 0  1  2]</div><div class="line"> [ 3  4  5]</div><div class="line"> [ 6  7  8]</div><div class="line"> [ 9 10 11]]</div><div class="line"> </div><div class="line">&gt;&gt;&gt; c = numpy.arange(24).reshape(2,3,4)</div><div class="line">&gt;&gt;&gt; print c</div><div class="line">[[[ 0  1  2  3]</div><div class="line">  [ 4  5  6  7]</div><div class="line">  [ 8  9 10 11]]</div><div class="line"></div><div class="line"> [[12 13 14 15]</div><div class="line">  [16 17 18 19]</div><div class="line">  [20 21 22 23]]]</div></pre></td></tr></table></figure>
<p>如果一个数组太长，则 NumPy 自动省略中间部分而只打印两端的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print numpy.arange(10000)</div><div class="line">[   0    1    2 ..., 9997 9998 9999]</div><div class="line"></div><div class="line">&gt;&gt;&gt; print numpy.arange(10000).reshape(100,100)</div><div class="line">[[   0    1    2 ...,   97   98   99]</div><div class="line"> [ 100  101  102 ...,  197  198  199]</div><div class="line"> [ 200  201  202 ...,  297  298  299]</div><div class="line"> ...,</div><div class="line"> [9700 9701 9702 ..., 9797 9798 9799]</div><div class="line"> [9800 9801 9802 ..., 9897 9898 9899]</div><div class="line"> [9900 9901 9902 ..., 9997 9998 9999]]</div></pre></td></tr></table></figure>
<p>可以通过设置 <code>set_printoptions()</code> 函数来禁用 NumPy 的这种行为并强制打印整个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.set_printoptions(threshold=&apos;nan&apos;)</div><div class="line">&gt;&gt;&gt; print numpy.arange(10000).reshape(100,100)</div></pre></td></tr></table></figure>
<p>此后输出时数组的所有元素都会显示出来。</p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[socket网络通信——TCP/IP客户和服务器]]></title>
      <url>http://lizonghang.github.io/2016/07/18/socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94TCP-IP%E5%AE%A2%E6%88%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="TCP-IP客户和服务器"><a href="#TCP-IP客户和服务器" class="headerlink" title="TCP/IP客户和服务器"></a>TCP/IP客户和服务器</h1><p>套接字可以配置为一个服务器，监听到来的消息，或者也可以配置为客户，连接到其他应用。TCP/IP 套接字的两端连接后，可以完成双向通信。</p>
<h2 id="回应服务器"><a href="#回应服务器" class="headerlink" title="回应服务器"></a>回应服务器</h2><p>下面的例子接收到来的消息，再回复给发送者。首先创建一个 TCP/IP 套接字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div></pre></td></tr></table></figure>
<p>然后使用 <code>bind()</code> 将这个套接字与服务器地址关联。在这里，地址是 localhost （当前服务器），端口号为 10000：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sock.bind((&apos;localhost&apos;, 10000))</div></pre></td></tr></table></figure>
<p>调用 <code>listen()</code> 将这个套接字置为服务器模式，调用 <code>accept()</code> 等待到来的连接。整数参数是在后台排队的连接数，达到这个连接数后，系统会拒绝连接新用户。该例希望一次只处理一个连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sock.listen(1)</div><div class="line">while True:</div><div class="line">    print &apos;wait for a connection&apos;</div><div class="line">    connection, client_address = sock.accept()</div></pre></td></tr></table></figure>
<p><code>accept()</code> 返回服务器和客户之间的一个打开的连接，并返回客户地址。这个连接实际上是另一个端口上的一个不同的套接字（由内核分配）。数据使用 <code>recv()</code> 从连接读取，并用 <code>sendall()</code> 传输。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">    print &apos;connection from &apos;, client_address</div><div class="line">    while True:</div><div class="line">        data = connection.revc(16)</div><div class="line">        print &apos;received &apos;, data</div><div class="line">        if data:</div><div class="line">            print &apos;sending data back to the client&apos;</div><div class="line">            connection.sendall(data)</div><div class="line">        else:</div><div class="line">            print &apos;no data from &apos;, client_address</div><div class="line">            break</div><div class="line">finally:</div><div class="line">    connection.close()</div></pre></td></tr></table></figure>
<p>与一个客户的通信完成时，需要用 <code>close()</code> 清理这个连接。例子使用 <code>finally</code> 确保 <code>close()</code> 总会被调用，即时出现了一个错误也不例外。</p>
<p>服务器端全部代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">sock.bind((&apos;localhost&apos;, 10000))</div><div class="line">sock.listen(1)</div><div class="line">while True:</div><div class="line">    print &apos;wait for a connection&apos;</div><div class="line">    connection, client_address = sock.accept()</div><div class="line">    try:</div><div class="line">        print &apos;connection from &apos;, client_address</div><div class="line">        while True:</div><div class="line">            data = connection.recv(16)</div><div class="line">            print &apos;received &apos;, data</div><div class="line">            if data:</div><div class="line">                print &apos;sending data back to the client&apos;</div><div class="line">                connection.sendall(data)</div><div class="line">            else:</div><div class="line">                print &apos;no data from &apos;, client_address</div><div class="line">                break</div><div class="line">    finally:</div><div class="line">        connection.close()</div><div class="line">        print &apos;connection closed()&apos;</div></pre></td></tr></table></figure>
<h2 id="回应客户"><a href="#回应客户" class="headerlink" title="回应客户"></a>回应客户</h2><p>与服务器不同，客户程序采用另一种方式建立 socket。它不绑定到一个端口并监听，而是使用 <code>connect()</code> 将套接字直接关联到远程地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">print &apos;connecting to server&apos;</div><div class="line">sock.connect((&apos;localhost&apos;, 10000))</div></pre></td></tr></table></figure>
<p>建立连接后，可以通过 socket 利用 <code>sendall()</code> 发送数据，并用 <code>recv()</code> 接收数据，这和服务器中是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">    message = &apos;abcdefghijklmnopqrstuvwxyz&apos;</div><div class="line">    sock.sendall(message)</div><div class="line">    amount_received = 0</div><div class="line">    amount_expected = len(message)</div><div class="line">    while amount_received &lt; amount_expected:</div><div class="line">        data = sock.recv(16)</div><div class="line">        amount_received += len(data)</div><div class="line">        print &apos;received &apos;, data</div><div class="line">finally:</div><div class="line">    print &apos;socket closed&apos;</div><div class="line">    sock.close()</div></pre></td></tr></table></figure>
<p>发送了整个消息并接收到一个副本时，套接字会关闭，以释放端口。</p>
<p>客户端全部代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">print &apos;connecting to server&apos;</div><div class="line">sock.connect((&apos;localhost&apos;, 10000))</div><div class="line">try:</div><div class="line">    message = &apos;abcdefghijklmnopqrstuvwxyz&apos;</div><div class="line">    sock.sendall(message)</div><div class="line">    amount_received = 0</div><div class="line">    amount_expected = len(message)</div><div class="line">    while amount_received &lt; amount_expected:</div><div class="line">        data = sock.recv(16)</div><div class="line">        amount_received += len(data)</div><div class="line">        print &apos;received &apos;, data</div><div class="line">finally:</div><div class="line">    print &apos;socket closed&apos;</div><div class="line">    sock.close()</div></pre></td></tr></table></figure>
<h2 id="客户与服务器"><a href="#客户与服务器" class="headerlink" title="客户与服务器"></a>客户与服务器</h2><p>要在不同的终端窗口运行客户和服务器，使它们能够相互通信。服务器输出显示了到来的连接和数据，以及发回给客户的响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">wait for a connection</div><div class="line">connection from  (&apos;127.0.0.1&apos;, 50124)</div><div class="line">received  abcdefghijklmnop</div><div class="line">sending data back to the client</div><div class="line">received  qrstuvwxyz</div><div class="line">sending data back to the client</div><div class="line">received</div><div class="line">no data from  (&apos;127.0.0.1&apos;, 50124)</div><div class="line">connection closed()</div><div class="line">wait for a connection</div></pre></td></tr></table></figure>
<p>客户端输出显示了来自服务器的响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">connecting to server</div><div class="line">received  abcdefghijklmnop</div><div class="line">received  qrstuvwxyz</div><div class="line">socket closed</div></pre></td></tr></table></figure>
<h2 id="简易客户连接"><a href="#简易客户连接" class="headerlink" title="简易客户连接"></a>简易客户连接</h2><p>如何使用便利函数 <code>create_connection()</code> 来连接服务器，TCP/IP 客户可以省去几步。这个函数只有一个参数，这是一个包含服务器地址的二值元组，函数将由这个参数推导出用于连接的最佳地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">def get_constants(prefix):</div><div class="line">    return dict((getattr(socket, n), n) for n in dir(socket) if n.startswith(prefix))</div><div class="line"></div><div class="line">families = get_constants(&apos;AF_&apos;)</div><div class="line">types = get_constants(&apos;SOCK_&apos;)</div><div class="line">protocols = get_constants(&apos;IPPROTO_&apos;)</div><div class="line"></div><div class="line">sock = socket.create_connection((&apos;localhost&apos;, 10000))</div><div class="line">print &apos;Family: &apos;, families[sock.family]</div><div class="line">print &apos;Type: &apos;, types[sock.type]</div><div class="line">print &apos;Protocol: &apos;, protocols[sock.proto]</div><div class="line">print</div><div class="line"></div><div class="line">try:</div><div class="line">    message = &apos;This is the message, It will be repeated.&apos;</div><div class="line">    print &apos;sending &quot;%s&quot;&apos; % message</div><div class="line">    sock.sendall(message)</div><div class="line">    amount_received = 0</div><div class="line">    amount_expected = len(message)</div><div class="line">    while amount_received &lt; amount_expected:</div><div class="line">        data = sock.recv(16)</div><div class="line">        amount_received += len(data)</div><div class="line">        print &apos;received &quot;%s&quot;&apos; % data</div><div class="line">finally:</div><div class="line">    sock.close()</div><div class="line">    print &apos;socket closed&apos;</div></pre></td></tr></table></figure>
<p><code>create_connection()</code> 使用 <code>getaddrinfo()</code> 来查找候选连接参数，并返回一个打开的 socket，它的第一个配置可以成功创建一个连接。可以检查 family、type 和 proto 属性确定返回的 socket 类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Family:  AF_INET</div><div class="line">Type:  SOCK_STREAM</div><div class="line">Protocol:  IPPROTO_TCP</div><div class="line"></div><div class="line">sending &quot;This is the message, It will be repeated.&quot;</div><div class="line">received &quot;This is the mess&quot;</div><div class="line">received &quot;age, It will be &quot;</div><div class="line">received &quot;repeated.&quot;</div><div class="line">socket closed</div></pre></td></tr></table></figure>
<h2 id="选择监听地址"><a href="#选择监听地址" class="headerlink" title="选择监听地址"></a>选择监听地址</h2><p>将服务器绑定到正确的地址很重要，这样客户才能与之通信。前面的例子都使用 <code>‘localhost’</code> 作为 IP 地址，这会限制为只能连接在同一服务器上运行的客户。可以使用服务器的一个公共地址，如 <code>gethostname()</code> 返回的值，从而允许其他主机连接。下面的例子修改了回应服务器，让它监听一个指定的地址，例如服务器地址 114.215.121.63 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">server_address = (&apos;114.215.121.63&apos;, 10000)</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">sock.bind(server_address)</div><div class="line">sock.listen(1)</div><div class="line">while True:</div><div class="line">    print &apos;wait for a connection&apos;</div><div class="line">    connection, client_address = sock.accept()</div><div class="line">    try:</div><div class="line">        print &apos;client connected: &apos;, client_address</div><div class="line">        while True:</div><div class="line">            data = connection.recv(16)</div><div class="line">            print &apos;received &apos;, data</div><div class="line">            if data:</div><div class="line">                connection.sendall(data)</div><div class="line">            else:</div><div class="line">                break</div><div class="line">    finally:</div><div class="line">        connection.close()</div></pre></td></tr></table></figure>
<p>测试之前，需要对客户程序做类似的修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">server_address = (&apos;114.215.121.63&apos;, 10000)</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">print &apos;connecting to server&apos;</div><div class="line">sock.connect(server_address)</div><div class="line">try:</div><div class="line">    message = &apos;This is the message, it will be repeat later.&apos;</div><div class="line">    print &apos;sending &quot;%s&quot;&apos; % message</div><div class="line">    sock.sendall(message)</div><div class="line">    amount_received = 0</div><div class="line">    amount_expected = len(message)</div><div class="line">    while amount_received &lt; amount_expected:</div><div class="line">        data = sock.recv(16)</div><div class="line">        amount_received += len(data)</div><div class="line">        print &apos;received &apos;, data</div><div class="line">finally:</div><div class="line">    print &apos;socket closed&apos;</div><div class="line">    sock.close()</div></pre></td></tr></table></figure>
<p>在服务器 114.215.121.63 上启动服务器程序，监听端口 10000。在另一个主机上运行客户端程序，会产生以下结果：</p>
<p>服务器端输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wait for a connection</div><div class="line">client connected:  (&apos;171.212.168.187&apos;, 50688)</div><div class="line">received  This is the mess</div><div class="line">received  age, it will be</div><div class="line">received  repeat later.</div><div class="line">received</div><div class="line">wait for a connection</div></pre></td></tr></table></figure>
<p>客户端输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">connecting to server</div><div class="line">sending &quot;This is the message, it will be repeat later.&quot;</div><div class="line">received  This is the mess</div><div class="line">received  age, it will be</div><div class="line">received  repeat later.</div><div class="line">socket closed</div></pre></td></tr></table></figure>
<p>很多服务器有不止一个网络接口，相应的会有不止一个 IP 地址。并不需要运行服务的不同副本分别绑定到各个 IP 地址，可以使用一个特殊的地址 <code>INADDR_ANY</code> 同时监听所有地址。socket 为 <code>INADDR_ANY</code> 定义了一个常量，这是一个整数值，但在传递到 <code>bind()</code> 之前必须将它转换为采用点记法的地址字符串。作为一种快捷方式，可以使用 ‘0.0.0.0’ 或者空串，而不是完成转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server_address = (&apos;&apos;, 10000)</div></pre></td></tr></table></figure>
<p>要看一个套接字使用的具体地址，可以调用其 <code>getsockname()</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">server_address = (&apos;&apos;, 10000)</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">sock.bind(server_address)</div><div class="line">print &apos;starting up on %s, port %s&apos; % sock.getsockname()</div></pre></td></tr></table></figure>
<p>输出的套接字使用的具体地址如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">starting up on 0.0.0.0, port 10000</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 网络通信 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[图像载入、显示、复制、新建和保存]]></title>
      <url>http://lizonghang.github.io/2016/07/17/OpenCV-Python%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>OpenCV的全称是Open Source Computer Vision Library，是一个跨平台的计算机视觉库。OpenCV可用于开发实时的图像处理、计算机视觉以及模式识别程序。OpenCV可用于解决如下领域的问题：</p>
<ul>
<li>人机交互</li>
<li>物体识别</li>
<li>图像分区</li>
<li>人脸识别</li>
<li>动作识别</li>
<li>运动跟踪</li>
<li>机器人</li>
</ul>
<p>OpenCV可以在Windows, Android, Maemo, FreeBSD, OpenBSD, iOS, Linux和Mac OS等平台上运行。</p>
<p>OpenCV1.0时代的基于 C 语言接口而建的图像存储格式IplImage*，如果在退出前忘记release掉的话，就会照成内存泄露。这导致debug时越来越多的纠缠于内存管理，而不是着力解决开发目标。但自从OpenCV踏入2.0时代用Mat类数据结构作为主打之后，OpenCV变得越发像Matlab那样，上手非常快。甚至有些函数名称都和matlab一样，比如大家所熟知的imread，imwrite，imshow等函数。</p>
<p><code>cv::Mat</code>类是用于保存图像以及其他矩阵数据的数据结构。默认情况下，其尺寸为0，我们也可以指定初始尺寸,比如定义一个Mat类对象，就要写<code>cv::Mat pic(320,640,cv::Scalar(100));</code>。它是对应于OpenCV1.0时代的IplImage的主要用来存放图像的数据结构。</p>
<h1 id="读取并显示图像"><a href="#读取并显示图像" class="headerlink" title="读取并显示图像"></a>读取并显示图像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;) # 读取文件</div><div class="line">cv2.namedWindow(&apos;lena&apos;) # 创建窗口</div><div class="line">cv2.imshow(&apos;lena&apos;, im) # 在窗口显示图像</div><div class="line"># cv2.waitKey(10000) # 等待10s</div><div class="line">cv2.waitKey(0) # 保持等待直到按下任意键</div><div class="line">cv2.destroyAllWindows() # 释放窗口</div></pre></td></tr></table></figure>
<h1 id="创建-复制图像"><a href="#创建-复制图像" class="headerlink" title="创建/复制图像"></a>创建/复制图像</h1><p>新的OpenCV的接口中没有CreateImage接口，如果要创建图像，需要使用numpy的函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">emptyImage = numpy.zeros(im.shape, numpy.uint8)</div></pre></td></tr></table></figure>
<p>图像使用NumPy数组的属性来表示图像的尺寸和通道信息。如果输出im.shape，将得到(750, 500, 3)，最后的3表示这是一个RGB图像。</p>
<p>也可以复制原图像得到新图像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tempImage = im.copy()</div></pre></td></tr></table></figure>
<p>还可以用cvtColor获得原图像的副本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tempImage = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)  </div><div class="line">tempImage[...] = 0 # 转成空白的黑色图像</div></pre></td></tr></table></figure>
<h1 id="保存图像"><a href="#保存图像" class="headerlink" title="保存图像"></a>保存图像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.imwrite(&apos;/Users/mac/Desktop/temp.jpg&apos;, tempImage)</div></pre></td></tr></table></figure>
<p>imwrite()有第三个可选参数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.imwrite(&apos;/Users/mac/Desktop/temp.jpg&apos;, tempImage, [int(cv2.IMWRITE_JPEG_QUALITY), 5])</div></pre></td></tr></table></figure>
<p>第三个参数针对特定的格式：</p>
<ul>
<li>对于JPEG，第三个参数表示的是图像的质量，用0-100的整数表示，默认为95。<code>cv2.IMWRITE_JPEG_QUALITY</code>类型为Long，必须转换成int。下面是以不同质量存储的两幅图：</li>
</ul>
<p>图像质量保存为5时：</p>
<p><img src="/images/temp_5.jpg" alt=""></p>
<p>图像质量保存为100时：</p>
<p><img src="/images/temp_100.jpg" alt=""></p>
<ul>
<li>对于PNG，第三个参数表示的是压缩级别。cv2.IMWRITE_PNG_COMPRESSION，从0到9,压缩级别越高，图像尺寸越小。默认级别为3：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cv2.imwrite(&quot;temp0.png&quot;, tempImage, [int(cv2.IMWRITE_PNG_COMPRESSION), 0])   </div><div class="line">cv2.imwrite(&quot;temp9.png&quot;, tempImage, [int(cv2.IMWRITE_PNG_COMPRESSION), 9])</div></pre></td></tr></table></figure>
<p>得到的图片存储大小分别为929KB和317KB</p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac上安装python-opencv]]></title>
      <url>http://lizonghang.github.io/2016/07/16/Mac%E4%B8%8A%E5%AE%89%E8%A3%85python-opencv/</url>
      <content type="html"><![CDATA[<p>如何正确安装OpenCV历来是一个堪称玄学的问题，在成功安装OpenCV的道路上经历了种种艰辛，这真的是我最恶心的一次安装经历。下载源码并编译的方法就不说了，下面介绍较简易的使用Homebrew安装的方法。</p>
<p>第一步：安装OpenCV</p>
<p>直接使用命令<code>brew install opencv</code>是不行的，因为homebrew找不到它，会产生如下报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">➜  ~ brew install opencv</div><div class="line">Error: No available formula with the name &quot;opencv&quot;</div><div class="line">==&gt; Searching for similarly named formulae...</div><div class="line">Error: No similarly named formulae found.</div><div class="line">==&gt; Searching taps...</div><div class="line">These formulae were found in taps:</div><div class="line">homebrew/science/opencv                  homebrew/science/opencv3</div><div class="line">To install one of them, run (for example):</div><div class="line">  brew install homebrew/science/opencv</div><div class="line">==&gt; You haven&apos;t updated Homebrew in a while.</div><div class="line">A formula for opencv might have been added recently.</div><div class="line">Run `brew update` to get the latest Homebrew updates!</div></pre></td></tr></table></figure>
<p>你需要先将opencv所在的science分类加入homebrew的搜索列表中再尝试下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ brew tap homebrew/science</div><div class="line">$ brew install opencv</div></pre></td></tr></table></figure>
<p>请留意安装过程中的输出信息，最好保存一下，之后可能有用，确保opencv正确安装后就可以删掉了。</p>
<p>安装过程中自动为你安装好了以下库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">==&gt; Installing dependencies for homebrew/science/opencv: eigen, ilmbase,</div><div class="line">==&gt; Installing homebrew/science/opencv dependency: eigen</div><div class="line">🍺  /usr/local/Cellar/eigen/3.2.8: 368 files, 3.5M</div><div class="line">==&gt; Installing homebrew/science/opencv dependency: ilmbase</div><div class="line">🍺  /usr/local/Cellar/ilmbase/2.2.0: 362 files, 5.6M</div><div class="line">==&gt; Installing homebrew/science/opencv dependency: openexr</div><div class="line">🍺  /usr/local/Cellar/openexr/2.2.0: 131 files, 11.4M</div><div class="line">==&gt; Installing homebrew/science/opencv dependency: homebrew/python/numpy</div><div class="line">🍺  /usr/local/Cellar/numpy/1.11.1: 430 files, 9M</div><div class="line">==&gt; Installing homebrew/science/opencv</div><div class="line">🍺  /usr/local/Cellar/opencv/2.4.13: 276 files, 35.8M</div></pre></td></tr></table></figure>
<p>其中已为你安装好numpy，其版本为1.11.1，如果你此前已经通过pip安装过numpy了，那需要很多额外步骤。</p>
<p>进入python环境，测试opencv是否正确安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import cv2</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ImportError: No module named cv2</div></pre></td></tr></table></figure>
<p>python找不到opencv，这就蛋疼了。翻看opencv的安装记录，有如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Python modules have been installed and Homebrew&apos;s site-packages is not</div><div class="line">in your Python sys.path, so you will not be able to import the modules</div><div class="line">this formula installed. If you plan to develop with these modules,</div><div class="line">please run:</div><div class="line">  mkdir -p /Users/mac/Library/Python/2.7/lib/python/site-packages</div><div class="line">  echo &apos;import site; site.addsitedir(&quot;/usr/local/lib/python2.7/site-packages&quot;)&apos; &gt;&gt; /Users/mac/Library/Python/2.7/lib/python/site-packages/homebrew.pth</div></pre></td></tr></table></figure>
<p>Homebrew的site-packages不在python的sys.path路径中，所以python无法导入安装好的opencv模块，如果想要python能够找到，执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir -p /Users/mac/Library/Python/2.7/lib/python/site-packages</div><div class="line">$ echo &apos;import site; site.addsitedir(&quot;/usr/local/lib/python2.7/site-packages&quot;)&apos; &gt;&gt; /Users/mac/Library/Python/2.7/lib/python/site-packages/homebrew.pth</div></pre></td></tr></table></figure>
<p>再尝试<code>import cv2</code>，可能会有如下报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RuntimeError: module compiled against API version 0xa but this version of numpy is 0x9</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ImportError: numpy.core.multiarray failed to import</div></pre></td></tr></table></figure>
<p>这是由于numpy版本过低导致的，可能是你系统中已经安装的numpy版本不能满足opencv的需求。并且没有提示找不到模块，所以python能正确找到opencv了。尝试<code>sudo pip uninstall numpy</code>，可能会有下面的报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Exception:</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/basecommand.py&quot;, line 215, in main</div><div class="line">    status = self.run(options, args)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/commands/uninstall.py&quot;, line 76, in run</div><div class="line">    requirement_set.uninstall(auto_confirm=options.yes)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/req/req_set.py&quot;, line 336, in uninstall</div><div class="line">    req.uninstall(auto_confirm=auto_confirm)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/req/req_install.py&quot;, line 742, in uninstall</div><div class="line">    paths_to_remove.remove(auto_confirm)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/req/req_uninstall.py&quot;, line 115, in remove</div><div class="line">    renames(path, new_path)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/utils/__init__.py&quot;, line 267, in renames</div><div class="line">    shutil.move(old, new)</div><div class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 302, in move</div><div class="line">    copy2(src, real_dst)</div><div class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 131, in copy2</div><div class="line">    copystat(src, dst)</div><div class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 103, in copystat</div><div class="line">    os.chflags(dst, st.st_flags)</div><div class="line">OSError: [Errno 1] Operation not permitted: &apos;/tmp/pip-8Z9Jmh-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy-1.8.0rc1-py2.7.egg-info&apos;</div><div class="line">The directory &apos;/Users/mac/Library/Caches/pip/http&apos; or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo&apos;s -H flag.</div></pre></td></tr></table></figure>
<p>并且，在使用<code>sudo pip install matplotlib</code>时也有类似的报错。可以改成<code>sudo pip install --ignore-installed matplotlib</code>试试。</p>
<p>这是由于System Integrity Protection导致的，需要关闭保护SIP，否则即时加了sudo也没用，尝试卸载和升级都需要关闭保护SIP。后面会介绍一种更简单的方法，这一段可略过。具体操作如下：</p>
<ol>
<li>重启电脑，电脑启动的时候按住command+R</li>
<li>等画面上显示苹果logo后会看到[OS X 工具程式]窗口，选择终端，要把键盘按下去，不要轻按</li>
<li>终端打开后输入<code>csrutil disable</code>，之后重启</li>
</ol>
<p>重启之后再升级或重装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install --upgrade numpy</div></pre></td></tr></table></figure>
<p>另一种更简单的方式和安装opencv时一样隐藏在安装信息中，就在opencv路径信息的上一段里，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &apos;import sys; sys.path.insert(1, &quot;/usr/local/lib/python2.7/site-packages&quot;)&apos; &gt;&gt; /Users/mac/Library/Python/2.7/lib/python/site-packages/homebrew.pth</div></pre></td></tr></table></figure>
<p>由于<code>mkdir -p /Users/mac/Library/Python/2.7/lib/python/site-packages</code>之前已经创建过了，可以不再创建。执行完命令后，重启一下终端，再进入python环境测试是否能正确导入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import cv2</div><div class="line">&gt;&gt;&gt; import numpy</div><div class="line">&gt;&gt;&gt; from matplotlib import pyplot</div></pre></td></tr></table></figure>
<p>本机异常已消除，若还有其他异常，请另行寻找解决方法。以下是本机安装的版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print cv2.__version__</div><div class="line">2.4.13</div><div class="line">&gt;&gt;&gt; print numpy.__version__</div><div class="line">1.11.1</div><div class="line">&gt;&gt;&gt; print matplotlib.__version__</div><div class="line">1.3.1</div></pre></td></tr></table></figure>
<p>希望这篇文章能帮助你脱离玄学的道路。</p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[儿童锁屏幕监测报警]]></title>
      <url>http://lizonghang.github.io/2016/07/15/%E5%84%BF%E7%AB%A5%E9%94%81%E5%B1%8F%E5%B9%95%E7%9B%91%E6%B5%8B%E6%8A%A5%E8%AD%A6/</url>
      <content type="html"><![CDATA[<p>这是一个丧尽天良的程序，用于家长对孩子使用电脑时的监控，当程序发现屏幕上出现了疑似色情的图片/视频时，将屏幕进行截图保存并邮件通知家长，也能判断出程序是否正常退出。可以设置采样间隔与监控时间，可以设置截图保存路径与图片尺寸。</p>
<p>假设文件名为ScreenScrape.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># encoding: utf-8</div><div class="line">from PIL import Image, ImageGrab</div><div class="line">import time</div><div class="line">import argparse</div><div class="line">import smtplib</div><div class="line">from email import encoders</div><div class="line">from email.header import Header</div><div class="line">from email.mime.text import MIMEText</div><div class="line">from email.utils import parseaddr, formataddr</div><div class="line"></div><div class="line">parser = argparse.ArgumentParser()</div><div class="line">parser.add_argument(&apos;p&apos;, help=&apos;Path to Save the Images.&apos;)</div><div class="line">parser.add_argument(&apos;-W&apos;, help=&apos;Width of the Scraped Images&apos;, default=1000)</div><div class="line">parser.add_argument(&apos;-H&apos;, help=&apos;Height of the Scraped Images.&apos;, default=600)</div><div class="line">parser.add_argument(&apos;-d&apos;, help=&apos;Scrape Duration(Minute).&apos;, default=1)</div><div class="line">parser.add_argument(&apos;-t&apos;, help=&apos;Total Scrape Time(Minute)&apos;, default=30)</div><div class="line">args = parser.parse_args()</div><div class="line"># 图片存放路径、图片尺寸、检测间隔、检测时长</div><div class="line">path, width, height, duration, totalTime = args.p, int(args.W), int(args.H), float(args.d), float(args.t)</div><div class="line"></div><div class="line">message = u&apos;屏幕检测到异常截图，请及时查看您的电脑&apos;</div><div class="line">fromUser = &apos;user_to_send_email&apos;</div><div class="line">password = &apos;vaelgxgnybtlbafd&apos; # 开启SMTP/POP3等，获得的校验码为密码，不是登陆密码</div><div class="line">toUser = &apos;user_to_receive_email&apos;</div><div class="line">smtp_server = &apos;smtp.qq.com&apos; # 可以是其他邮件代理服务器</div><div class="line"></div><div class="line">send_once = False # 只发送一次邮件</div><div class="line"></div><div class="line">start_time = int(time.time())</div><div class="line">def inTotalTime():</div><div class="line">    &apos;&apos;&apos;判断检测时间是否到时，上限时间totalTime&apos;&apos;&apos;</div><div class="line">    now_time = int(time.time())</div><div class="line">    elapseTimeByMinutes = (now_time - start_time) / 60.0</div><div class="line">    if elapseTimeByMinutes &lt; totalTime:</div><div class="line">        return True</div><div class="line">    else:</div><div class="line">        return False</div><div class="line"></div><div class="line">def _format_addr(s):</div><div class="line">    &apos;&apos;&apos;调整邮件信息格式&apos;&apos;&apos;</div><div class="line">    name, addr = parseaddr(s)</div><div class="line">    return formataddr((Header(name, &apos;utf-8&apos;).encode(), addr.encode(&apos;utf-8&apos;) if isinstance(addr, unicode) else addr))</div><div class="line"></div><div class="line">def sendMessage(message, fromUser, password, toUser, smtp_server):</div><div class="line">    &apos;&apos;&apos;发送邮件&apos;&apos;&apos;</div><div class="line">    msg = MIMEText(message, &apos;plain&apos;, &apos;utf-8&apos;)</div><div class="line">    # 下面三项不标明可能被当作垃圾邮件，导致接收方收不到邮件</div><div class="line">    msg[&apos;From&apos;] = _format_addr(u&apos;Mac管理员-%s&apos; % fromUser) # 邮件中标明发件人</div><div class="line">    msg[&apos;To&apos;] = _format_addr(u&apos;家长-%s&apos; % toUser) # 邮件中标明收件人</div><div class="line">    msg[&apos;Subject&apos;] = Header(u&apos;屏幕监测报告&apos;, &apos;utf-8&apos;).encode() # 邮件标题</div><div class="line">    server = smtplib.SMTP_SSL(smtp_server, 465)</div><div class="line">    # server.set_debuglevel(1) # 发送邮件过程中的详细信息</div><div class="line">    server.login(fromUser, password)</div><div class="line">    server.sendmail(fromUser, toUser, msg.as_string())</div><div class="line">    server.quit()</div><div class="line"></div><div class="line">def handleRudeImage(im):</div><div class="line">    &apos;&apos;&apos;保存截图并发送邮件通知&apos;&apos;&apos;</div><div class="line">    filename = str(int(time.time())) + &apos;.jpg&apos;</div><div class="line">    im.save(path+filename, &apos;JPEG&apos;)</div><div class="line">    global send_once</div><div class="line">    if not send_once:</div><div class="line">        sendMessage(message, fromUser, password, toUser, smtp_server)</div><div class="line">        send_once = True</div><div class="line"></div><div class="line">def screenScrape():</div><div class="line">    &apos;&apos;&apos;屏幕截取、鉴黄与处置&apos;&apos;&apos;</div><div class="line">    im = ImageGrab.grab().resize((width, height)).convert(&apos;YCbCr&apos;)</div><div class="line">    w, h = im.size</div><div class="line">    sx = im.getdata()</div><div class="line">    count = 0</div><div class="line">    for i, ycbcr in enumerate(sx):</div><div class="line">        y, cb, cr = ycbcr</div><div class="line">        if 86 &lt;= cb &lt;= 117 and 140 &lt;= cr &lt;= 168:</div><div class="line">            count += 1</div><div class="line">    if count &gt; w * h * 0.3:</div><div class="line">        handleRudeImage(im)</div><div class="line">#        print &apos;Sexy Playing&apos;</div><div class="line">#    else:</div><div class="line">#        print &apos;Normal&apos;</div><div class="line">    im.close()</div><div class="line"></div><div class="line">while inTotalTime():</div><div class="line">    time.sleep(duration*60) # 间隔duration分钟对屏幕采样</div><div class="line">    screenScrape()</div><div class="line"></div><div class="line"># 程序正常退出提醒</div><div class="line">sendMessage(u&apos;监控程序正常退出&apos;, fromUser, password, toUser, smtp_server)</div></pre></td></tr></table></figure>
<p>运行程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python ScreenScrape.py path [-W Width] [-H Height] [-d duration] [-t totalTime]</div></pre></td></tr></table></figure>
<ul>
<li>path - 存放截图的文件夹，必选</li>
<li>Width - 存储截图时的截图宽度，可选</li>
<li>Height - 存储截图时的截图高度，可选</li>
<li>duration - 采样周期，单位min，可选</li>
<li>totalTime - 监控时长，单位min，可选</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[多张图片合成GIF图]]></title>
      <url>http://lizonghang.github.io/2016/07/14/%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90GIF%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p>require:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install Pillow</div><div class="line">$ sudo pip install images2gif</div></pre></td></tr></table></figure>
<h1 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h1><p>将以下gif图分割为多张静态PNG格式图，并以这些PNG图为例：</p>
<p><img src="/images/niko.gif" alt=""></p>
<h1 id="帧分割"><a href="#帧分割" class="headerlink" title="帧分割"></a>帧分割</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line"></div><div class="line">im = Image.open(&apos;niko.gif&apos;)</div><div class="line">im.seek(0)</div><div class="line"></div><div class="line">try:</div><div class="line">    while True:</div><div class="line">        im.save(&apos;./nikos/&apos; + chr(im.tell() + ord(&apos;a&apos;))  + &apos;.png&apos;, &apos;PNG&apos;)</div><div class="line">        im.seek(im.tell()+1)</div><div class="line">except EOFError, msg:</div><div class="line">    pass</div></pre></td></tr></table></figure>
<h1 id="帧合成"><a href="#帧合成" class="headerlink" title="帧合成"></a>帧合成</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">#encoding: utf-8</div><div class="line">from PIL import Image</div><div class="line">import os</div><div class="line">import images2gif</div><div class="line">import argparse</div><div class="line"></div><div class="line">parser = argparse.ArgumentParser()</div><div class="line">parser.add_argument(&apos;image_path&apos;, help=&apos;The Path to Source Images, to Create the Gif Animation.&apos;)</div><div class="line">parser.add_argument(&apos;-T&apos;, help=&apos;Target to Save the Gif&apos;, default=&apos;./generate.gif&apos;)</div><div class="line">parser.add_argument(&apos;-W&apos;, help=&apos;Width of the Gif&apos;, default=300)</div><div class="line">parser.add_argument(&apos;-H&apos;, help=&apos;Height of the Gif&apos;, default=281)</div><div class="line">args = parser.parse_args()</div><div class="line">srcImageFilePath = args.image_path</div><div class="line">if srcImageFilePath.split(&apos;/&apos;)[-1]:</div><div class="line">    srcImageFilePath += &apos;/&apos;</div><div class="line">targetGIFPath = args.T</div><div class="line">targetGIFWidth = args.W</div><div class="line">targetGIFHeight = args.H</div><div class="line">targetSize = (targetGIFWidth, targetGIFHeight)</div><div class="line"></div><div class="line">def GetGifAnimationFromImages(srcImageFilePath):</div><div class="line">    images = []</div><div class="line">    for item in os.listdir(srcImageFilePath):</div><div class="line">        suffix = item.split(&apos;.&apos;)[-1]</div><div class="line">        if suffix == &apos;png&apos;:</div><div class="line">            images.append(Image.open(srcImageFilePath + item).resize(targetSize))</div><div class="line">    images2gif.writeGif(targetGIFPath, images, duration=0.1, nq=0.1)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    GetGifAnimationFromImages(srcImageFilePath)</div></pre></td></tr></table></figure>
<h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python GetGifAnimation.py &lt;path-to-images&gt; [-T targetGIFPath] [-W targetGIFWidth] [-H targetGIFHeight]</div></pre></td></tr></table></figure>
<p>合成的gif图为generate.gif</p>
<p>注意：若png图片含有alpha通道需要预先处理。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[socket网络通信——寻址、协议簇和套接字类型]]></title>
      <url>http://lizonghang.github.io/2016/07/14/socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94%E5%AF%BB%E5%9D%80%E3%80%81%E5%8D%8F%E8%AE%AE%E7%B0%87%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;socket模块提供了一个底层C API，可以使用BSD套接字接口实现网络通信。它包括socket类，用于处理具体的数据通道，还包括用于完成网络相关任务的函数，如将一个服务器名称转换为一个地址，以及格式化数据以便在网络上发送。</p>
<h1 id="寻址、协议簇和套接字类型"><a href="#寻址、协议簇和套接字类型" class="headerlink" title="寻址、协议簇和套接字类型"></a>寻址、协议簇和套接字类型</h1><p>&emsp;&emsp;套接字（socket）是程序在本地或者通过互联网来回传递数据时所用通信通道的一个端点。套接字有两个主要属性来控制如何发送数据：地址簇（address family）控制所用的OSI网络层协议，套接字类型（socket type）控制传输层协议。</p>
<p>&emsp;&emsp;Python支持3个地址簇。最常用的是AF_INET，用于IPv4 Internet寻址。IPv4地址长度为4个字节，通常表示为4个数的序列，每个字节对应一个数，用点号分隔（如10.1.1.5和127.0.0.1）。这些值通常被称为“IP地址”。目前几乎所有互联网网络应用都使用IPv4.</p>
<p>&emsp;&emsp;AF_INET6用于IPv6 Internet寻址。IPv6是下一代Internet协议。它支持128位地址和通信流调整，还支持IPv4所不支持的一些路由特性。目前采用IPv6的应用还很有限，不过在不断增长。</p>
<p>&emsp;&emsp;AF_UNIX是UNIX域套接字（UNIX Domain Sockets， UDS）的地址簇，这是一种POSIX兼容系统上的进程间通信协议。UDS的实现通常允许操作系统直接从进程向进程传递数据，而不用通过网络栈。这比使用AF_INET更高效，但是由于要用文件系统作为寻址的命名空间，UDS仅限于同一个系统上的进程。相比其他IPC机制（如命名管道或共享内存），使用UDS的优势在于它与IP网络应用的编程接口是一样的。这说明应用在单个主机上运行时可以利用高效的通信，在网络上发送数据时仍然可以使用同样的代码。</p>
<pre>注意：AF_UNIX常量仅在支持UDS的系统上定义。</pre>

<p>&emsp;&emsp;套接字类型往往是SOCK_DGRAM或SOCK_STREAM，SOCK_DGRAM对应用户数据报协议（user datagram protocol，UDP），SOCK_STREAM对应传输控制协议（transmission control protocol，TCP）。UDP不需要传输握手过程或其他设置过程（setup），但是提供的传输可靠性较低。UDP消息可能乱序传送，也可能传送多次，或者根本不传送。TCP则相反，可以确保每个消息只传送一次，而且按正确的顺序传送。不过，由于增加了可靠性，可能会引入额外的延迟，因为数据报可能需要重新传输。大多数传送大量数据的应用协议（如HTTP）都建立在TCP基础上。UDP通常用于顺序不太重要的协议（因为消息可以放在一个数据包中，例如DNS），或者用于广播（向多个主机发送相同的数据）。</p>
<h2 id="在网络上查找主机"><a href="#在网络上查找主机" class="headerlink" title="在网络上查找主机"></a>在网络上查找主机</h2><p>&emsp;&emsp;socket包含一些函数与网络上的域名服务交互，使得程序可以将服务器的主机名转换为其数字网络地址。应用使用地址来连接一个服务器之前不需要显式转换地址，不过报告错误时除了报告所用的名字之外，还包含这个数字地址会很有用。</p>
<h3 id="socket-gethostname"><a href="#socket-gethostname" class="headerlink" title="socket.gethostname()"></a>socket.gethostname()</h3><p>&emsp;&emsp;要查找当前主机的名字，可以使用<code>gethostname()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import socket</div><div class="line">&gt;&gt;&gt; print socket.gethostname()</div><div class="line">macdeMacBook-Pro.local</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回的名字取决于当前系统的网络设置，在不同的网络上返回的名字可能有变化（如一个连接到WLAN的笔记本电脑）。</p>
<h3 id="socket-gethostbyname"><a href="#socket-gethostbyname" class="headerlink" title="socket.gethostbyname()"></a>socket.gethostbyname()</h3><p>&emsp;&emsp;下面使用<code>gethostbyname()</code>访问操作系统主机名解析API，将服务器名字转换为其数字地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import socket</div><div class="line">&gt;&gt;&gt; for host in [&apos;homer&apos;, &apos;www&apos;, &apos;www.python.org&apos;, socket.gethostname()]:</div><div class="line">...     try:</div><div class="line">...             print &apos;%s : %s&apos; % (host, socket.gethostbyname(host))</div><div class="line">...     except socket.error, msg:</div><div class="line">...             print &apos;%s : %s&apos; % (host, msg)</div><div class="line">... </div><div class="line">homer : [Errno 8] nodename nor servname provided, or not known</div><div class="line">www : [Errno 8] nodename nor servname provided, or not known</div><div class="line">www.python.org : 151.101.36.223</div><div class="line">macdeMacBook-Pro.local : 192.168.0.101</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果当前系统的DNS配置在搜索中包括一个或多个域，名字（name）参数不要求是完全限定名（不需要包含域名和基名）。如果一个名字无法找到，会产生一个socket.error类型的异常。</p>
<h3 id="socket-gethostbyname-ex"><a href="#socket-gethostbyname-ex" class="headerlink" title="socket.gethostbyname_ex()"></a>socket.gethostbyname_ex()</h3><p>&emsp;&emsp;要访问有关服务器的更多命名信息，可以使用函数<code>gethostbyname_ex()</code>，它会返回服务器的标准主机名、所有别名，以及可以用来到达这个主机的所有可用IP地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import socket</div><div class="line">&gt;&gt;&gt; for host in [&apos;baidu.com&apos;, &apos;www.python.org&apos;, socket.gethostname(), &apos;nosuchname&apos;]:</div><div class="line">...     print host</div><div class="line">...     try:</div><div class="line">...             hostname, aliases, addresses = socket.gethostbyname_ex(host)</div><div class="line">...             print &apos; Hostname:&apos;, hostname</div><div class="line">...             print &apos; Aliases:&apos;, aliases</div><div class="line">...             print &apos; Addresses:&apos;, addresses</div><div class="line">...     except socket.error as msg:</div><div class="line">...             print &apos;ERROR:&apos;, msg</div><div class="line">...     print</div><div class="line">...</div><div class="line">baidu.com</div><div class="line"> Hostname: baidu.com</div><div class="line"> Aliases: []</div><div class="line"> Addresses: [&apos;111.13.101.208&apos;, &apos;123.125.114.144&apos;, &apos;180.149.132.47&apos;, &apos;220.181.57.217&apos;]</div><div class="line"></div><div class="line">www.python.org</div><div class="line"> Hostname: prod.python.map.fastlylb.net</div><div class="line"> Aliases: [&apos;www.python.org&apos;, &apos;python.map.fastly.net&apos;]</div><div class="line"> Addresses: [&apos;151.101.16.223&apos;]</div><div class="line"></div><div class="line">macdeMacBook-Pro.local</div><div class="line"> Hostname: macdemacbook-pro.local</div><div class="line"> Aliases: []</div><div class="line"> Addresses: [&apos;10.200.55.2&apos;, &apos;10.57.129.2&apos;, &apos;192.168.0.103&apos;]</div><div class="line"></div><div class="line">nosuchname</div><div class="line">ERROR: [Errno 8] nodename nor servname provided, or not known</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果能得到一个服务器的所有已知IP地址，客户端就可以实现其自己的负载平衡或故障恢复算法。</p>
<h3 id="socket-gethostbyaddr"><a href="#socket-gethostbyaddr" class="headerlink" title="socket.gethostbyaddr()"></a>socket.gethostbyaddr()</h3><p>&emsp;&emsp;如果得到一个服务器的地址，可以使用<code>gethostbyaddr()</code>完成一个逆向查找来得到主机名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import socket</div><div class="line">&gt;&gt;&gt; hostname, aliases, addresses = socket.gethostbyaddr(&apos;127.0.0.1&apos;)</div><div class="line">&gt;&gt;&gt; print &apos;Hostname: %s\nAliases: %s\nAddresses: %s&apos; % (hostname, aliases, addresses)</div><div class="line">Hostname: localhost</div><div class="line">Aliases: [&apos;1.0.0.127.in-addr.arpa&apos;]</div><div class="line">Addresses: [&apos;127.0.0.1&apos;]</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回值是一个元组，其中包含完全主机名、所有别名、以及与这个名字关联的所有IP地址。</p>
<h2 id="查找服务信息"><a href="#查找服务信息" class="headerlink" title="查找服务信息"></a>查找服务信息</h2><p>&emsp;&emsp;除了IP地址之外，每个套接字地址还包括一个整数端口号（port number）。很多应用可以在用一个端口上运行并监听一个IP地址，不过一次只有一个套接字可以使用该地址端口。通过结合IP地址、协议和端口号，可以唯一的标识一个通信通道，确保通过一个套接字发送的消息可以到达正确的目标。</p>
<h3 id="socket-getservbyname"><a href="#socket-getservbyname" class="headerlink" title="socket.getservbyname()"></a>socket.getservbyname()</h3><p>&emsp;&emsp;有些端口号已经预先分配给某个特定的协议。例如，使用SMTP的 email 服务器使用 TCP 在端口25相互通信，Web 客户和服务器使用 80 作为 HTTP 的端口号。网络服务的端口号和标准名可以使用 <code>getservbyname()</code> 查找：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print socket.getservbyname(&apos;ftp&apos;)</div><div class="line">21</div><div class="line">&gt;&gt;&gt; print socket.getservbyname(&apos;https&apos;)</div><div class="line">443</div><div class="line">&gt;&gt;&gt; print socket.getservbyname(&apos;http&apos;)</div><div class="line">80</div><div class="line">&gt;&gt;&gt; print socket.getservbyname(&apos;smtp&apos;)</div><div class="line">25</div></pre></td></tr></table></figure>
<h3 id="socket-getservbyport"><a href="#socket-getservbyport" class="headerlink" title="socket.getservbyport()"></a>socket.getservbyport()</h3><p>要逆向完成服务端口查找，可以使用 <code>getservbyport</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print socket.getservbyport(80)</div><div class="line">http</div></pre></td></tr></table></figure>
<h3 id="socket-getprotobyname"><a href="#socket-getprotobyname" class="headerlink" title="socket.getprotobyname()"></a>socket.getprotobyname()</h3><p>可以使用 <code>getprotobyname()</code> 获取分配给一个传输协议的端口号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print socket.getprotobyname(&apos;tcp&apos;)</div><div class="line">6</div><div class="line">&gt;&gt;&gt; print socket.getprotobyname(&apos;udp&apos;)</div><div class="line">17</div><div class="line">&gt;&gt;&gt; print socket.getprotobyname(&apos;icmp&apos;)</div><div class="line">1</div></pre></td></tr></table></figure>
<p>协议码值是标准化的，作为常量在 socket 中定义，这些协议码都有前缀 <code>IPPROTO_</code>：</p>
<ul>
<li>TCP - <code>socket.IPPROTO_TCP = 6</code></li>
<li>UDP - <code>socket.IPPROTO_UDP = 17</code></li>
<li>ICMP - <code>socket.IPPROTO_ICMP = 1</code> </li>
</ul>
<h2 id="查找服务器地址"><a href="#查找服务器地址" class="headerlink" title="查找服务器地址"></a>查找服务器地址</h2><h3 id="socket-getaddrinfo"><a href="#socket-getaddrinfo" class="headerlink" title="socket.getaddrinfo()"></a>socket.getaddrinfo()</h3><p><code>getaddrinfo()</code> 将一个服务的基本地址转换为一个元组列表，其中包含建立一个连接所需的全部信息。每个元组的内容会有变化，包含不同的网络簇或协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print socket.getaddrinfo(&apos;www.python.org&apos;, &apos;http&apos;)</div><div class="line">[(2, 2, 17, &apos;&apos;, (&apos;151.101.36.223&apos;, 80)), (2, 1, 6, &apos;&apos;, (&apos;151.101.36.223&apos;, 80))]</div></pre></td></tr></table></figure>
<p>下面的程序将解释上述元素的含义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">def get_constants(prefix):</div><div class="line">	return dict((getattr(socket, n), n) for n in dir(socket) if n.startswith(prefix))</div><div class="line"></div><div class="line">families = get_constants(&apos;AF_&apos;)</div><div class="line">types = get_constants(&apos;SOCK_&apos;)</div><div class="line">protocols = get_constants(&apos;IPPROTO_&apos;)</div><div class="line">response = socket.getaddrinfo(&apos;www.python.org&apos;, &apos;http&apos;)</div><div class="line">for family, socktype, proto, canonname, sockaddr in response:</div><div class="line">	print &apos;Family		:&apos;, families[family]</div><div class="line">	print &apos;Type		:&apos;, types[socktype]</div><div class="line">	print &apos;Protocol	:&apos;, protocols[proto]</div><div class="line">	print &apos;Canonical Name	:&apos;, canonname</div><div class="line">	print &apos;Socket Address	:&apos;, sockaddr</div><div class="line">	print</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Family		: AF_INET</div><div class="line">Type		: SOCK_DGRAM</div><div class="line">Protocol	: IPPROTO_UDP</div><div class="line">Canonical Name	:</div><div class="line">Socket Address	: (&apos;151.101.16.223&apos;, 80)</div><div class="line"></div><div class="line">Family		: AF_INET</div><div class="line">Type		: SOCK_STREAM</div><div class="line">Protocol	: IPPROTO_TCP</div><div class="line">Canonical Name	:</div><div class="line">Socket Address	: (&apos;151.101.16.223&apos;, 80)</div></pre></td></tr></table></figure>
<p><code>getaddrinfo()</code> 有多个参数来过滤结果列表。例子中给出的主机和端口值是必要参数。可选参数包括 family、socktype、proto 和 flags。这些可选值可以取 0 或 socket 定义的某个常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response = socket.getaddrinfo(&apos;www.python.org&apos;, &apos;http&apos;, socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP, socket.AI_CANONNAME)</div></pre></td></tr></table></figure>
<p>这一次由于标志（flags）包括 <code>AI_CONONNAME</code>，如果这个主机有别名，结果中会包含服务器的标准名（可能与查找所用的值不同）。如果没有这个标志，标准名值则为空。</p>
<h2 id="IP地址表示"><a href="#IP地址表示" class="headerlink" title="IP地址表示"></a>IP地址表示</h2><h3 id="socket-inet-aton-和socket-inet-ntoa"><a href="#socket-inet-aton-和socket-inet-ntoa" class="headerlink" title="socket.inet_aton()和socket.inet_ntoa()"></a>socket.inet_aton()和socket.inet_ntoa()</h3><p>用 C 编写的网络程序使用数据类型 struct sockaddr 将 IP 地址表示为二进制值（而不是Python程序中常见的地址）。要在 Python 表示和 C 表示之间转换 IPv4 地址，可以使用 <code>inet_aton()</code> 和 <code>inet_ntoa()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import binascii</div><div class="line">import socket</div><div class="line">import struct</div><div class="line">import sys</div><div class="line"></div><div class="line">for string_address in [&apos;192.168.1.1&apos;, &apos;127.0.0.1&apos;]:</div><div class="line">    packed = socket.inet_aton(string_address)</div><div class="line">    print &apos;Original: &apos;, string_address</div><div class="line">    print &apos;Packed: &apos;, binascii.hexlify(packed)</div><div class="line">    print &apos;Unpacked: &apos;, socket.inet_ntoa(packed)</div><div class="line">    print</div></pre></td></tr></table></figure>
<p>数据包格式中的4个字节可以传递到C库、通过网络安全地传输，或者紧凑地保存在一个数据库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Original:  192.168.1.1</div><div class="line">Packed:  c0a80101</div><div class="line">Unpacked:  192.168.1.1</div><div class="line"></div><div class="line">Original:  127.0.0.1</div><div class="line">Packed:  7f000001</div><div class="line">Unpacked:  127.0.0.1</div></pre></td></tr></table></figure>
<h3 id="socket-inet-pton-和socket-inet-ntop"><a href="#socket-inet-pton-和socket-inet-ntop" class="headerlink" title="socket.inet_pton()和socket.inet_ntop()"></a>socket.inet_pton()和socket.inet_ntop()</h3><p>相关函数 <code>inet_pton()</code> 和 <code>inet_ntop()</code> 都能处理 IPv4 和 IPv6 地址，根据传入的地址簇参数生成适当的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import binascii</div><div class="line">import socket</div><div class="line">import struct</div><div class="line">import sys</div><div class="line"></div><div class="line">string_address = &apos;2002:ac10:10a:1234:21e:52ff:fe74:40e&apos;</div><div class="line">packed = socket.inet_pton(socket.AF_INET6, string_address)</div><div class="line">print &apos;Original: &apos;, string_address</div><div class="line">print &apos;Packed: &apos;, binascii.hexlify(packed)</div><div class="line">print &apos;Unpacked: &apos;, socket.inet_ntop(socket.AF_INET6, packed)</div></pre></td></tr></table></figure>
<p>IPv6 地址已经是十六进制值，所以将打包版本转换为一个十六进制数系列时会生成一个与原值类似的串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Original:  2002:ac10:10a:1234:21e:52ff:fe74:40e</div><div class="line">Packed:  2002ac10010a1234021e52fffe74040e</div><div class="line">Unpacked:  2002:ac10:10a:1234:21e:52ff:fe74:40e</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 网络通信 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Python制作长图]]></title>
      <url>http://lizonghang.github.io/2016/07/14/Python%E5%88%B6%E4%BD%9C%E9%95%BF%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p>代码功能将多张图片合并为一张长图，保持各子图比例相同。需要第三方库PIL和numpy。numpy是一个开源数字扩展库，可以用来处理大型矩阵。</p>
<p>require:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install pillow</div><div class="line">$ sudo pip install numpy</div></pre></td></tr></table></figure>
<h1 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h1><p><img src="/images/menbi1.jpg" alt=""><br><img src="/images/menbi2.jpg" alt=""><br><img src="/images/menbi3.jpg" alt=""><br><img src="/images/menbi4.jpg" alt=""><br><img src="/images/menbi5.jpg" alt=""><br><img src="/images/menbi6.jpg" alt=""><br><img src="/images/menbi7.jpg" alt=""></p>
<p>合成效果：</p>
<p><img src="/images/MergeImage.jpg" alt=""></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>假设文件名为merge.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># encoding: utf-8</div><div class="line">from PIL import Image</div><div class="line">import numpy</div><div class="line">import os</div><div class="line">import sys</div><div class="line">import random</div><div class="line">import argparse</div><div class="line"></div><div class="line">parser = argparse.ArgumentParser()</div><div class="line">parser.add_argument(&apos;image_dir&apos;, help=&apos;Path to Image Direction&apos;)</div><div class="line">parser.add_argument(&apos;-w&apos;, help=&apos;Image Width&apos;, type=int, default=300)</div><div class="line">args = parser.parse_args()</div><div class="line">root = args.image_dir # 图片文件夹目录</div><div class="line">if root.split(&apos;/&apos;)[-1]:</div><div class="line">    root += &apos;/&apos;</div><div class="line">pxsize = args.w # 单张照片宽度</div><div class="line">images = [] # 存放所有照片路径</div><div class="line"></div><div class="line">def getPhotos():</div><div class="line">    &apos;&apos;&apos;获取所有照片的索引&apos;&apos;&apos;</div><div class="line">    image_num = 0</div><div class="line">    for im in os.listdir(root):</div><div class="line">        suffix = im.split(&apos;.&apos;)[-1]</div><div class="line">        if suffix == &apos;jpg&apos; or suffix == &apos;JPG&apos; or suffix == &apos;jpeg&apos; or suffix == &apos;png&apos;:</div><div class="line">            images.append(root + im)</div><div class="line">            image_num += 1</div><div class="line">    return image_num</div><div class="line"></div><div class="line">xnum = 1 # 行照片数目</div><div class="line">ynum = getPhotos() # 列照片数目</div><div class="line">if ynum &gt; 70:</div><div class="line">    print &apos;图片数目过多，最高70&apos;</div><div class="line">    sys.exit()</div><div class="line"></div><div class="line">def getTotalHeight():</div><div class="line">    &apos;&apos;&apos;获取合并图片总长&apos;&apos;&apos;</div><div class="line">    totalHeight = 0</div><div class="line">    for i in range(xnum):</div><div class="line">        for j in range(ynum): </div><div class="line">            totalHeight += len(transfer(images[j])) + 1</div><div class="line">    return totalHeight</div><div class="line"></div><div class="line">def transfer(img_path):</div><div class="line">    &apos;&apos;&apos;将图片尺寸等比例转换&apos;&apos;&apos;</div><div class="line">    im = Image.open(img_path)</div><div class="line">    rate = float(im.size[0]) / im.size[1]</div><div class="line">    target_width = pxsize</div><div class="line">    target_height = int(pxsize / rate)</div><div class="line">    im = im.resize((target_width, target_height))</div><div class="line">    return numpy.array(im)[:target_height, :target_width]</div><div class="line"></div><div class="line">def mergeImage():</div><div class="line">    &apos;&apos;&apos;合并图片&apos;&apos;&apos;</div><div class="line">    point = 0</div><div class="line">    I = numpy.array(Image.new(&apos;RGB&apos;, (pxsize, getTotalHeight()), (255,255,255)))</div><div class="line">    for i in range(xnum):</div><div class="line">        for j in range(ynum):</div><div class="line">            DA = transfer(images[j]) </div><div class="line">            I[point:point+len(DA), (i*pxsize):((i+1)*pxsize)] = DA</div><div class="line">            point += len(DA) + 1</div><div class="line">    Image.fromarray(I.astype(numpy.uint8)).save(&apos;MergeImage.jpg&apos;, &apos;JPEG&apos;)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    getPhotos()</div><div class="line">    mergeImage()</div></pre></td></tr></table></figure>
<h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python merge.py &lt;path-to-image-file&gt; [-w width]</div></pre></td></tr></table></figure>
<ul>
<li>path-to-image-file - 必选，指向存放要合并的图片的文件夹</li>
<li>-w width - 可选，指定生成图片的宽度，默认为300px</li>
<li>默认生成图片存放路径为文件merge.py同级目录</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[使用pytesser破解简单验证码]]></title>
      <url>http://lizonghang.github.io/2016/07/10/%E4%BD%BF%E7%94%A8pytesser%E7%A0%B4%E8%A7%A3%E7%AE%80%E5%8D%95%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>Tesseract是一款开源 OCR（Optical Character Recognition，光学字符识别）软件。所谓OCR是图像识别领域中一个子领域，该领域专注于对图片中的文字信息进行识别并转换成能被常规文本编辑器编辑的文本。</p>
<p>Tesseract 已经有30年历史，开始它是惠普实验室的一款专利软件，然后在 2005 年开源，自 2006 年后由 Google 赞助进行后续的开发和维护。在 1995 年 Tesseract 曾是世界前三的 OCR 引擎，而且在现在的免费 OCR 引擎中，其识别精度也仍然是出类拔萃的。因为其免费与较好的效果，许多的个人开发者以及一些较小的团队在使用着 Tesseract ，诸如验证码识别、车牌号识别等应用中，不难见到 Tesseract 的身影。</p>
<p>测试图片如下，文件名为test.png :<br><img src="/images/20140811163359656.png" alt=""></p>
<h1 id="安装pytesseract"><a href="#安装pytesseract" class="headerlink" title="安装pytesseract"></a>安装pytesseract</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install tesseract-ocr</div><div class="line">$ sudo apt-get install tesseract-ocr-eng tesseract-ocr-chi-sim</div><div class="line">$ sudo pip install pytesseract</div></pre></td></tr></table></figure>
<p>若非Linux系统，编译安装tesseract-ocr：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://tesseract-ocr.googlecode.com/files/tesseract-ocr-3.02.02.tar.gz</div><div class="line">tar -xzvf tesseract-ocr-3.02.02.tar.gz</div></pre></td></tr></table></figure>
<p>编译需要<code>automake</code>、<code>autoconf</code>、<code>libtool</code>支持，如果有的话可以跳过该步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install autoconf automake libtool</div></pre></td></tr></table></figure>
<p>进入文件夹 tesseract-ocr-3.02.02 编译安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure>
<p>Tesseract还依赖一些图像库，你可以选择性安装，也可不安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install ligjpeg62-dev libtiff4-dev libpng12-dev libleptonica-dev</div></pre></td></tr></table></figure>
<p>运行测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; import pytesseract</div><div class="line">&gt;&gt;&gt; im = Image.open(&apos;test.png&apos;)</div><div class="line">&gt;&gt;&gt; print pytesseract.image_to_string(im)</div></pre></td></tr></table></figure>
<p>可能会出现’Leptonica not found’错误。如果出现该错误，下载安装Leptonica包即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://leptonica.googlecode.com/files/leptonica-1.69.tar.bz2</div></pre></td></tr></table></figure>
<h1 id="安装语言训练集"><a href="#安装语言训练集" class="headerlink" title="安装语言训练集"></a>安装语言训练集</h1><p>解压后进入目录执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure>
<p>若出现<code>TesseractError</code>，这是由于没有下载语音训练集造成，你可以使用命令查看目前的语言训练集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tesseract --list-langs</div></pre></td></tr></table></figure>
<p>训练集放置于/usr/local/share/目录中的tessdata文件夹中，你需要手动下载训练集并添加到这个文件夹，添加后可以使用上述命令查看。你可以从<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="external">Github</a>获取到训练集。</p>
<p>再次尝试运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; import pytesseract</div><div class="line">&gt;&gt;&gt; im = Image.open(&apos;test.png&apos;)</div><div class="line">&gt;&gt;&gt; print pytesseract.image_to_string(im)</div><div class="line">hoke</div></pre></td></tr></table></figure>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>经测试，pytesser适用于比较规范的英文/数字，对于中文的识别能力较差，对于有干扰素的验证码图片性能较差，可以用来提取简单的英文/数字。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[随机数字图片验证码的原理、生成和破解]]></title>
      <url>http://lizonghang.github.io/2016/07/10/%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%AD%97%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E7%94%9F%E6%88%90%E5%92%8C%E7%A0%B4%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>验证码的功能一般是防止使用程序恶意注册、暴力破解或批量发帖而设置的。所谓验证码，就是将一串随机产生的数字或符号，生成一幅图片，图片里加上一些干扰象素（防止OCR），由用户肉眼识别其中的验证码信息，输入表单提交网站验证，验证成功后才能使用某项功能。学习验证码的破解/识别技术，不仅可以知道验证码的原理，而且可以让你知道怎样才能防止验证码被破解。</p>
<h1 id="常见验证码类型"><a href="#常见验证码类型" class="headerlink" title="常见验证码类型"></a>常见验证码类型</h1><p><img src="/images/authtype.png" alt=""></p>
<ol>
<li>图片背景和数字都使用相同的颜色，字符规整，字符位置统一</li>
<li>验证字符规整，颜色相同，排除干扰素容易，只要是非字符色素全部排除即可</li>
<li>处理背景色和干扰色一直变换，验证字符的颜色也在变化，各个字符的颜色也各不相同</li>
<li>在第三个基础上，在文字上加了两条直线干扰率，容易去掉</li>
</ol>
<h1 id="验证码识别步骤"><a href="#验证码识别步骤" class="headerlink" title="验证码识别步骤"></a>验证码识别步骤</h1><h2 id="取出干扰素"><a href="#取出干扰素" class="headerlink" title="取出干扰素"></a>取出干扰素</h2><p>干扰素的一个重要特征是不能影响验证码的显示效果，所以制作干扰素时它的RGB可能低于或高于某个特定值。比如例子中的图片，干扰素的RGB各项值小于125，依此很容易去掉干扰素。</p>
<h2 id="取出字模"><a href="#取出字模" class="headerlink" title="取出字模"></a>取出字模</h2><p>由于各个网站的验证码各不相同，最常见的方法是建立验证码的特征码库。取字模时，需要多收集几张图片，使这些图片中包括所有的字符。一般来说有0~9、a~z</p>
<h2 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h2><p>把图片上的验证字符上每个像素用一种数字表示1，其他部分用0表示。这样就可以计算每个数字字模，记录下这些字模当作key</p>
<h2 id="计算特征"><a href="#计算特征" class="headerlink" title="计算特征"></a>计算特征</h2><p>把要识别的图片进行二值化，得到图片特征</p>
<h2 id="对照样本"><a href="#对照样本" class="headerlink" title="对照样本"></a>对照样本</h2><p>把上一步图片特征码和验证码的字模进行对比，得到验证图片上的数字</p>
<h1 id="复杂验证码"><a href="#复杂验证码" class="headerlink" title="复杂验证码"></a>复杂验证码</h1><p>识别的目标验证码由字符和数字组成，验证码存在旋转，位置不固定，存在字符与字符之间的粘连，且验证码有更强的干扰素。以下图为例：</p>
<p><img src="/images/authexam.jpg" alt=""></p>
<h2 id="二值化-1"><a href="#二值化-1" class="headerlink" title="二值化"></a>二值化</h2><p>把验证码的部分用1表示，背景部分用0表示。识别方法为：打印出验证码图片的RGB，分辨出图片的R值大于120，G和B小于80的像素，依据这个规则把图片二值化。</p>
<p>常见验证码第三张图片中，验证码的图片每次背景色都不相同，且不是单色，各个验证码数字的颜色每次也各不相同。打印出其 RGB 值很容易就发现。无论验证数字颜色如何变化，该数字的 RGB 值总有一个值小于 125 ，所以通过判断<code> rgbarray[‘red’] &lt; 125 || rgbarray[‘green’] &lt; 125 || rgbarray[‘blue’] &lt; 125 </code>就很容易分辨出数字和背景。</p>
<p>这些规律的原因是，在制作验证码的干扰素时，为了使干扰素不影响数字的显示效果，必须使干扰素的 RGB 和数字的 RGB 相互独立，互不干扰。依照这个规律就容易实现二值化。</p>
<p>我们找到的 120 ， 80 ， 125 等阈值，可能和实际的 RGB 有出入，所以，有时二值化后，会有部分地方出现 1 ，对于验证码上固定位置显示数字，这种干扰没有太大意义。但是对于验证码位置不确定的图片来说，在我们切割字符时，很可能造成干扰。所以，在二值化后要进行去噪处理。</p>
<h2 id="去噪处理"><a href="#去噪处理" class="headerlink" title="去噪处理"></a>去噪处理</h2><p>去噪就是把孤立的有效值去掉。如果一个点为1，则判断这个点的周围一圈上的数字是否为1，若没有则认为是一个噪点，直接设置为0即可。</p>
<p><img src="/images/noise.jpg" alt=""></p>
<p>如图所示，红色方框部分的 1 为噪点，直接设置为 0 即可。有时候噪点可能是两个连续的 1 ，可以计算这个点 8 个方向上的值之和，判断和是否小于特定的阈值。</p>
<h2 id="切割字符"><a href="#切割字符" class="headerlink" title="切割字符"></a>切割字符</h2><p>切割方法有很多种，最简单的一种为竖直切割。先沿垂直方向切割为字符，然后再水平方向去掉多余的 0 。如下图所示</p>
<p><img src="/images/1336829447_7784.jpg" alt=""></p>
<p>第一步切割红线部分，第二步切割蓝线部分，就可以得到独立的字符了。但是像下面的情况：</p>
<p><img src="/images/1336829468_5425.jpg" alt=""></p>
<p>按上面的方法会把 dw 字符切割成一个字符，这是错误的切割，这里涉及到粘连字符的切割。</p>
<h2 id="粘连字符切割"><a href="#粘连字符切割" class="headerlink" title="粘连字符切割"></a>粘连字符切割</h2><p>制作验证码时，规则字符的粘连很容易分割开，如果字符本身有缩放，变形就很难处理。上述字符粘连是规则字符的粘连，完成分割操作后，不能马上确定分割的部分为一个字符，要进行验证。验证的关键是切割下来的字符的宽是否大于阈值。阈值的取舍标准是一个字符无论怎么旋转变形都不会大于这个阈值。若切割的块大于这个阈值，可以认为是一个粘连字符；如果大于两个阈值之和，认为是三个字符粘连，以此类推。如果发现粘连字符块，直接平分为两个或多个小块即可。为了更好的还原字符，一般采用平分±1对字符块部分进行适当的补充。</p>
<h2 id="匹配字符"><a href="#匹配字符" class="headerlink" title="匹配字符"></a>匹配字符</h2><p>最简单的方式是为所有的字符所有情况建立匹配库，目的是现有人工识别图片的验证码，处理后写入特征码库以便匹配。特征码库的图片数据越多，验证识别的准确性就越高。</p>
<h1 id="制作验证码的建议"><a href="#制作验证码的建议" class="headerlink" title="制作验证码的建议"></a>制作验证码的建议</h1><p>对于识别验证码的程序来说最难的部分是验证码字符的切割和特征码的建立。很多验证码加了很多干扰素和干扰线，不仅影响用户体验还达不到防止破解的很好的效果。若要使验证码难于被程序识别，需要注意：</p>
<ul>
<li>字符粘连，最后所有字符都有粘连的部分</li>
<li>不使用规则字符，验证码的各个部分使用不同比例的缩放或者旋转</li>
</ul>
<p>一般实现以上两点或这两点的变性，破解程序就很难识别。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Python破解验证码]]></title>
      <url>http://lizonghang.github.io/2016/07/09/Python%E7%A0%B4%E8%A7%A3%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>本项目使用<strong>PIL库</strong>及<strong>向量空间搜索引擎理论</strong>实现验证码破解。先下载实验用文件便于解释图片解析的原理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ wget http://labfile.oss.aliyuncs.com/courses/364/python_captcha.zip</div><div class="line">$ unzip python_captcha.zip</div></pre></td></tr></table></figure></p>
<p>或直接访问 <a href="http://labfile.oss.aliyuncs.com/courses/364/python_captcha.zip" target="_blank" rel="external">http://labfile.oss.aliyuncs.com/courses/364/python_captcha.zip</a> 并解压。python_captcha目录下的内容有:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">python_captcha</div><div class="line">├── captcha.gif</div><div class="line">├── crack.py</div><div class="line">├── examples</div><div class="line">└── iconset</div><div class="line">    ├── 0~9</div><div class="line">    ├── a~z</div></pre></td></tr></table></figure></p>
<ul>
<li>captcha.gif - 试验用验证码图片</li>
<li>crack.py - 即将编写的实现验证码破解的程序</li>
<li>examples/ - 存放了其他可用于测试的验证码图片</li>
<li>iconset/ - 存放了训练集，即用于对比的单符号图片</li>
</ul>
<p>下图为试验用验证码图片:</p>
<p><img src="/images/captcha.gif" alt=""></p>
<h1 id="从文件中提取图片"><a href="#从文件中提取图片" class="headerlink" title="从文件中提取图片"></a>从文件中提取图片</h1><p>将图片转为8位P模式图片，输出其颜色直方图:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line">im = Image.open(&apos;captcha.gif&apos;).convert(&apos;P&apos;)</div><div class="line">print im.histogram()</div></pre></td></tr></table></figure>
<p>输出:</p>
<pre>
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 1, 2, 0, 1, 0, 0, 1, 0, 2, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 3, 1, 3, 3, 0, 0, 0, 0, 0, 0, 1, 0, 3, 2, 132, 1, 1, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 15, 0, 1, 0, 1, 0, 0, 8, 1, 0, 0, 0, 0, 1, 6, 0, 2, 0, 0, 0, 0, 18, 1, 1, 1, 1, 1, 2, 365, 115, 0, 1, 0, 0, 0, 135, 186, 0, 0, 1, 0, 0, 0, 116, 3, 0, 0, 0, 0, 0, 21, 1, 1, 0, 0, 0, 2, 10, 2, 0, 0, 0, 0, 2, 10, 0, 0, 0, 0, 1, 0, 625]
</pre>

<p>颜色直方图的每一位数字都代表了在图片中含有对应位颜色像素的数量。每个像素点可表现256种颜色。从输出中可发现白点最多，白色像素序号为255，即最后一位，有625个像素。红像素在序号200左右，通过排序可以得到有用的颜色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">his = im.histogram()</div><div class="line">values = &#123;&#125;</div><div class="line">for i in range(256):</div><div class="line">    values[i] = his[i] </div><div class="line">for index,count in sorted(values.items(), key=lambda d:d[1], reverse=True)[:10]:</div><div class="line">    print index,count</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">255 625</div><div class="line">212 365</div><div class="line">220 186</div><div class="line">219 135</div><div class="line">169 132</div><div class="line">227 116</div><div class="line">213 115</div><div class="line">234 21</div><div class="line">205 18</div><div class="line">184 15</div></pre></td></tr></table></figure>
<p>得到了图片中最多的10种颜色，其中index为220与227是需要的红色和灰色，通过这一信息构造黑白二值图片:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line">im = Image.open(&apos;captcha.gif&apos;).convert(&apos;P&apos;)</div><div class="line">im2 = Image.new(&apos;P&apos;, im.size, 255)</div><div class="line">for row in range(im.size[1]):</div><div class="line">    for col in range(im.size[0]):</div><div class="line">        pix = im.getpixel((col,row))</div><div class="line">        if pix == 220 or pix == 227:</div><div class="line">            im2.putpixel((col,row), 0)</div><div class="line">im2.show()</div></pre></td></tr></table></figure>
<p>得到黑白二值图片:</p>
<p><img src="/images/im2.gif" alt=""></p>
<h1 id="提取单个字符图片"><a href="#提取单个字符图片" class="headerlink" title="提取单个字符图片"></a>提取单个字符图片</h1><p>为了判断各个字符，需要将图片切割为单个字符的像素集合，对黑白二值图片进行纵向切割：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">inLetter = False</div><div class="line">foundLetter = False</div><div class="line">letterStart = 0</div><div class="line">letterEnd = 0</div><div class="line">letter_split = []</div><div class="line"></div><div class="line">for col in range(im2.size[0]):</div><div class="line">    for row in range(im2.size[1]):</div><div class="line">        pix = im2.getpixel((col,row))</div><div class="line">        if pix != 255:</div><div class="line">            inLetter = True</div><div class="line">    if foundLetter == False and inLetter == True:</div><div class="line">        foundLetter = True</div><div class="line">        letterStart = col</div><div class="line">    if foundLetter == True and inLetter == False:</div><div class="line">        foundLetter = False</div><div class="line">        letterEnd = col</div><div class="line">        letter_split.append((letterStart,letterEnd))</div><div class="line">    inLetter = False</div></pre></td></tr></table></figure>
<p>letter_split中记录了每个字符开始和结束的列序号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[(6, 14), (15, 25), (27, 35), (37, 46), (48, 56), (57, 67)]</div></pre></td></tr></table></figure>
<p>分割图片:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for letter in letter_split:</div><div class="line">    im_Letter = im2.crop((letter[0], 0, letter[1], im2.size[1]))</div><div class="line">    im_Letter.show()</div></pre></td></tr></table></figure>
<p>得到每个字符的图片。将这些图片与本地图片进行比较分析，匹配到相似度最高的字符。</p>
<h1 id="向量空间图形识别"><a href="#向量空间图形识别" class="headerlink" title="向量空间图形识别"></a>向量空间图形识别</h1><p>这里使用向量空间搜索引擎来做字符识别，它具有很多优点：</p>
<ul>
<li>不需要大量的训练迭代</li>
<li>不会训练过度</li>
<li>可以随时加入/移除错误的数据查看效果</li>
<li>很容易理解和编写成代码</li>
<li>提供分级结果，可以查看最接近的多个匹配</li>
<li>对于无法识别的东西只要加入到搜索引擎中就能识别</li>
</ul>
<p>但它分类的速度比神经网络慢很多，不能找到自己的方法解决问题。</p>
<p>原理可以参考<a href="/2016/07/07/向量空间搜索引擎基本理论/">向量空间搜索引擎</a></p>
<p>类VectorCompare实现向量空间:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import math</div><div class="line">class VectorCompare:</div><div class="line">    def magnitude(self, concordance):</div><div class="line">        total = 0</div><div class="line">        for word, count in concordance.iteritems():</div><div class="line">            total += count ** 2</div><div class="line">        return math.sqrt(total)</div><div class="line"></div><div class="line">    def relation(self, concordance1, concordance2):</div><div class="line">        relevance = 0</div><div class="line">        topvalue = 0</div><div class="line">        for word, count in concordance1.iteritems():</div><div class="line">            if concordance2.has_key(word):</div><div class="line">                topvalue += count * concordance2[word]</div><div class="line">        return topvalue / (self.magnitude(concordance1) * self.magnitude(concordance2))</div></pre></td></tr></table></figure>
<p>该类会比较两个字典并输出它们的相似度(0~1)</p>
<h1 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h1><p>还需要取大量的验证码提取出单个字符图片作为训练集合的工作，上文已经介绍。iconset目录下放的是训练集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">def buildvector(im):</div><div class="line">    d1 = &#123;&#125;</div><div class="line">    count = 0</div><div class="line">    for i in im.getdata():</div><div class="line">        d1[count] = i</div><div class="line">        count += 1</div><div class="line">    return d1</div><div class="line"></div><div class="line">v = VectorCompare()</div><div class="line">iconset = [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;]</div><div class="line"></div><div class="line"># 加载训练集</div><div class="line">imageset = []</div><div class="line">for letter in iconset:</div><div class="line">    for img in os.listdir(&apos;./iconset/%s/&apos; % letter):</div><div class="line">        temp = []</div><div class="line">        if img != &apos;Thumbs.db&apos; and img != &apos;.DS_Store&apos;:</div><div class="line">            temp.append(buildvector(Image.open(&apos;./iconset/%s/%s&apos; % (letter, img))))</div><div class="line">        imageset.append(&#123;letter: temp&#125;)</div><div class="line"></div><div class="line">count = 0</div><div class="line"># 切割验证码</div><div class="line">for letter in letter_split:</div><div class="line">    im_Letter = im2.crop((letter[0], 0, letter[1], im2.size[1]))</div><div class="line">    guess = []</div><div class="line">    # 将切割得到的验证码小片段与每个训练片段进行比较</div><div class="line">    for image in imageset:</div><div class="line">        for x,y in image.iteritems():</div><div class="line">            if len(y) != 0:</div><div class="line">                guess.append((v.relation(y[0], buildvector(im_Letter)), x))</div><div class="line">    guess.sort(reverse=True)</div><div class="line">    print guess[0]</div><div class="line">    count += 1</div></pre></td></tr></table></figure>
<h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># encoding: utf-8</div><div class="line">from PIL import Image</div><div class="line">import os</div><div class="line">import math</div><div class="line"></div><div class="line">class VectorCompare:</div><div class="line">    def magnitude(self, concordance):</div><div class="line">        total = 0</div><div class="line">        for word, count in concordance.iteritems():</div><div class="line">            total += count ** 2</div><div class="line">        return math.sqrt(total)</div><div class="line"></div><div class="line">    def relation(self, concordance1, concordance2):</div><div class="line">        relevance = 0</div><div class="line">        topvalue = 0</div><div class="line">        for word, count in concordance1.iteritems():</div><div class="line">            if concordance2.has_key(word):</div><div class="line">                topvalue += count * concordance2[word]</div><div class="line">        return topvalue / (self.magnitude(concordance1) * self.magnitude(concordance2))</div><div class="line"></div><div class="line"></div><div class="line">def buildvector(im):</div><div class="line">    d1 = &#123;&#125;</div><div class="line">    count = 0</div><div class="line">    for i in im.getdata():</div><div class="line">        d1[count] = i</div><div class="line">        count += 1</div><div class="line">    return d1</div><div class="line"></div><div class="line">v = VectorCompare()</div><div class="line">iconset = [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;]</div><div class="line">image_set = []</div><div class="line"></div><div class="line">for letter in iconset:</div><div class="line">    for img in os.listdir(&apos;./iconset/%s/&apos; % letter):</div><div class="line">        temp = []</div><div class="line">        if img != &quot;Thumbs.db&quot; and img != &apos;.DS_Store&apos;:</div><div class="line">            temp.append(buildvector(Image.open(&apos;./iconset/%s/%s&apos; % (letter, img))))</div><div class="line">        image_set.append(&#123;letter: temp&#125;)</div><div class="line"></div><div class="line">im = Image.open(&apos;captcha.gif&apos;).convert(&apos;P&apos;)</div><div class="line">im2 = Image.new(&apos;P&apos;, im.size, 255)</div><div class="line">temp = &#123;&#125;</div><div class="line"></div><div class="line">for row in range(im.size[1]):</div><div class="line">    for col in range(im.size[0]):</div><div class="line">        pix = im.getpixel((col,row))</div><div class="line">        temp[pix] = pix</div><div class="line">        if pix == 220 or pix == 227:</div><div class="line">            im2.putpixel((col,row), 0)</div><div class="line"></div><div class="line">inLetter = False</div><div class="line">foundLetter = False</div><div class="line">letterStart = 0</div><div class="line">letterEnd = 0</div><div class="line">letter_split = []</div><div class="line"></div><div class="line">for col in range(im2.size[0]):</div><div class="line">    for row in range(im2.size[1]):</div><div class="line">        pix = im2.getpixel((col,row))</div><div class="line">        if pix != 255:</div><div class="line">            inLetter = True</div><div class="line">    if foundLetter == False and inLetter == True:</div><div class="line">        foundLetter = True</div><div class="line">        letterStart = col</div><div class="line">    if foundLetter == True and inLetter == False:</div><div class="line">        foundLetter = False</div><div class="line">        letterEnd = col</div><div class="line">        letter_split.append((letterStart,letterEnd))</div><div class="line">    inLetter = False</div><div class="line"></div><div class="line">count = 0</div><div class="line">for letter in letter_split:</div><div class="line">    im_Letter = im2.crop((letter[0], 0, letter[1], im2.size[1]))</div><div class="line">    guess = []</div><div class="line">    for image in image_set:</div><div class="line">        for x,y in image.iteritems():</div><div class="line">            if len(y) != 0:</div><div class="line">                guess.append((v.relation(y[0], buildvector(im_Letter)), x))</div><div class="line">    guess.sort(reverse=True)</div><div class="line">    print guess[0]</div><div class="line">    count += 1</div></pre></td></tr></table></figure>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>运行程序查看是否正常工作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./crack.py</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(0.9637681159420289, &apos;7&apos;)</div><div class="line">(0.96234028545977, &apos;s&apos;)</div><div class="line">(0.9286884286888929, &apos;9&apos;)</div><div class="line">(0.9835037060984447, &apos;t&apos;)</div><div class="line">(0.9675116507250627, &apos;9&apos;)</div><div class="line">(0.9698971168877263, &apos;j&apos;)</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[快速入门PIL]]></title>
      <url>http://lizonghang.github.io/2016/07/05/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8PIL/</url>
      <content type="html"><![CDATA[<h1 id="使用Image类"><a href="#使用Image类" class="headerlink" title="使用Image类"></a>使用Image类</h1><p>PIL中最重要的类是<code>Image</code>类，可以通过多种方法创建这个类的实例。可以从文件加载图像，或者处理其他图像，或者从scratch创建。</p>
<p>要从文件加载图像，可使用<code>Image</code>模块的<code>open()</code>函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; im = Image.open(&apos;lena.jpg&apos;)</div></pre></td></tr></table></figure>
<p>示例用的图片如下:</p>
<p><img src="/images/lena.jpg" alt="lena"></p>
<p>加载成功将返回一个<code>Image</code>对象。可以使用如下命令检查文件内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print im</div><div class="line">&lt;PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=500x750 at 0x10B9E3890&gt;</div><div class="line">&gt;&gt;&gt; print(im.format, im.size, im.mode)</div><div class="line">(&apos;JPEG&apos;, (500, 750), &apos;RGB&apos;)</div></pre></td></tr></table></figure>
<p><code>format</code>这个属性标识了图像来源。如果图像不是从文件读取那它的值为None。<code>size</code>属性是一个二元tuple，包含width和height(单位px)。<code>mode</code>属性定义了图像bands的数量和名称，以及像素类型和深度。常见的modes有“L”(luminance)表示灰度图像，“RGB”表示真彩色图像，“CMYK”表示出版图像。</p>
<p>如果文件打开错误，则返回<code>IOError</code>错误。</p>
<p>只要有了<code>Image</code>类的实例，就可以通过类的方法处理图像。比如下面的方法可以用来显示图像:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; im.show()</div></pre></td></tr></table></figure>
<pre>
注解：标准的<code>show()</code>效率不高，它需要保存图像到临时文件然后通过xv显示图像。
</pre>

<h1 id="读写图像"><a href="#读写图像" class="headerlink" title="读写图像"></a>读写图像</h1><p>PIL模块支持大量图片格式。使用在<code>Image</code>模块的<code>open()</code>函数从磁盘读取文件。不需要知道文件格式就能打开它，这个库能够根据文件内容自动确定文件格式。</p>
<p>要保存文件，使用<code>Image</code>类的<code>save()</code>方法。保存文件时文件名变得重要了。除非指定格式，否则这个库将会以文件名的扩展名作为格式保存。</p>
<h2 id="创建略缩图"><a href="#创建略缩图" class="headerlink" title="创建略缩图"></a>创建略缩图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; im = Image.open(&apos;lena.jpg&apos;)</div><div class="line">&gt;&gt;&gt; print im.size</div><div class="line">(500, 750)</div><div class="line">&gt;&gt;&gt; size = (250, 375)</div><div class="line">&gt;&gt;&gt; im.thumbnail(size)</div><div class="line">&gt;&gt;&gt; print im.size</div><div class="line">(250, 375)</div></pre></td></tr></table></figure>
<p>使用<code>thumbnail()</code>方法需要注意的是，指定的<code>size</code>应当比原尺寸小，且转换后的图片比例与原图片比例相同。</p>
<h2 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h2><p>继续执行下述步骤,将转换后的图片保存:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; im.save(&apos;lena_thumbnail.jpg&apos;, &apos;JPEG&apos;)</div></pre></td></tr></table></figure>
<h1 id="剪切、粘贴、合并图像"><a href="#剪切、粘贴、合并图像" class="headerlink" title="剪切、粘贴、合并图像"></a>剪切、粘贴、合并图像</h1><p><code>Image</code>类包含的方法允许操作图像部分选区，使用<code>Image.crop()</code>方法获取图像的一个子矩形选区。</p>
<h2 id="从图像中复制出一个矩形选区"><a href="#从图像中复制出一个矩形选区" class="headerlink" title="从图像中复制出一个矩形选区"></a>从图像中复制出一个矩形选区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print im.size</div><div class="line">(500, 750)</div><div class="line">&gt;&gt;&gt; box = (100, 100, 400, 400)</div><div class="line">&gt;&gt;&gt; region = im.crop(box)</div><div class="line">&gt;&gt;&gt; region.show()</div></pre></td></tr></table></figure>
<p>矩形选区有一个四元元组定义，分别表示左上、右下的坐标。这个库以左上角为坐标原点，单位是px，所以上述代码复制了一个 300x300 pixels 的矩形选区。这个选区现在可以被处理并且粘贴到原图。</p>
<p>剪下来的 300x300px 图片如下所示:</p>
<p><img src="/images/lena_cut.jpg" alt="lena_cut"></p>
<h2 id="处理复制的矩形选区并粘贴到原图"><a href="#处理复制的矩形选区并粘贴到原图" class="headerlink" title="处理复制的矩形选区并粘贴到原图"></a>处理复制的矩形选区并粘贴到原图</h2><p>继续上面的步骤:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; region = region.transpose(Image.ROTATE_180)</div><div class="line">&gt;&gt;&gt; im.paste(region, box)</div><div class="line">&gt;&gt;&gt; im.show()</div></pre></td></tr></table></figure>
<p>当粘贴矩形选区的时候必须保证尺寸一致。此外，矩形选区不能在图像外。然而不必保证矩形选区和原图的颜色模式一致，因为矩形选区会被自动转换颜色。</p>
<p>效果图如下:</p>
<p><img src="/images/lena_paste.jpg" alt="lena_paste"></p>
<h2 id="分离和合并颜色通道"><a href="#分离和合并颜色通道" class="headerlink" title="分离和合并颜色通道"></a>分离和合并颜色通道</h2><p>由于上面例子已经对im进行了改变，我们重新将im指向原图片:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; im = Image.open(&apos;lena.jpg&apos;)</div><div class="line">&gt;&gt;&gt; r, g, b = im.split()</div></pre></td></tr></table></figure>
<p>如果是单色通道的图片，使用<code>split()</code>之后会返回图片本身。你可以使用<code>r.show()</code>来查看分离颜色通道后的图片。</p>
<p><img src="/images/lena_split.jpg" alt="lena_split"></p>
<p>将分离的颜色合并为RGB可用<code>merge()</code>方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; img = Image.merge(&apos;RGB&apos;, (b, g, r))</div><div class="line">&gt;&gt;&gt; img.show()</div></pre></td></tr></table></figure>
<p>以b,g,r顺序合并成的图片如图所示:</p>
<p><img src="/images/lena_merge.jpg" alt="lena_merge"></p>
<h1 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h1><p><code>PIL.Image.Image</code>类包含了设置图像大小<code>resize()</code>和旋转图像<code>rotate()</code>的方法。<code>resize()</code>接收一个元组来指定新大小。<code>rotate()</code>接收一个逆时针的角度值。</p>
<h2 id="简单的几何变换"><a href="#简单的几何变换" class="headerlink" title="简单的几何变换"></a>简单的几何变换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; print im.size</div><div class="line">(500, 750)</div><div class="line">&gt;&gt;&gt; im_resize = im.resize((250, 250))</div><div class="line">&gt;&gt;&gt; im_resize.show()</div><div class="line">&gt;&gt;&gt; im_rotate = im.rotate(45)</div><div class="line">&gt;&gt;&gt; im_rotate.show()</div></pre></td></tr></table></figure>
<p><code>im_resize.show()</code>效果图如下:</p>
<p><img src="/images/lena_resize.jpg" alt="lena_resize"></p>
<p><code>im_rotate.show()</code>效果图如下:</p>
<p><img src="/images/lena_rotate.jpg" alt="lena_rotate"></p>
<h2 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h2><p>如果要将图片旋转90°的整数倍，可以使用<code>rotate()</code>方法或者<code>transpose()</code>方法。<code>transpose()</code>还可以将图片按照其竖直或水平边缘翻转，由于图片过多不一一展示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">out = im.transpose(Image.FLIP_LEFT_RIGHT)</div><div class="line">out = im.transpose(Image.FLIP_TOP_BOTTOM)</div><div class="line">out = im.transpose(Image.ROTATE_90)</div><div class="line">out = im.transpose(Image.ROTATE_180)</div><div class="line">out = im.transpose(Image.ROTATE_270)</div></pre></td></tr></table></figure>
<p>使用<code>transpose(ROTATE)</code>和<code>rotate()</code>是没有区别的。更普遍的方法是使用<code>transform()</code>方法。</p>
<h1 id="颜色变换"><a href="#颜色变换" class="headerlink" title="颜色变换"></a>颜色变换</h1><p>Python Imaging Library可以使用<code>convert()</code>方法来实现像素的变换。</p>
<h2 id="颜色模式转换"><a href="#颜色模式转换" class="headerlink" title="颜色模式转换"></a>颜色模式转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; im.convert(&apos;L&apos;).show()</div></pre></td></tr></table></figure>
<p>PIL库支持各种不同模式之间的转换，比如“L”和“RGB”模式。为了转成其他的模式，需要用一张中间模式图像，典型的为RGB图片。</p>
<h1 id="颜色增强"><a href="#颜色增强" class="headerlink" title="颜色增强"></a>颜色增强</h1><p>PIL库提供了许多方法和模块可以用来增强图像</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p><code>ImageFilter</code>模块包含了许多预定义的增强过滤器，通过<code>filter</code>方法调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import ImageFilter</div><div class="line">&gt;&gt;&gt; out = im.filter(ImageFilter.DETAIL)</div></pre></td></tr></table></figure>
<h2 id="点操作"><a href="#点操作" class="headerlink" title="点操作"></a>点操作</h2><p><code>point()</code>方法能够用来实现图片像素值的转换(比如图像对比度处理)。在大多数情况下，<code>point()</code>方法接收一个函数体作为参数，每一个像素都根据此函数处理:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; out = im.point(lambda i: i * 1.2)</div></pre></td></tr></table></figure>
<p>效果图如下，相比原图有增强:</p>
<p><img src="/images/lena_point.jpg" alt="lena_point"></p>
<p>处理个别bands:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># split the image into individual bands</div><div class="line">source = im.split()</div><div class="line"></div><div class="line">R, G, B = 0, 1, 2</div><div class="line"></div><div class="line"># select regions where red is less than 100</div><div class="line">mask = source[R].point(lambda i: i &lt; 100 and 255)</div><div class="line"></div><div class="line"># process the green band</div><div class="line">out = source[G].point(lambda i: i * 0.7)</div><div class="line"></div><div class="line"># paste the processed band back, but only where red was &lt; 100</div><div class="line">source[G].paste(out, None, mask)</div><div class="line"></div><div class="line"># build a new multiband image</div><div class="line">im = Image.merge(im.mode, source)</div></pre></td></tr></table></figure>
<p>效果和原图差异不大，就不上图了。需要注意的是这个语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">imout = im.point(lambda i: expression and 255)</div></pre></td></tr></table></figure>
<p>如果expression的值为false/0，则and之后的不再检查，直接返回0。如果expression的值为true/非0，判断and之后的表达式，并返回最后一个检查的值，语句返回255。</p>
<h2 id="增强"><a href="#增强" class="headerlink" title="增强"></a>增强</h2><p>要使用更多先进的图片增强功能，可以使用模块<code>ImageEnhance</code>中的类。你可以通过它调整对比度、亮度、颜色平衡度和尖锐度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from PIL import ImageEnhance</div><div class="line"></div><div class="line">enh = ImageEnhance.Contrast(im)</div><div class="line">enh.enhance(0.5).show(&quot;50% less contrast&quot;)</div></pre></td></tr></table></figure>
<p>对比度降低50%后效果如下:</p>
<p><img src="/images/lena_contrast.jpg" alt="lena_contrast"></p>
<h1 id="多帧图像序列"><a href="#多帧图像序列" class="headerlink" title="多帧图像序列"></a>多帧图像序列</h1><p>PIL支持图像序列(动画格式)。支持的序列格式包括FLI/FLC,GIF等。TIFF文件也能包含许多帧。打开一个序列文件时，PIL自动装载序列的第一帧。你可以使用函数来移动帧。参考图片如下:</p>
<p><img src="/images/niko.gif" alt="niko"></p>
<h2 id="读取序列"><a href="#读取序列" class="headerlink" title="读取序列"></a>读取序列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line"></div><div class="line">im = Image.open(&quot;niko.gif&quot;)</div><div class="line">im.seek(0) # 跳到第一帧</div><div class="line"></div><div class="line">try:</div><div class="line">    while 1:</div><div class="line">        im.seek(im.tell()+1) # 跳到下一帧，tell()方法返回目前的帧序号</div><div class="line">        im.show()</div><div class="line">except EOFError:</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>以前的PIL库只允许seek到下一帧，如果要倒回去需要重新打开。而现在的PIL库你可以seek到任意帧。</p>
<h2 id="序列迭代类"><a href="#序列迭代类" class="headerlink" title="序列迭代类"></a>序列迭代类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line"></div><div class="line">class ImageSequence:</div><div class="line">    def __init__(self, im):</div><div class="line">        self.im = im</div><div class="line">    def __getitem__(self, ix):</div><div class="line">        try:</div><div class="line">            if ix:</div><div class="line">                self.im.seek(ix)</div><div class="line">            return self.im</div><div class="line">        except EOFError:</div><div class="line">            raise IndexError</div><div class="line"></div><div class="line">im = Image.open(&apos;niko.gif&apos;)</div><div class="line">for frame in ImageSequence(im):</div><div class="line">    frame.show()</div></pre></td></tr></table></figure>
<h1 id="更多关于读取图像"><a href="#更多关于读取图像" class="headerlink" title="更多关于读取图像"></a>更多关于读取图像</h1><p><code>Image.open()</code>方法是用来打开一个图片文件的。大多数情况下可以简单的将图像文件名作参数传入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">im = Image.open(&apos;lena.jpg&apos;)</div></pre></td></tr></table></figure>
<p>正常返回结果是一个<code>PIL.Image.Image</code>实例。否则会抛出<code>IOError</code>错误。</p>
<p>你可以传入一个类文件代替文件名。这个类文件必须实现<code>read()</code>，<code>seek()</code>，<code>tell()</code>方法，并且以二进制模式打开。</p>
<h2 id="从文件读取"><a href="#从文件读取" class="headerlink" title="从文件读取"></a>从文件读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; fp = open(&apos;lena.jpg&apos;, &apos;rb&apos;)</div><div class="line">&gt;&gt;&gt; im = Image.open(fp)</div></pre></td></tr></table></figure>
<h2 id="从string读取"><a href="#从string读取" class="headerlink" title="从string读取"></a>从string读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import urllib2</div><div class="line">&gt;&gt;&gt; import StringIO</div><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; headers = &#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36&apos;&#125;</div><div class="line">&gt;&gt;&gt; req = urllib2.Request(&apos;http://tupian.enterdesk.com/2014/mxy/06/19/1/8.jpg&apos;, headers=headers)</div><div class="line">&gt;&gt;&gt; buffer = urllib2.urlopen(req).read()</div><div class="line">&gt;&gt;&gt; im = Image.open(StringIO.StringIO(buffer))</div><div class="line">&gt;&gt;&gt; im.show()</div></pre></td></tr></table></figure>
<p>使用的示例图片如下:</p>
<p><img src="/images/string_pic.jpg" alt=""></p>
<h2 id="从压缩包读取"><a href="#从压缩包读取" class="headerlink" title="从压缩包读取"></a>从压缩包读取</h2><p>为示范，先将一些文件例如”lena.jpg”和”niko.gif”打包，压缩包名假设为”Imaging.tar”。从压缩包中读取”lena.jpg”可使用<code>TarIO.TarIO()</code>方法获取图片，并交由<code>Image.open()</code>处理。(Linux/Unix系统下可以简单使用<code>tar -cvf Imaging.tar lena.jpg niko.gif </code>打包为tar压缩格式)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image, TarIO</div><div class="line">&gt;&gt;&gt; fp = TarIO.TarIO(&apos;Imaging.tar&apos;, &apos;lena.jpg&apos;)</div><div class="line">&gt;&gt;&gt; im = Image.open(fp)</div></pre></td></tr></table></figure>
<p>注意：对zip压缩包进行操作时可能会出现解码错误。</p>
<h1 id="控制解码器"><a href="#控制解码器" class="headerlink" title="控制解码器"></a>控制解码器</h1><p>部分解码器支持在读取图片文件的时候对图像进行处理，常用于创建略缩图时加速解码速度(当速度比质量重要时)和传输给单色激光打印机时()。<code>draft()</code>方法可以在图像尚未加载完时对其进行处理，所以给定的模式和大小尽可能的匹配。这是通过重新配置图像解码器完成的。</p>
<h2 id="在草稿模式读取"><a href="#在草稿模式读取" class="headerlink" title="在草稿模式读取"></a>在草稿模式读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; im = Image.open(file)</div><div class="line">&gt;&gt;&gt; print(&quot;original =&quot;, im.mode, im.size)</div><div class="line">&gt;&gt;&gt; im.draft(&quot;L&quot;, (100, 100))</div><div class="line">&gt;&gt;&gt; print(&quot;draft =&quot;, im.mode, im.size)</div></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">original= RGB (500, 750)</div><div class="line">draft= L (125, 188)</div></pre></td></tr></table></figure>
<p>注意得到的图片可能不会完全的匹配给定的模式和大小。为了保证图像不比给定的大小大，使用<code>im.thumbnail()</code>方法来代替。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Scrapy采集天气数据]]></title>
      <url>http://lizonghang.github.io/2016/07/05/Scrapy%E9%87%87%E9%9B%86%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>很多网站都提供了浏览者本地的天气信息，这些信息大多是利用某些网站提供的天气API获取的，也有利用爬虫采集的。本文介绍如何用Scrapy来采集天气信息。天气信息来源为<a href="http://weather.sina.com.cn/" target="_blank" rel="external">新浪天气频道</a>。本文提取“国内”栏目的天气信息。</p>
<p>Scrapy是Python开发的一个快速,高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。用途广泛，可以用于数据挖掘、监测和自动化测试。</p>
<p>如果你还没有安装Scrapy，请参考官方的<a href="http://doc.scrapy.org/en/latest/intro/install.html" target="_blank" rel="external">安装向导</a>或在网上查找安装方法。</p>
<h1 id="创建Scrapy项目"><a href="#创建Scrapy项目" class="headerlink" title="创建Scrapy项目"></a>创建Scrapy项目</h1><p>在开始爬取之前，需要创建一个scrapy项目。进入需要存储代码的目录，执行命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ scrapy startproject weather</div></pre></td></tr></table></figure>
<p>正常初始化的文件内容应该是这样的:</p>
<p><img src="/images/weather_tree.png" alt="weather-dir"></p>
<h1 id="定义Item"><a href="#定义Item" class="headerlink" title="定义Item"></a>定义Item</h1><p>Item是保存爬取到的数据的容器，使用方法和Python字典相似，并且提供了额外的保护机制来避免拼写错误导致的未定义字段错误。</p>
<p>首先需要根据从<code><a href="http://weather.sina.com.cn/china/" target="_blank" rel="external">http://weather.sina.com.cn/china/</a></code>中获取到的数据对item进行建模。需要的内容如图:</p>
<p><img src="/images/item.png" alt="item"></p>
<p>编辑weather/items.py文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*-</div><div class="line">import scrapy</div><div class="line"></div><div class="line">class WeatherItem(scrapy.Item):</div><div class="line">    county = scrapy.Field() # 县/区</div><div class="line">    weather_day = scrapy.Field() # 白天天气</div><div class="line">    wind_day = scrapy.Field() # 白天风向</div><div class="line">    temperate_max = scrapy.Field() # 最高温度</div><div class="line">    weather_night = scrapy.Field() # 夜间天气</div><div class="line">    wind_night = scrapy.Field() # 夜间风向</div><div class="line">    temperate_min = scrapy.Field() # 最低温度</div></pre></td></tr></table></figure>
<h1 id="编写Spider"><a href="#编写Spider" class="headerlink" title="编写Spider"></a>编写Spider</h1><p>Spider是用户编写的用于从单个或多个网页中爬取数据的类。为了创建一个Spider，必须继承scrapy.Spider类，且定义以下三个属性:</p>
<ul>
<li>name - 用于区别Spider。该名字必须是唯一的，不可以给不同的Spider使用相同的名字。</li>
<li>start_urls - 包含了Spider在启动时爬取的url列表。是Spider第一轮爬取的链接。后续的URL则从初始URL获取到的数据中提取。</li>
<li>parse(self, response) - 被调用时，每个初始URL完成下载后生成的Response对象将会作为唯一的参数传递给该函数。该方法负责解析返回的数据，提取数据以及生成需要进一步处理的URL的Request对象。</li>
</ul>
<p>首先分析一下需要爬取的数据的位置和网页源代码:</p>
<p><img src="/images/province.png" alt="province"></p>
<p><img src="/images/province_code.png" alt="code"></p>
<p>我们可以看到，全国城市都位于一个<code>class=”wd_piC”</code>的<code>div</code>中的<code>a</code>标签中，于是我们可以使用如下代码来提取各省份的链接。保存于weather/spiders目录下的localweather.py文件中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def parse(self, response):</div><div class="line">    selector = scrapy.Selector(response)</div><div class="line">    for num in selector.xpath(&apos;//div[@class=&quot;wd_piC&quot;]&apos;):</div><div class="line">        for province in num.xpath(&apos;a&apos;):</div><div class="line">            self.provinces.append(province.xpath(&apos;@href&apos;).extract()[0])</div><div class="line">    yield Request(self.provinces.pop(), callback=self.getCountyWeather)</div></pre></td></tr></table></figure>
<p>上述操作将所有省份的链接提取出来，存储到一个叫<code>provinces</code>的列表中，然后从中取出一个链接，进行下一次爬取。在编写回调函数getCountyWeather之前，先查看数据的位置和网页源代码:</p>
<p><img src="/images/county.png" alt="county"></p>
<p><img src="/images/county_code.png" alt="code"></p>
<p>我们需要的信息在多个<code>class=”wd_cm_table”</code>的<code>table</code>标签中，每条信息又在其中的多个<code>tr</code>标签中，最后标签<code>td</code>中含有我们需要的信息。</p>
<p>用于获取这些信息的方法getCountyWeather()代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">def getCountyWeather(self, response):</div><div class="line">    item = WeatherItem()</div><div class="line">    selector = scrapy.Selector(response)</div><div class="line">    for table in selector.xpath(&apos;//table[@class=&quot;wd_cm_table&quot;]&apos;):</div><div class="line">        for each_row in table.xpath(&apos;tr&apos;):</div><div class="line">            tds = each_row.xpath(&apos;td&apos;)</div><div class="line">            item[&apos;county&apos;] = tds[0].xpath(&apos;a/text()&apos;).extract()[0]</div><div class="line">            item[&apos;weather_day&apos;] = tds[1].xpath(&apos;p/text()&apos;).extract()[0]</div><div class="line">            item[&apos;wind_day&apos;] = tds[2].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">            item[&apos;temperate_max&apos;] = tds[3].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">            item[&apos;weather_night&apos;] = tds[4].xpath(&apos;p/text()&apos;).extract()[0]</div><div class="line">            item[&apos;wind_night&apos;] = tds[5].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">            item[&apos;temperate_min&apos;] = tds[6].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">            yield item</div><div class="line">    if len(self.provinces) &gt; 0:</div><div class="line">        yield Request(self.provinces.pop(), callback=self.getCountyWeather)</div><div class="line">    else:</div><div class="line">        print &apos;The Spider Has Finished Its Work! Wish To Meet U Later!&apos;</div></pre></td></tr></table></figure>
<h1 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h1><p>localweather.py中的全部代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># encoding: utf-8</div><div class="line">import scrapy</div><div class="line">from scrapy.http import Request</div><div class="line">from weather.items import WeatherItem</div><div class="line"></div><div class="line"></div><div class="line">class WeatherSpider(scrapy.Spider):</div><div class="line">    name = &apos;WeatherSpider&apos;</div><div class="line">    allowed_domains = [&apos;sina.com.cn&apos;]</div><div class="line">    start_urls = [&apos;http://weather.sina.com.cn/china/&apos;]</div><div class="line">    provinces = []</div><div class="line"></div><div class="line">    def parse(self, response):</div><div class="line">        selector = scrapy.Selector(response)</div><div class="line">        for num in selector.xpath(&apos;//div[@class=&quot;wd_piC&quot;]&apos;):</div><div class="line">            for province in num.xpath(&apos;a&apos;):</div><div class="line">                self.provinces.append(province.xpath(&apos;@href&apos;).extract()[0])</div><div class="line">        yield Request(self.provinces.pop(), callback=self.getCountyWeather)</div><div class="line"></div><div class="line">    def getCountyWeather(self, response):</div><div class="line">        item = WeatherItem()</div><div class="line">        selector = scrapy.Selector(response)</div><div class="line">        for table in selector.xpath(&apos;//table[@class=&quot;wd_cm_table&quot;]&apos;):</div><div class="line">            for each_row in table.xpath(&apos;tr&apos;):</div><div class="line">                tds = each_row.xpath(&apos;td&apos;)</div><div class="line">                item[&apos;county&apos;] = tds[0].xpath(&apos;a/text()&apos;).extract()[0]</div><div class="line">                item[&apos;weather_day&apos;] = tds[1].xpath(&apos;p/text()&apos;).extract()[0]</div><div class="line">                item[&apos;wind_day&apos;] = tds[2].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">                item[&apos;temperate_max&apos;] = tds[3].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">                item[&apos;weather_night&apos;] = tds[4].xpath(&apos;p/text()&apos;).extract()[0]</div><div class="line">                item[&apos;wind_night&apos;] = tds[5].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">                item[&apos;temperate_min&apos;] = tds[6].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">                yield item</div><div class="line">        if len(self.provinces) &gt; 0:</div><div class="line">            yield Request(self.provinces.pop(), callback=self.getCountyWeather)</div><div class="line">        else:</div><div class="line">            print &apos;The Spider Has Finished Its Work! Wish To Meet U Later!&apos;</div></pre></td></tr></table></figure>
<h1 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h1><p>存储到Item中的数据可以导出为JSON/JSON lines/CSV/XML格式的文件。以导出为CSV文件为例，其他的请参考<a href="http://doc.scrapy.org/en/1.1/topics/feed-exports.html" target="_blank" rel="external">官方说明</a>。需要修改weather/settings.py中的配置，在配置最后添加代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FEED_URI = u&apos;~/Desktop/Weather.csv&apos; # 存储csv文件的目录，可任意修改</div><div class="line">FEED_FORMAT = &apos;CSV&apos; # 存储格式为csv，可修改为json等其他格式</div></pre></td></tr></table></figure>
<p>随后，在项目的scrapt.cfg文件同级目录下使用命令，运行爬虫:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ scrapy crawl WeatherSpider</div></pre></td></tr></table></figure>
<p>等待运行结束，得到一个csv文件如下所示，显示为乱码，这是由于编码问题造成的:</p>
<p><img src="/images/csverr.png" alt="csv"></p>
<p>将csv文件用Sublime Text打开，点击File-&gt;Save with Encoding-&gt;UTF-8 with BOM，再用Excel打开，即可恢复正常。该文件中包含了全国所有城市的天气情况。</p>
<p><img src="/images/csv1.png" alt="csv"></p>
<p>然而，csv文件中的顺序并不是按照Items.py中指定的顺序来的，可作如下修改:</p>
<p>第一步:在scrapy的spider同层目录下，新建CsvItemExporter.py文件夹，内容如下(文件名可修改):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from scrapy.conf import settings</div><div class="line">from scrapy.contrib.exporter import CsvItemExporter</div><div class="line"></div><div class="line">class ProjectCsvItemExporter(CsvItemExporter):</div><div class="line">    def __init__(self, *args, **kwargs):</div><div class="line">        kwargs[&apos;delimiter&apos;] = settings.get(&apos;CSV_DELIMITER&apos;, &apos;,&apos;)</div><div class="line">        if settings.get(&apos;FIELDS_TO_EXPORT&apos;, []):</div><div class="line">            kwargs[&apos;fields_to_export&apos;] = settings.get(&apos;FIELDS_TO_EXPORT&apos;, [])</div><div class="line"></div><div class="line">        super(ProjectCsvItemExporter, self).__init__(*args, **kwargs)</div></pre></td></tr></table></figure>
<p>第二步:在settings.py文件末新增如下内容，指定item的field顺序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">FEED_EXPORTERS = &#123;</div><div class="line">    # 项目名.文件名.类名</div><div class="line">    &apos;csv&apos;: &apos;weather.CsvItemExporter.ProjectCsvItemExporter&apos;, </div><div class="line">&#125;</div><div class="line"></div><div class="line"># 导出字段顺序</div><div class="line">FIELDS_TO_EXPORT = [</div><div class="line">    &apos;county&apos;,</div><div class="line">    &apos;weather_day&apos;,</div><div class="line">    &apos;wind_day&apos;,</div><div class="line">    &apos;temperate_max&apos;,</div><div class="line">    &apos;weather_night&apos;,</div><div class="line">    &apos;wind_night&apos;,</div><div class="line">    &apos;temperate_min&apos;,</div><div class="line">]</div></pre></td></tr></table></figure>
<p>第三步:再次运行爬虫，获取的csv文件内容如下所示:</p>
<p><img src="/images/csv2.png" alt="csv"></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>关于为Item指定中文名的问题作者暂时还未找到类似django model中verbose_name参数的解决方法，若有需要可在程序末对csv文件进行文件IO处理，替换第一行。或者取代scrapy的文件导出，自行将数据导出到csv文件。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo Github Page]]></title>
      <url>http://lizonghang.github.io/2016/06/30/Hexo%20Github-Page/</url>
      <content type="html"><![CDATA[<h1 id="创建Github-io"><a href="#创建Github-io" class="headerlink" title="创建Github.io"></a>创建Github.io</h1><p>本文默认的前提为你会使用Git，如不会使用Git或没有Github账号，请参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的Git教程</a></p>
<p>要在github上搭建github pages，需要在你的github下新建一个名为[username].github.io的仓库，其中username是你的用户名(或组织名称)。注意: 如果username与你的用户名不同将无法成功。</p>
<p>在电脑自定义的位置新建一个文件夹如github.io，然后进入github.io文件夹执行git初始化命令并克隆github.io仓库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git init</div><div class="line">$ git clone https://github.com/username/username.github.io</div></pre></td></tr></table></figure>
<p>进入项目文件夹并增加一个index.html文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd username.github.io</div><div class="line">$ echo &quot;Hello World&quot; &gt; index.html</div></pre></td></tr></table></figure>
<p>将你的github.com/username/username.github.io设置一个名称，假设为blog:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote add blog git@github.com:username/username.github.io.git</div></pre></td></tr></table></figure>
<p>执行add,commit操作并push到你的blog仓库，注意，请确认你是否push到了正确的仓库:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git add -A</div><div class="line">$ git commit -m &quot;Initial Commit&quot;</div><div class="line">$ git push blog master</div></pre></td></tr></table></figure>
<p>如果出现错误，不能push，请尝试先进行pull，再进行push操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull blog master</div></pre></td></tr></table></figure>
<p>当你的username.github.io仓库中存在index.html时，访问你的博客页面，如username.github.io，可以看到页面上出现“Hello World”，你就拥有了一个自己的github博客。</p>
<h1 id="使用Hexo作博客模板"><a href="#使用Hexo作博客模板" class="headerlink" title="使用Hexo作博客模板"></a>使用Hexo作博客模板</h1><p>当然不是每个人都有时间去写博客页面或管理自己的博客，此时即可借助Hexo来帮你管理和生成你的博客。</p>
<p>在安装Hexo之前，请确保你的电脑中安装有node.js，否则可能出现错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">init env: node: No such file or directory</div></pre></td></tr></table></figure>
<p>若电脑中没有node.js，前往<a href="https://nodejs.org/en/" target="_blank" rel="external">nodejs的官方网站</a>下载，本人使用的是<a href="https://nodejs.org/dist/v4.4.7/node-v4.4.7.pkg" target="_blank" rel="external">v4.4.7 LTS版本</a>。下载完成后，运行安装程序即可完成安装，安装node.js后也安装好了npm。</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo npm install -g hexo</div></pre></td></tr></table></figure>
<h2 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init</div></pre></td></tr></table></figure>
<p>这个命令会初始化博客目录，执行命令时在你想要创建的目录下执行，此时该目录下会生成以下文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">   ├── .deploy</div><div class="line">   ├── public</div><div class="line">   ├── scaffolds</div><div class="line">   ├── scripts</div><div class="line">   ├── source</div><div class="line">   |   ├── _drafts</div><div class="line">   |   └── _posts</div><div class="line">   ├── themes</div><div class="line">   ├── _config.yml</div><div class="line">   └── package.json</div></pre></td></tr></table></figure>
<p>文件说明:</p>
<ul>
<li>.deploy：执行hexo deploy命令部署到GitHub上的内容目录</li>
<li>public：执行hexo generate命令，输出的静态网页内容目录</li>
<li>scaffolds：layout模板文件目录，其中的md文件可以添加编辑</li>
<li>scripts：扩展脚本目录，这里可以自定义一些javascript脚本</li>
<li>source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。</li>
<li>_drafts：草稿文章</li>
<li>_posts：发布文章</li>
<li>themes：主题文件目录</li>
<li>_config.yml：全局配置文件，大多数的设置都在这里</li>
<li>package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮</li>
</ul>
<p>你可以尝试使用运行hexo服务器并<a href="127.0.0.1:4000" target="_blank" rel="external">在浏览器中打开</a>来检查Hexo是否正常工作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<h2 id="将Hexo的模板应用到github-io"><a href="#将Hexo的模板应用到github-io" class="headerlink" title="将Hexo的模板应用到github.io"></a>将Hexo的模板应用到github.io</h2><p>在hexo中有两个_config.yml文件，一个位于hexo的根目录下，我们称之为全局配置文件，另一个位于/themes/landscape/_config.yml，称之为主题配置文件。</p>
<p>打开全局配置文件_config.yml，你需要注意的配置有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">title: title    #博客名</div><div class="line">subtitle: subtitle  #博客副标题</div><div class="line">description:          #网站描述, 用于爬虫抓取的关键词</div><div class="line">author: author    #作者名称</div><div class="line">email: email  #作者邮箱</div><div class="line">language: zh-CN       #网页编码,中文</div><div class="line">root: /			# 一定要从/开始，否则与github.io不能同步路径</div><div class="line">deploy:</div><div class="line">  type: github    #部署类型Github</div><div class="line">  repository: git@github.com:username/username.github.io.git </div><div class="line">  branch: master   #部署分支,一般使用master主分支</div></pre></td></tr></table></figure>
<p>保存设置后执行命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<p>随后将hexo下的模板文件同步到github:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo deploy</div></pre></td></tr></table></figure>
<p>稍等片刻，打开你的username.github.io，应当可以看到hexo的模板页面。</p>
<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h2><p>使用如下命令后在hexo根目录中/source/_posts/目录下新增一个new-article.md文本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new &apos;new-article&apos;</div></pre></td></tr></table></figure>
<p>编辑该文件，以markdown格式书写自己的博文。关于markdown的使用方法请参考<a href="http://www.appinn.com/markdown/" target="_blank" rel="external">Markdown语法说明(简体中文版)</a>。编辑时，可启动hexo本地服务器实时查看<a href="127.0.0.1:4000" target="_blank" rel="external">页面效果</a>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>编辑完成后，使用如下命令发布到github上:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo clean		# 清理原有文件，以防与新文件冲突</div><div class="line">$ hexo generate		# 生成静态站点文件</div><div class="line">$ hexo deploy		# 发布到github pages上</div></pre></td></tr></table></figure>
<p>完成操作后，稍等十秒(github pages更新有延迟)，刷新github pages页面查看页面效果</p>
<h2 id="删除文章"><a href="#删除文章" class="headerlink" title="删除文章"></a>删除文章</h2><p>直接删除本地hexo目录下/source/_posts/中的md文件，再执行清理、生成静态站点文件、发布操作即可。命令参考”新增文章”。</p>
<h1 id="更换模板"><a href="#更换模板" class="headerlink" title="更换模板"></a>更换模板</h1><p>官方默认的主题为landscape主题，主题存放于themes文件夹中，可以更改全局配置文件来更换为需要的主题。</p>
<h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h2><p>官方提供了许多<a href="https://hexo.io/themes/" target="_blank" rel="external">主题</a>，可自行选择喜欢的主题并下载。以我使用的是<a href="https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="external">next</a>主题为例。首先需要将主题文件下载下来(在Downloads分类下)，解压后存放于themes目录下，并将文件夹名称简化为next。</p>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>打开全局配置文件，找到theme字段，将其更改为next，<a href="127.0.0.1:4000" target="_blank" rel="external">验证主题</a>是否启动:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo s --debug</div></pre></td></tr></table></figure>
<h3 id="选择-Scheme"><a href="#选择-Scheme" class="headerlink" title="选择 Scheme"></a>选择 Scheme</h3><p>NexT通过Scheme提供主题中的主题。Mist是NexT的第一款Scheme。启用Mist仅需在主题配置文件中将 #scheme: Mist 前面的#注释去掉即可。</p>
<h3 id="语言设置"><a href="#语言设置" class="headerlink" title="语言设置"></a>语言设置</h3><p>编辑全局配置文件，将 language 设置成需要的语言。例如选用正体中文，则配置为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">language: zh-Hans</div></pre></td></tr></table></figure>
<p>可用的语言如以下表格所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>语言</th>
<th>代码</th>
<th>设定值</th>
</tr>
</thead>
<tbody>
<tr>
<td>English</td>
<td>en</td>
<td>language: en</td>
</tr>
<tr>
<td>简体中文</td>
<td>zh-Hans</td>
<td>language: zh-Hans</td>
</tr>
<tr>
<td>French</td>
<td>fr-FR</td>
<td>language: fr-FR</td>
</tr>
<tr>
<td>正体中文</td>
<td>zh-hk/zh-tw</td>
<td>language: zh-hk</td>
</tr>
<tr>
<td>Russian</td>
<td>ru</td>
<td>language: ru</td>
</tr>
<tr>
<td>German</td>
<td>de</td>
<td>language: de</td>
</tr>
</tbody>
</table>
</div>
<h3 id="菜单配置"><a href="#菜单配置" class="headerlink" title="菜单配置"></a>菜单配置</h3><p>菜单配置在主题配置文件的menu。若站点运行在子目录中，请将链接前缀的/去掉。默认支持的菜单项有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>键值</th>
<th>设定值</th>
<th>comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>home</td>
<td>home:/</td>
<td>主页</td>
</tr>
<tr>
<td>archives</td>
<td>archives: /archives</td>
<td>归档页</td>
</tr>
<tr>
<td>categories</td>
<td>categories: /categories</td>
<td>分类页（需手动创建）</td>
</tr>
<tr>
<td>tags</td>
<td>tags: /tags</td>
<td>标签页（需手动创建）</td>
</tr>
<tr>
<td>about</td>
<td>about: /about</td>
<td>关于页面 （需手动创建）</td>
</tr>
<tr>
<td>commonweal</td>
<td>commonweal: /404.html</td>
<td>公益 404 （需手动创建）</td>
</tr>
</tbody>
</table>
</div>
<p>菜单配置示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /</div><div class="line">  archives: /archives</div><div class="line">  #about: /about</div><div class="line">  #categories: /categories</div><div class="line">  tags: /tags</div><div class="line">  #commonweal: /404.html</div></pre></td></tr></table></figure>
<h3 id="侧栏设置"><a href="#侧栏设置" class="headerlink" title="侧栏设置"></a>侧栏设置</h3><p>默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示。可以通过修改主题配置文件中的 sidebar 字段来控制侧栏的行为。</p>
<p>支持的选项有：</p>
<p>post - 默认行为，在文章页面（拥有目录列表）时显示<br>always - 在所有页面中都显示<br>hide - 在所有页面中都隐藏（可以手动展开）</p>
<p>侧栏示例配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sidebar: post</div></pre></td></tr></table></figure>
<h3 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h3><p>编辑主题配置文件，新增字段 avatar，值设置成头像的链接地址。</p>
<p>其中，头像的链接地址可以是完整网络图片url，或站内文件。其中站内文件的url与图片放置位置如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/uploads/avatar.jpg - 需要将头像图片放置在站点的source/uploads/（可能需要新建uploads目录）</div><div class="line">/images/avatar.jpg - 需要将头像图片放置在主题的source/images/目录下|</div></pre></td></tr></table></figure>
<p>头像配置示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">avatar: https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460</div></pre></td></tr></table></figure>
<h3 id="作者名称"><a href="#作者名称" class="headerlink" title="作者名称"></a>作者名称</h3><p>编辑全局配置文件，设置 author 为作者的昵称。</p>
<h3 id="站点描述设置"><a href="#站点描述设置" class="headerlink" title="站点描述设置"></a>站点描述设置</h3><p>编辑全局配置文件，设置 description 字段为你的站点描述。</p>
<h1 id="开启”分类”边栏入口"><a href="#开启”分类”边栏入口" class="headerlink" title="开启”分类”边栏入口"></a>开启”分类”边栏入口</h1><p>为Hexo添加分类页面的index.html，并在其菜单中显示各分类的链接</p>
<p>第一步:新建一个页面，命名为categories:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new page categories</div></pre></td></tr></table></figure>
<p>第二步:编辑新建的md文件，将页面类型设置为”categories”，主题将自动为这个页面显示所有的分类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">title: 分类</div><div class="line">date: 2014-12-22 12:39:04</div><div class="line">type: &quot;categories&quot;</div><div class="line">---</div></pre></td></tr></table></figure>
<p>注意: 如果有启动多说或Disqus评论，默认的页面也会带有评论。如果需要关闭可以将字段comments设置为false:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">title: 分类</div><div class="line">date: 2014-12-22 12:39:04</div><div class="line">type: &quot;categories&quot;</div><div class="line">comments: false</div><div class="line">---</div></pre></td></tr></table></figure>
<p>第三步:编辑主题配置文件_config.yml，将menu中的categories:/categories注释去掉:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /</div><div class="line">  categories: /categories</div><div class="line">  archives: /archives</div><div class="line">  tags: /tags</div></pre></td></tr></table></figure>
<p>第四步:清空缓存、生成静态文件、发布/预览:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div><div class="line">$ hexo generate</div><div class="line">$ hexo deploy	# 发布</div><div class="line">$ hexo server	# 打开本地服务器在页面上预览</div></pre></td></tr></table></figure>
<h1 id="开启”关于我”边栏入口"><a href="#开启”关于我”边栏入口" class="headerlink" title="开启”关于我”边栏入口"></a>开启”关于我”边栏入口</h1><p>新建一个about页面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new page &apos;about&apos;</div></pre></td></tr></table></figure>
<p>修改主题配置文件，将menu下的about:/about/注释取消即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /</div><div class="line">  archives: /archives</div><div class="line">  tags: /tags</div><div class="line">  about: /about</div></pre></td></tr></table></figure>
<p>更改menu中项目的顺序可更改在菜单中显示的顺序。</p>
<h1 id="设置侧边栏社交链接"><a href="#设置侧边栏社交链接" class="headerlink" title="设置侧边栏社交链接"></a>设置侧边栏社交链接</h1><p>编辑主题配置文件_config.yml，找到字段social，删除注释并添加社交站点名称与地址，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Social links</div><div class="line">social:</div><div class="line">  github: https://github.com/your-user-name</div><div class="line">  twitter: https://twitter.com/your-user-name</div><div class="line">  weibo: http://weibo.com/your-user-name</div><div class="line">  douban: http://douban.com/people/your-user-name</div><div class="line">  zhihu: http://www.zhihu.com/people/your-user-name</div></pre></td></tr></table></figure>
<h1 id="接入Google统计脚本"><a href="#接入Google统计脚本" class="headerlink" title="接入Google统计脚本"></a>接入Google统计脚本</h1><p>步骤一:</p>
<p>注册Google账户，登陆后访问<a href="https://analytics.google.com" target="_blank" rel="external">Google Analytics</a>，按照提示填写网站信息开通GA服务，获取统计ID。</p>
<p>步骤二:</p>
<p>编辑主题配置文件，找到字段google_analytics，删除注释并填写统计ID:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">google_analytics: your-analytics-id</div></pre></td></tr></table></figure>
<p>步骤三:</p>
<p>进入GA数据查看页查看会话数、用户数、浏览量、平均会话时长、跳出率等信息</p>
]]></content>
      
        <categories>
            
            <category> 其它 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
