<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[卓有成效的管理者]]></title>
      <url>http://lizonghang.github.io/2018/02/03/%E5%8D%93%E6%9C%89%E6%88%90%E6%95%88%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85/</url>
      <content type="html"><![CDATA[<h1 id="五项思想习惯"><a href="#五项思想习惯" class="headerlink" title="五项思想习惯"></a>五项思想习惯</h1><ol>
<li><strong>善用时间：</strong>有效的管理者应知道时间用在什么地方。他们可控的时间有限，通过有系统地工作来善用这有限的时间。</li>
<li><strong>重视成果：</strong>有效的管理者重视对外界的贡献。他们并非为工作而工作，而是为成果而工作。他们不会一接到工作就一头钻进去，更不会一开头就探究工作的技术和手段，他们会首先自问“别人期望我做出什么成果？”。</li>
<li><strong>取长避短：</strong>有效的管理者善于利用长处，包括自己的长处、上司的长处、同事的长处和下属的长处。他们还善于抓住有利的形势，做他们想做的事。他们不会把工作建立在自己的短处上，也绝不会去做自己做不了的事。</li>
<li><strong>要事第一：</strong>有效的管理者集中精力于少数重要的领域，在这少数重要的领域中，如果能有优秀的绩效就可以产生卓越的成果。他们会按照工作的轻重缓急设定优先次序，而且坚守优先次序。他们知道：要事第一。重要的事先做，不重要的事放一放，否则可能会一事无成。</li>
<li><strong>谨慎决策：</strong>有效的管理者必须善于做有效的决策。他们知道有效的决策事关处事的条例和秩序问题，也就是如何按正确的次序采取正确的步骤。他们知道一项有效的决策，总是在“不同意见讨论”的基础上做出的判断，它绝不会是“一致意见”的产物。他们知道快速的决策多为错误的决策，真正不可或缺的决策数量并不多，但一定是根本性的决策。他们需要的是正确的战略，而不是令人眼花缭乱的战术。</li>
</ol>
<h1 id="掌握自己的时间"><a href="#掌握自己的时间" class="headerlink" title="掌握自己的时间"></a>掌握自己的时间</h1><p>有效的管理者并不是一开始就着手工作，他们往往会从时间安排上着手。他们并不以计划为起点，认识清楚自己的时间用在什么地方才是起点。然后他们管理自己的时间，减少非生产性工作所占用的时间。最后，再将“可自由运用的时间”由零星集中成大块连续性的时段。这三个步骤是管理者有效性的基础：</p>
<ul>
<li>记录时间</li>
<li>管理时间</li>
<li>统一安排可自由支配的时间</li>
</ul>
<p>即时是只想获得最低程度的有效性，管理者的绝大部分任务也需要相当多的整块时间。如果每一次所花的时间少于这个极限，事情就做不好，所花的时间就是浪费，再做就得从头开始。</p>
<blockquote>
<p>举例来说，写一份报告大概得花5~8小时才能完成初稿。如果说每次花15分钟，每天2次，一共做两星期，虽然总时间达到了7小时，但恐怕结果还是一张白纸。但如果能够关起门来，连续做五六个小时，一份相当不错的初稿就应该差不多了。有了这份初稿，他才能做零星的补充，才能逐句逐段地润色、修改和整理。科学工作也与此相似。起码需要5~12小时的整块时间，才能把仪器调整妥当，做成一次实验。如果中间被打断，恐怕就得重新开始。</p>
</blockquote>
<p>每一位知识工作者，尤其是每一位管理者，要想有效就必须能将时间做整块的运用。如果将时间分隔开来零星使用，纵然总时间相同，结果时间也肯定不够。尤其是与他人一起工作时，这一点更为重要。与他人只接触三两分钟，是决不会产生什么结果的。要想与他人做有效的沟通，总得花上足够的时间。</p>
<blockquote>
<p>一位经理人员如果以为他与下属讨论一项计划、一项方针，或是一项工作表现，只需15分钟就够了，那他一定是自欺欺人。如果真想影响别人，那至少需要一个小时以上。如果想和别人建立良好的人际关系，就需要更多的时间。</p>
</blockquote>
<p>知识工作者只能自己制定工作方向，所以他必须了解别人期望他做出的贡献是什么，原因是什么，对必须使用其知识成果的人的工作情况，他也要有足够的了解。因此，知识工作者需要资料，需要讨论，还需要指导他人，这都是极为费时的。而且，他不但需要占用他上级的时间，也同样需要占用他周围同事的时间。</p>
<p>人际关系和工作关系的协调很费时间，然而任何组织都少不了这种协调。人数越多，协调相互关系所需的时间越长，而真正用于工作的时间便相对地减少了。身为管理者，也因此更应该知道自己的时间用在什么地方，并且妥善运用剩下来可自由支配的少量时间。同时，组织的人数越多，有关人事的决策也肯定越多。对人事的问题决定得太快，很容易铸成错误。人事决策往往需要大量的时间，因为决策所涉及到的一些问题，只有在反复考虑多次之后才能看清楚。</p>
<h2 id="实时的记录时间"><a href="#实时的记录时间" class="headerlink" title="实时的记录时间"></a>实时的记录时间</h2><p>要了解时间是怎样耗用的，从而据以管理时间，我们必须先记录时间。</p>
<blockquote>
<p>许多管理者都备有一本小册子记录时间，也有人请秘书代为记录。重要的是，必须在处理某一工作的当时立即加以记录，而不能事后凭记忆补记。</p>
</blockquote>
<p>许多有效的管理者都经常保持这样一份时间记录，每月定期拿出来检讨。至少，有效的管理者往往以连续三四个星期为一个时段，每天记录，一年内记录两三个时段。有了时间耗用的记录样本，他们便能自行检讨了。半年之后，他们都会发现自己的时间耗用得很乱，浪费在种种无谓的小事上。经过练习，他们在时间的利用上必有进步。但是管理时间必须持之以恒，才能避免再回到浪费的状态上去。</p>
<h2 id="系统的时间管理"><a href="#系统的时间管理" class="headerlink" title="系统的时间管理"></a>系统的时间管理</h2><p>先要将非生产性和浪费时间的活动找出来，尽可能将这类活动从时间表上排除出去。要做到这一步，可以试问自己下列几个问题。</p>
<ol>
<li>“这件事如果不做，会有什么后果？”。”如果认为“不会有任何影响”，那么这件事便该立刻取消。</li>
<li>“时间记录上的哪些活动或事务可以由别人代为参加而又不影响效果？”</li>
<li>“我是否在浪费别人的时间？”。诚恳地问自己的下属：“我常做哪些浪费你的时间而又不产生效果的事情？”。</li>
</ol>
<blockquote>
<p>例1：一个天天有应酬的总经理，天天在做一些他觉得难以割舍的事，比如应邀演讲、参加宴会、担任委员和列席指导之类，不知占去多少时间，而这些工作他本身并不感兴趣。其实，对付这类事情，只要审度一下对于组织有无贡献，对于他本人有无贡献，对于对方的组织有无贡献，如果都没有，只要谢绝就可以了。这个总经理在经过一番检讨后，发现其中至少1/3的宴请根本没有参加的必要。甚至主人发来邀请，只不过是出于礼貌而已，并不真心希望他出席。而且还有1/3的宴会只要有公司的高级管理人员到场即可，并非每次都要他亲自参加不可。</p>
<p>例2：“授权”这个名词的意义应该是把可由别人做的事情交付给别人，这样才能做真正应由自己做的事。例如，研究所为了发布研究成果的新闻，得由主持该项目的高级研究员来撰写新闻稿。研究所里很多人都知道该项研究的经过，新闻稿如果由别人写，写出来一定文笔流畅、通俗易懂，而高级研究员只能写出一些高深的数学公式。总而言之，管理者所作的工作，确实有许许多多可由别人去做，而且也应该由别人去做。</p>
<p>例3：某一大企业机构的财务经理，深感会议浪费了太多时间。通常不管讨论的是什么，他都通知财务部各单位主管全体前来开会。其结果是会议每次都拖得很长。出席会议的每一位主管，为了表示自己对问题的关切，都得表示意见，而表示的意见却大多与问题无关，会议时间自然拖长了。直到有一次这位财务经理诚恳地问了大家，才知道大家也都认为会议太浪费时间了。可是，他又想到：每一个人在组织中都至为重要，都应该了解情况，开会时如果少几个人，他又担心会使未被邀请的人觉得他们被忽视。现在这位财务经理终于找到一个两全的办法了。开会前，他先普遍分发一份开会通知：“兹订于周三下午3时，于四楼会议室，邀请赵钱孙李四位开会讨论下年度资本预算问题。如哪些需了解这个问题或愿参与讨论，亦请届时出席。如果无法出席，我们将于会后呈送记录，供各位参考并希望提供宝贵意见。”过去每次会议都要12人参加，花费整个下午，而现在只要4人出席，一小时就可以结束，并且没有一个人有被忽视的感觉。</p>
</blockquote>
<p>许多管理者都意识到了哪些事情会浪费他们的时间，然而他们却不敢面对这个问题。他们怕因小失大，造成错误。事实上，一位管理者大刀阔斧减少不必要的工作，绝对无损于有效性。能够大量削减不必要的和非生产性的工作，则工作就进行得快得多了。</p>
<blockquote>
<p>第二次世界大战期间，罗斯福总统的机要顾问霍普金斯先生当时已体衰力竭，每隔一天才能办公几小时。因此，他不能不把一切事务撇开，仅处理真正重要的工作。但这丝毫无损于他的有效性。他完成的工作，当年美国政府无人能出其右。</p>
</blockquote>
<p>时间浪费有时也是由于管理不善和机构有缺陷引起的，身为主管者也应予以同等的重视。管理不善不仅会浪费大家的时间，更重要的是会浪费主管自己的时间。所以，我们要清除浪费时间的活动。</p>
<p>1.找出由于缺乏制度或远见而产生时间浪费的因素。现象是机构中一而再再而三出现同样的“危机”。这类危机可以预先防止，或可设计成一种例行作业，即专家们从过去的危机中学会的一套有系统和有步骤的处理方式。</p>
<p>2.人员过多造成时间浪费。人员太多，以至于很多时间花费在协调人员之间的关系，而没有花在工作上。</p>
<p>判断人数是否过多有一个靠得住的标准，如果一个高级管理人员，尤其是经理，不得不将他工作时间的1/10花在处理“人际关系问题”上，花在处理纠纷和摩擦上，花在处理争执和合作等等问题上，那么这个单位就嫌人数过多了。人数过多，难免彼此侵犯，也难免成为绩效的阻碍。在精干的组织里，人的活动空间较大，不至于互相冲突，工作时也不用每次都向别人说明。</p>
<p>多用几个人，总是以“有此需要”为借口。“我们实在少不了一位热力学专家，少不了一位专利法律顾问，少不了一位学经济的人才。”但在增加了一位专家后，实在不大用得上他，也许根本用不上他。然而任用理由很多，例如：“养兵千日，用在一时”呀，“他总得熟悉我们的业务”呀，“总得一开始和我们共处”呀，用一个人，应该是每天的工作都需要用他。偶尔才有需要的专家，必要时才需要向他请教的专家，就不该正式聘用。要知道在有问题时花顾问费向他请教，远比正式聘用便宜得多。何况把这样的专家留在组织里，对整个团体的有效性肯定有不良的影响，用了他反而将成为组织的祸害。</p>
<p>3.组织不健全，其表现就是会议太多。</p>
<p>会议应该是不得已的例外，不能视为常规。一个人人都随时开会的组织，必是一个谁都不能做事的组织。原则上，一位管理者的时间绝不能让开会占用太多。会议太多，表示职位结构不当，也表示单位设置不当。会议太多，表示本应由一个职位或一个单位做的工作，分散到几个职位或几个单位去了。同时表示职责混乱，以及未能将信息传送给需要信息的人员。</p>
<p>4.信息功能不健全或信息的表达方式不当。</p>
<blockquote>
<p>例1：某一医院的院长，多年来一直为应付院内医生们的电话而苦恼。医生们打电话给他，要求他为病人安排一个床位。住院部都说是没有床位了，但这位院长几乎每次都可以找到空床位。原因是在病人出院时，住院部不能立刻接到通知。当然，有没有床位，各病房的护士长随时都清楚，主办出院结账手续的出纳台也能随时知道。住院部的人是在每天清早5点办理“床位调查”工作，而通常病人大多是在上午医生查房后才办出院手续。其实像这样的问题，只要各病房护士长在填写出院通知单给出纳台时，多填一份副本送住院部就解决了。</p>
<p>例2：制造部门常遭遇的一项困扰，是生产数字无法直接供生产作业部门使用。例如产量，报表中往往只列出会计部门所需的“平均产量”。可是直接作业人员需要的却不是平均数字，而是范围和大小，包括产品的组合、产量的变动和每批生产的时间等等。所以，他们需要这类资料时，不是每天都得花费几小时来推算，就只有在本单位内设置一个自己的秘密统计组了。当然这种资料在会计部门一定都有的，可是通常谁也不想去告诉会计部门，说自己需要的是怎样的信息。</p>
</blockquote>
<h2 id="统一安排可自由支配的时间"><a href="#统一安排可自由支配的时间" class="headerlink" title="统一安排可自由支配的时间"></a>统一安排可自由支配的时间</h2><p>管理者在做过了时间记录和分析后，就了解了有多少时间可以自由支配，又有多少时间可以用在确有贡献的大事上。但一个管理者无论删掉了多少浪费时间的活动，其自由时间仍不会太多。如果时间分割成零星的很多段，等于没有时间。因此，有效的管理者知道他必须集中他的自由时间。</p>
<p>对于如何集中自由时间，各人有各人的办法。有些高层人员在一星期内留一天在家工作。许多杂志主编和主持研究的科学家，就常采用此法。还有人将会议、审核、问题分析等例行工作，规定排在一星期内的两天中办理，而将其他日子的整个上午保留下来，用于处理真正重大的事务。还有人每天排定一段时间在家办公。</p>
<blockquote>
<p>某银行总裁，召开业务会议、约请高级职员讨论和接待重要客户之类的工作，都排在星期一和星期五。星期二、三、四的下午，则不排固定的工作，用来处理其它事务，例如研究突发的人事问题、约见回国的国外分行经理、接待重要客户，或前往华盛顿出差之类。但是在这三天的上午，他会事先排定时间表来处理重要事项，并以90分钟为一个单元。</p>
</blockquote>
<p>集中时间的方法在其次，真正重要的是时间如何用。许多人把次要的工作集中起来办理，因而匀出一段整块时间来。但这样的方法并无多大作用，因为几天或几星期后，他已经集中的自由时间又会被新的问题、新的紧急事件、新的麻烦瓜分得无影无踪了。</p>
<p>有效的管理者第一步应先估计究竟有多少自由时间真正是他自己的时间，然后保留出相当分量的一段连续性的整块时间来。一旦发现还有别的事情在“蚕食”他保留的时间，便立刻再仔细分析他的时间记录，再将其中比较次要的工作重新过滤一次。</p>
<p>一切卓有成效的管理者都懂得：对时间的控制与管理不能一劳永逸。他们要持续不断地做时间记录，定期对这些记录进行分析，还必须根据自己可以支配的时间的多少，给一些重要的活动定下必须完成的期限。</p>
<blockquote>
<p>有一位极有成效的主管，身边经常带着两张这样的完成期限表。一张是有关紧急事件的，一张是做起来自己并无兴趣但却非做不可的。每次在发现完成时间比预定期限落后时，他就警觉到可支配时间已经有溜走的迹象了。</p>
</blockquote>
<h1 id="我能贡献什么"><a href="#我能贡献什么" class="headerlink" title="我能贡献什么"></a>我能贡献什么</h1><p>重视贡献是有效性的关键。所谓有效性，表现在以下三个方面：</p>
<ol>
<li>自己的工作，包括工作内容、工作水准及其影响；</li>
<li>自己与他人的关系，包括对上司、对同事和对下属；</li>
<li>各项管理手段的运用，例如会议或报告等。</li>
</ol>
<p>可是大多数管理者重视勤奋，而忽略成果。他们耿耿于怀的是：所服务的组织和上司是否亏待了他们，是否该为他们做些什么。他们抱怨自己没有职权，结果是做事没有效果。一个人如果只知道埋头苦干，如果老是强调自己的职权，不论其职位有多高，也只能算是别人的“下属”。然而一个重视贡献的人，一个注意对成果负责的人，即时他位卑职小，也算是“高层管理人员”，因为他能对整个机构的经营绩效负责。</p>
<h2 id="管理者的贡献"><a href="#管理者的贡献" class="headerlink" title="管理者的贡献"></a>管理者的贡献</h2><p>重视贡献，才能使管理者的注意力不为其本身的专长所限，不为其本身的技术所限，不为其本身所属的部门所限，才能看到整体的绩效，同时也才能使他更加重视外部世界。只有外部世界才是产生成果的地方。因此，他会考虑自己的技能、专长、作用，以及所属单位与整个组织及组织目标的关系。只有这样，他才会凡事都想到顾客、服务对象和病人。事实上一个组织之所以存在，不论其产品是商品、是政府的服务，还是健康医疗服务，最终目的总是为了顾客、为了服务对象，或为了病人。因此，重视贡献的人，其所作所为可能与其他人截然不同。</p>
<blockquote>
<p>美国某一颇具规模的公立科学研究所，该研究所的出版部主任退休了，这位主任本身既不是科学家，也不擅长笔墨，因此，他主持出版的各种书刊常受到批评，说是缺乏学术水准。后来改由一位科学家来继任，从此该所出版的书刊面貌为之一新，具有高度学术水准了。然而，一向阅读该所书刊的科学团体却从此停止订阅了。一位教授发现了原因：“你们前任出版部主任，出版的书刊都是‘为’我们而写的，而现在的新主人，却把我们当成了写的对象。”</p>
<p>前任主任常自问：“我能为本所贡献些什么？”，他认为：“我应该引发外界年轻科学家对本所研究工作的兴趣，吸引他们来参加本所的工作”。因此，他特别强调研究所内的重大事件、重大决策，甚至于内部的争执。这样的做法屡次引起所长的不满，而且造成了正面冲突，然而他始终坚持这一原则。他说：“我们出版品是否成功，不在于‘我们’爱不爱看，而在于有多少年轻而素质良好的科学家，因读过我们的书刊而愿意前来应征工作。”</p>
</blockquote>
<p>一般机构对成效的要求往往表现在三个方面，管理者若想做点贡献，就必须在这三个方面下功夫：</p>
<p>1.直接成果</p>
<p>直接成果通常最显而易见，也是最重要的。在企业机构，销售和利润就是直接成果；在医院，对病人的护理和治疗就是直接成果。然而，如果连管理者自己都弄不清楚应有什么直接成果，那就别想有任何成果了。</p>
<blockquote>
<p>以英国的国营航空公司为例来说明。政府将这些航空公司作为企业来管理，同时又认为它们是执行国家政策和维护英联邦团结的工具。然而，它们实际上又一直是英国航空工业生存与发展的资金来源。三种不同的直接成果混淆在一起，结果是哪一种成果都没有得到。</p>
</blockquote>
<p>2.树立新的价值观及对这些价值观的重新确认；</p>
<p>一个组织必须有自己的主张和想法，否则就难免解体、混乱和瘫痪。以一个企业机构来说，其价值观的承诺也许是指建立技术权威，也许是指为社会大众寻求最好的商品和服务，并以最低的价格和最高的质量来供应。</p>
<p>3.培养与开发明天所需要的人才。</p>
<p>人都免不了一死，纵然他有再大的贡献，其贡献也因此有一定的限度。而一个组织正是克服这种限度的工具。一个组织必须今天准备明天的接班人，其人力资源必须更新，必须经常提高水准。下一代的人是站在他们前辈的肩头，再开创新的高峰，并在此基础上为他们的下一代准备更高的基准线。一个组织如果仅能维持今天的视野、今天的优点和今天的成就，它就一定会丧失适应力，并且在变幻无常的明天难以生存下去。</p>
<p>一位管理者能重视贡献，是人才发展最大的动力，因为人可以随外加的要求调整自己。重视贡献的管理者还可以帮助那些与他共事的人将眼光放得更远，这样也就提高了他们的工作水准。</p>
<blockquote>
<p>某医院新任院长在召开第一次院务会议时，以为一件棘手的事情经过讨论，已经获得可以使大家都满意的解决办法了。但这时有人提出：“这办法能使白莉安护士满意吗？”，这个问题一提出，会议中又掀起了热烈的辩论，直到另一个更为积极的解决办法研究出来。</p>
<p>后来新任院长才知道，白莉安曾是该院一位资深护士。她并没有什么特殊才能，但是每次院中有关病人护理的事情要决定时，白莉安小姐都要问：“我们对病人是否已尽了最大努力？”。凡是白小姐主管的病房中的病人，都痊愈得特别快。因此，多年以来，这家医院人人都知道了所谓“白莉安原则”，即凡事都必须先自问：“为贯彻本院的宗旨，我们真是做出了最大的贡献吗？”。</p>
<p>虽然白莉安小姐早在十年前退休了，但她所制定的标准却一直流传至今，为院中上下所信守。</p>
</blockquote>
<p>管理者的失败因素很多。常见的原因应该是他本人在出任一项新的职位时，不能或不愿为适应新职位的需要而改变。自以为过去做得成功了，因此满足于自己老一套的工作方法，结果必然遭到失败。职位有了改变，他所贡献的成果也一定改变，而且新职位所要求的上述三种绩效之间的相对比重也会改变。管理者如果不明白这层道理，仍然墨守他过去的处事方式，即时他过去是以对的方法做对的事情，现在也必将是“以错的方法做错的事情”。</p>
<h2 id="使专业人员的工作卓有成效"><a href="#使专业人员的工作卓有成效" class="headerlink" title="使专业人员的工作卓有成效"></a>使专业人员的工作卓有成效</h2><p>知识工作者不生产实物，他生产的是构想、信息和观念。知识工作者通常是一位专业人员。原则上，只有当他掌握了某种专门知识后，他的工作才能卓有成效。也就是说，他必须有所专长。但是，所谓专长，本身就是片面的、孤立的。一个专业人员的产出必须与其他人的产出结合在一起，才能产生成果。</p>
<p>但这意思并不是说专业人员应变成“通才”，而是说专业人员必须使他本人有效，必须使他的专长有效。他必须考虑到他的产出供什么人使用，也必须了解用户应该知道些什么才能有效使用他的产出，从而产生成果。</p>
<blockquote>
<p>今天有一种普遍的论调，说我们的社会可以分为“科学家”和“门外汉”两类，因此希望门外汉都应该多少具备一点科学家的常识，了解些科学术语及科学工具。殊不知我们的社会即使真能截然划分为两类人，那也是一个世纪以前的社会。事实上，在现代组织中，可以说每一个人都是专业人员，各有其专精的知识、工具、观念和术语。而现在科学的门类也越分越细，同是物理学家，可能互相不懂工作内容。</p>
<p>生物化学家固然是科学家，成本会计师又何尝不是。每个人都各有其专业领域和理想，各有其概念，各有其语言。同样地，市场研究人员、计算机编程人员，甚至政府机构的预算人员、医院的精神科医师，也都是科学家。这些人要想使自己的工作卓有成效，就必须先让别人能了解自己。</p>
</blockquote>
<p>这意思是说，知识分子有责任让别人了解自己。有些专业人员认为，普通人应该并且可以做出努力来理解他们，甚至认为他们只要能够和同行的少数专业人员沟通就够了，这真是傲慢的自大。即时是在大学或研究所，这样的态度也会使专业人员的工作变成无用，使专业人员的知识学问变成卖弄玄虚的手段。一个人如果想成为管理者，换句话说，如果愿以贡献为目标，就必须使自己的“产品”——即他的知识能为别人所用。</p>
<p>卓有成效的管理者总想了解别人需要什么、发现了什么以及能理解些什么。他们会向机构内部人员（包括他们的上司、下属，特别是其他部门的同事）提出这样的问题：“为便于你为机构作出贡献，你需要我做些什么贡献？需要我在什么时候，以哪种形式，用什么方式来提供这些贡献？”</p>
<blockquote>
<p>如果一位成本会计人员能问这样的问题，就会发现对他来说一目了然的数据，对需要这些数字的经理人来说却是完全陌生的东西。他也会发现，有些数字在他看来很重要，然而经营部门却用不上。他还可能发现，有不少资料是别人每天都需要的，但是他的报表中却没有。</p>
<p>制药工厂的生物化学家如果问了这样的问题，也会发现他的研究报告应该采用临床医师熟悉的语言，而不能采用生物化学的语言。生物化学家的研究是否能发展成为一种新药，是要经过临床试验才能决定的。</p>
<p>政务机构的科学家如果能重视贡献，也会懂得必须将科学发展的趋势及其可能的影响向政策决定人说明。他应打破科学家们的一般禁忌——即猜测一项科学调查的结果。</p>
</blockquote>
<p>所谓“通才”，应该也是一位专家，是一位能将其所专的一个小领域与其他广大知识领域联系的专家。有少数人也许可以精通几门知识，但这并不意味着他们便是通才，他们不过是精通几门知识的专家而已。一位专家只要能肩负贡献的责任，就一定能使他所专精的知识配合整体。他尽管不一定能将几门知识整合为一，但他一定知道应该了解别人的需要、别人的方向、别人的限度和别人的理解，以使别人能够应用他的成果。</p>
<h2 id="正确的人际关系"><a href="#正确的人际关系" class="headerlink" title="正确的人际关系"></a>正确的人际关系</h2><p>在一个组织中，自认为有管理天赋的管理者，往往并没有良好的人际关系。而在自己的工作上和人际关系上都比较重视贡献的管理者，往往都有良好的人际关系，他的工作也因此富有成效。有效的人际关系有下列四项基本要求：</p>
<ol>
<li>互相沟通</li>
<li>团队合作</li>
<li>自我发展</li>
<li>培养他人</li>
</ol>
<h3 id="互相沟通"><a href="#互相沟通" class="headerlink" title="互相沟通"></a>互相沟通</h3><p>如果我们一直把沟通当成是上对下的事，是主管对下属的事，仅靠上对下的单向关系，沟通永远不可能成功。上级对下属越想说得严厉，下属就越听不进去。下属要听的是自己想听的，而不是对方所说的。</p>
<p>一位在工作中以贡献为重的管理者，通常期望其下属也能以贡献为重。因此他肯定常常问他的下属：“我们的组织和我，应该期望你有怎样的贡献呢？我们该期望你做些什么？如果才能使你的知识和能力得到最大的发挥？”，有了这样的检讨，才有沟通的可能性，也才容易成功。</p>
<p>下属经过思考提出他认为可以做出的贡献之后，主管才有权利和责任对他所提出的建议是否可行做出判断。</p>
<blockquote>
<p>我们都有这样的经验：由下属自己设定的目标，往往会出乎主管的意料之外。换言之，主管和下属看问题的角度往往极不相同。下属越是能干，就越愿意自己承担责任，他们的所见所闻，所看到的客观现实、机会和需要，也越与他们的主管不同。下属的结论和主管的期望往往是明显对立的。</p>
</blockquote>
<p>出现这种分歧时，主管和下属双方究竟谁对，通常并不值得重视，因为上下双方已经建立了有效的沟通。</p>
<h3 id="团队合作"><a href="#团队合作" class="headerlink" title="团队合作"></a>团队合作</h3><p>强调贡献有助于横向的沟通，因此能够促成团队合作。“谁需要我的产出，并使它产生效益？”，这个问题能帮助我们看到与管理者责任范围无关的一些人的重要性。这种认识，正是一个知识型组织的现实：在一个知识型组织中，主要有赖于知识不同和技术不同的专业人员组成的团队，工作才能有效。各路英雄的合作，贵在自动自发，贵在能依循情势的逻辑和任务的需要，而非仅依赖正式的组织结构。</p>
<blockquote>
<p>例如在一所医院中（医院也许是最复杂的一种现代知识型组织），所有的护士、营养师、X光医师、药剂师、病理医师以及其他各方面的专家，都必须共同合作。他们面对同一位病人，但是谁也不觉得受了谁的管理和指挥。然而，他们必须为同一个共同目的而工作，而且必须符合总的行动计划，即主治医生的治疗处方。但是从组织结构的立场来说，他们各有各的上级主管。而在医疗工作上，他们各自尽其所长，以专家的身份各尽其责。同时，对一位病人的任何特殊情况及特殊需要，每一个人都必须相互告知。否则，他们的努力很可能只会适得其反。</p>
<p>在一个医院里，如果人人都已将重视贡献养成了一种近乎天性的习惯，则他们的配合和协作肯定不会有困难。反之，如果没有这种精神，则纵然有最完善的制度、有各式各样的委员会、有会议、有通告、有命令，也仍然不可能有这样的横向沟通，也不可能自然形成一个以正确的任务为中心的工作团队。</p>
</blockquote>
<p>今天的机构发生的组织问题，绝非传统的观念和理论所能解决。知识工作者必须专精于他的本行，必须对自己的能力和工作素质负责。从正式组织形态来看，他们“隶属”于某一专业职能部门——例如医院中的生物化学部、护理部等。从人事管理立场来看，他们的培训、档案、奖惩、升迁等等，也是由专业部门来管理的。但是他们在实际工作的时候，却必须是团队中的一位负责任的成员。他们的团队由全然不同领域的知识工作者组成，以当时承担的特定任务为中心。</p>
<p>当然，强调贡献并不一定必能解决组织问题，但至少能提高对任务和沟通的认识，而使一个尚未臻于理想的组织也能发挥实效。</p>
<blockquote>
<p>如何“沟通信息”一直是一个难以解决的问题。在过去，一切信息都靠人来处理和传送，故往往因沟通而失真。即信息在沟通过程中受到各人的看法、印象、意见、判断和偏见的影响。自从电脑问世以来，沟通过程不再带上各人的见解，所有的信息都变成纯信息了。在今天，我们的问题是如何建立最低限度的必要沟通，以使我们能相互了解，能认识彼此的需要、目标、感受和处事方式。而纯信息能告诉我们什么呢？唯有靠人与人之间的直接接触，通过语言或文字，才能达到沟通的目的。</p>
</blockquote>
<p>信息处理自动化程度越高，我们越需要去创造机会进行有效的沟通。</p>
<h3 id="自我发展"><a href="#自我发展" class="headerlink" title="自我发展"></a>自我发展</h3><p>自问：我对组织能有什么最大的贡献？这就等于是说：“我需要怎样的自我发展，我应该学习什么知识和技能，才有助于我对组织作出贡献？我应该将我的哪些优点用在我的工作上？我应为自己设定怎样的标准？”。</p>
<p>关于自我发展，我们可以断言：一般人都是根据自己设定的目标和要求成长起来的，知识工作者更是如此。他们自己认为应有怎样的成就，就会有怎样的成长。如果他们对自己的要求不严，就只能原地踏步，不会有任何发展。反之，如果对自己要求很高，他们就一定能成长为杰出的人物。</p>
<h3 id="培养他人"><a href="#培养他人" class="headerlink" title="培养他人"></a>培养他人</h3><p>重视贡献的管理者必然会同时启发他人寻求自我发展。这样的管理者设定的标准，一定不是他个人认定的标准，而是以任务需求为基础的标准。而且他设定的标准，一般来说要求很高，是高度的期望，是远大的目标，是具有重大冲击力的工作。</p>
<h2 id="有效的会议"><a href="#有效的会议" class="headerlink" title="有效的会议"></a>有效的会议</h2><p>管理者总不免要参加讨论会、协调会和简报会等各种会议。会议正是管理者每日使用的管理工具。当然，这些工作也占去了管理者的时间。即使最擅于分析其时间和管理时间的人，仍不免花费大量时间于会议和报告上。</p>
<p>卓有成效的管理者知道他们能从会议中得到什么，也知道会议的目的是什么。他会自问：“我们为什么要召开这次会议？是为了某项决策？是为了宣布什么？还是为了澄清我们应该做些什么？”，他会在事前想清楚会议目的，想清楚要求什么报告，以及想清楚简报的用意。他坚持开会必须真正有所贡献。</p>
<blockquote>
<p>有效的管理者在会议开始时，会先说明会议的目的和要求达成的贡献。同时，他还要设法让会议紧紧围绕着主题。他绝不会使会议成为一次摆龙门阵的机会，任大家随便发言。当然，如果会议的目的是激发大家的思想和创见，他也不会仅让某一个人滔滔不绝。他会刺激每一位与会人员的发言兴趣。但是在会议结束之前，他会回到开场所介绍的主题，使会议获得的结论与主题相符。</p>
</blockquote>
<p>还有其他一些使会议开得有效的办法。简单但是最易被人忽视的一条规则是：你可以主持会议，听取重要的发言，也可以是与大家共同讨论。但你不能既主持会议，又高谈阔论。</p>
<h1 id="如何发挥人的长处"><a href="#如何发挥人的长处" class="headerlink" title="如何发挥人的长处"></a>如何发挥人的长处</h1><p>有效的管理者能使人发挥其长处。他知道只抓住缺点和短处是干不成任何事的，为实现目标，必须用人所长——用其同事之所长、用其上级之所长和用其本身之所长。充分发挥人的长处才是组织存在的唯一目的。任何人都必定有很多缺点和短处，有些缺点和短处是短期难以改变的，但我们可以设法使其不发生作用。管理者的任务，就是要充分运用每一个人的长处，共同完成任务。</p>
<h2 id="要用人所长"><a href="#要用人所长" class="headerlink" title="要用人所长"></a>要用人所长</h2><p>管理者要运用人的长处，面临的第一关即在于择人。有效的管理者择人任事和升迁，都以一个人能做些什么为基础。所以，他的用人决策，不在于如何克服人的短处，而在于如何发挥人的长处。</p>
<blockquote>
<p>美国南北战争时，林肯总统任命格兰特将军为总司令。当时有人告诉他格兰特嗜酒贪杯，难当大任。林肯却说：“如果我知道他喜欢什么酒，我倒应该送他几桶，让大家共享。”林肯总统并不是不知道酗酒可能误事，但他更知道在北军诸将领中，只有格兰特能够运筹帷幄，决胜千里。后来的事实，证明了格兰特将军的受命正是南北战争的转折点。这也说明了林肯的用人政策是求其人能发挥所长，而不求其人是个“完人”。</p>
<p>林肯之所以懂得这些用人之道，也是经过了一番周折的。在这之前，他曾先后选用了三四位将领，选用标准都是他们必须无重大缺点。但结果是，虽然北军拥有人力物力的绝对优势，在1861年至1864年间却没有取得任何进展。反之，南方的李将军手下，从杰克逊起，几乎没有一位将领不是满身都是大小缺点。但李将军并不在意，因为他知道他所用的人，每一位都各有所长。而李将军正是善用他们的长处，使他们充分发挥。所以，在那段时期，林肯麾下每一位“无缺点”的将领都被李将军手下拥有“一技之长”的将领击败了。</p>
</blockquote>
<p>不管是谁，如果他在任用一个人时只想避免短处，那他所领导的组织最终必然是平平庸庸的。所谓“样样皆通”，实际上可能是一无是处。才干越高的人，其缺点也往往越多。有高峰必有深谷，谁也不可能是十项全能。与人类现有博大的知识、经验、能力的汇集总和相比，任何伟大的天才都不及格。世界上实在没有真正全能的人，最多只是有在某方面特别有能力的人。</p>
<p>一位管理者如果仅能见人之短而不能识人之长，因而刻意避其所短，而非着眼于发挥其所长，则这位管理者本身就是一位弱者。他会觉得别人的才干可能构成对他本身的威胁。有效的管理者知道他们之所以用人，是用人来做事，而不是用人来投主管之所好。有效的管理者从来不问：“他能跟我合得来吗？”，他们问的是：“他贡献了什么？”，他们从来不问：“他不能做什么？”，他们问的是：“他能做些什么？”。所以在用人时，他们用的都是在某一方面有所长的人，而不是在各方面都过得去的人。</p>
<p>重视一个人的长处，也就是要对他的工作绩效提出要求。如果管理者不在用人之前先问自己“他能做些什么”，那可以肯定他的下属绝难有贡献，这就等于他已经事先对下属的不称职采取了宽容的态度。真正“苛求的上司”（实际上懂得用人的上司大部分都是“苛求”的上司）总是先发掘一个人最擅长做什么，再来“苛求”他做些什么。</p>
<p>组织有特殊的手段，既可以使人的长处得到发挥，有可以使人的短处所带来的不利影响减少到最低程度。一位优秀的税务会计师，自行执业时可能因拙于待人而遇到挫折。但是在一个组织中，他可以自设一间办公室，不与其他人直接接触；一位小企业家精通财务，但可能因不懂产销而受困，而在较大规模的企业中，一位仅懂财务的人却可能极具生产性。</p>
<p>有效的管理者了解他自己的任务，在于如何使某人充分发挥其税务会计的才干，而不斤斤计较他不善于与人打交道。因此，他不会冒然指派这个人出任经理的职位。要与人打交道，完全可以找别人，而第一流的税务会计师更是不可多得的人才。所以，这个人能够做什么，才是组织器重他的原因。而他不能做什么，则仅是他的限制而已。</p>
<p>坚持“因事用人”而非“因人设事”。先有职位再物色人选来出任，往往会引人走入歧途，物色的对象，往往只是一位“仅合乎最低要求”的人选，其结果自然难免都是平平庸庸的人选了；但“因人设事”比原有的错误还糟，组织中任何一个职位的变更都会造成一连串的连锁反应，组织中的职位都是相互联系、相互依存的，牵一发而动全身，我们不能为了替某人安插一个职位，而使组织中的每一个人都受到牵连。此外，因人设事必将产生恩怨派系，组织绝对不能出现这种情况，人事的决策要凭公平和公正，否则就会赶走好人或破坏了好人的干劲。</p>
<blockquote>
<p>但有时确实有因人设事的必要。以斯隆先生为例，他一向不主张因人设事，但当他面对凯特林这位天才发明家时，他忍不住为其设置了一个工程技术部门，这就是通用汽车公司早期的工程建设部。罗斯福总统当年任用体衰力竭的霍普金斯，也打破了各种常规。不过，这种例外总是极为罕见的，它只适用于有特殊的才能，从事非同一般的工作，并取得杰出成就的人。</p>
</blockquote>
<p>那么，卓有成效的管理者究竟应该怎样用人，才不致陷入因人设事的陷阱呢？大致来说有四个原则：</p>
<p>1.卓有成效的管理者不会将职位设计成“常人”不可能胜任的职位。一个职位，如果先后由三人担任都失败了，就肯定是一个常人无法胜任的职位，这个职位就必须重新设计。</p>
<p>但是这样的职位却很常见。有些职位设定了，看起来非常合理，但却找不到合适的人选。为什么会有这样的职位呢？通常是因为先前有了一位非常人物，所以才按照这一人物的特殊天分和气质定下了职位条件。然而哪里去找这样的人？一个人也许能有多方面的知识或技能，但气质难以改变。如果一个职位要求特殊气质的人才能胜任，便注定了是不可能胜任的职位。</p>
<blockquote>
<p>例1：在营销学科教书中，常说销售管理应包括广告和促销，应隶属于同一位营销主管。然而一些知名的消费品生产厂家的经验说明，设置一个总揽全部营销业务的职位，根本是行不通的。如果行得通，那么出任这一职位的人，一方面要有高度的第一线销售能力——如何有效推动“物”；一方面又要有高度的广告和促销能力——如何有效推动“人”。这就要求做这项工作的人有各种不同的性格特点。这样的人是很难找的。</p>
<p>例2：在今天的跨国大企业中，设置了专营国际业务的副总裁的职位。起初这一职位还能找到理想人选，但是等到国外分公司的产销业务成长到相当程度时，这个职位就成为坑人的职位了。要解决这个问题，应按产品类别来调整组织，或按市场的社会和经济背景来调整组织。例如：国际部副总裁不妨分设三位，分别管高度发达国家、发展中国家和不发达国家的业务。一些化学工业公司走的就是这条路。</p>
</blockquote>
<p>有效的管理者的第一项任务就是要将自己管辖下的职位都设计得合情合理。一旦发现某职位设计不当，就要重新设计，而不会去设法寻找天才来担任，他知道组织的好坏不是由天才来验证的。只有“让平凡人都能做出不平凡的事”的组织，才是好的组织。</p>
<p>2.职位的要求要严格，而涵盖要广。</p>
<p>对于初级的知识工作的职位，这一原则尤其适用。尽管一位新人的能力不高，但他出任一项职位后，应该使他能有发展的机会。一位知识工作者在初任某一职位时，其职位的标准，应能作为他日后发展的引导，应能成为他衡量自己、评估贡献的依据。知识工作者在尚未担任一项成熟的职位之前，通常没有表现才能的机会。在学校念书最多只能显示他将来的可能成就，而实际的成就只有在实际工作中才能表现。对一位知识工作者，其同事及其上级主管最需要了解的，便是他实际上究竟能做些什么。</p>
<p>知识工作者职位的设计，还应该能够使人及早发现自己是否适合该职位。测试知识工作者是否适合某一职位，只有靠实际的工作绩效才能印证。一个人在年轻时，要调动工作并不难，但是若某人在同一组织干了十年以上，再想动就难了，尤其是那些工作缺乏成效的人。所以一位年轻的知识工作者，应该趁早做自我检讨：“就我的能力来看，我在这个组织中担任这个工作，是不是最适合？”</p>
<p>但是，如果他初任的职位涵盖太小，工作太简单，同时这职位又正是不需要经验，不能考验他能做什么的，那么他根本就无法做这样的自我检讨了。</p>
<blockquote>
<p>每次对年轻的知识工作者进行调查，例如军队里的医生、研究机构的化学家、工厂中的会计人员和工程师，以及医院的护士等等。所有的调查几乎都得到同样的结论：凡是能充分发挥其长处，而且最受到挑战的人，他的工作肯定最起劲，也肯定最能有所成就。而对工作不满的人，大都是抱怨：“他们没有让我充分发挥所长！”。</p>
</blockquote>
<p>年轻的知识工作者的职位涵盖范围太窄，不足以向他的能力挑战，其结果不是他自请离职，便是很快地变成了“老油条”。我们常听到许多主管感慨地说：想不到满怀壮志的年轻人会一个接一个消沉下去。其实这只能怪这些主管，是他们自己冻结了年轻人的热情，他们将职位设计得涵盖范围太窄了。</p>
<p>3.卓有成效的管理者在用人时，会先考虑某人能做什么，而不是先考虑职位的要求是什么。换言之，有效的管理者在决定将某人安置于某职位之前，会先仔细考虑这个人的条件，对其有个正确的评价，而且他考虑时绝不会只局限于这个职位。</p>
<p>尽管每一个大型组织都有一套评估考核人才的程序，但事实上这套程序很少被真正采用。情况通常是这样的：年年考评，年年归档，而在真要做某项人事决策时，谁也不会专门为此去翻阅档案，人人都将考评表视为无用的废纸。此外还有面谈考评的制度：由主管与其下属面对面讨论。可是这种面谈考评也因主管感到难堪而没有真正实行过，然而面谈考评却正是整个考评制度的重心所在。</p>
<p>今天大多数组织制定的考评办法，其实是源于医生对病人的评估。而医生重视的是病人的毛病，而不是病人的优点。</p>
<blockquote>
<p>日本主持管理发展研讨会，参加人都是日本大企业的高层人员。当时日本没有考评制度，他们认为：“你们的考评制度，目的只是发现一个人的错误和弱点。而在日本，不能因为某人有缺点而把他开除或降级，于是自然对考评制度没有兴趣了。我们更想知道的是这个人有什么优点，他能做些什么。而你们的考评制度根本不重视这一点”。虽然日本终身雇用的办法并不是理想的，但其“见人之所长、用人之所长”的精神值得我们学习。</p>
</blockquote>
<p>如果一位主管专找下属的缺点——例如我们的考评制度，就必将破坏主管与下属之间的团结，甚至会造成双方无法合作，所以，管理者不运用考评制度是有理由的：考评制度是一种错误的工具，用错了地方，也弄错了目标。</p>
<p>有效的管理者通常有自己一套与众不同的考评方式。第一步列出对某人过去职务和现任职务所期望的贡献，再把某人的实际绩效记录与这项期望贡献相对照，然后检讨下面四个问题：</p>
<ol>
<li>哪方面的工作他确实做得很好？</li>
<li>哪方面的工作他可能会做得更好？</li>
<li>为了充分发挥他的长处，他还应该再学习或获得哪些知识？</li>
<li>我愿意让我的子女在他的指导下工作吗？理由是什么？</li>
</ol>
<p>第四点暗示了其个人品格，正直的品格本身不一定能成就什么，但一个人如果缺乏正直和诚实，则足以败事。有这种缺点的人没有资格做管理者。</p>
<p>4.卓有成效的管理者知道在用人之所长的同时，必须容忍人之所短。</p>
<blockquote>
<p>如果需要的是一位确能履险如夷、担当重任的人物，我们就必须接受像狄斯雷利或罗斯福那样的人物，而不必去介意他们的态度缺少谦恭。</p>
</blockquote>
<p>有效的管理者会问：“这个人在某方面是否确有长处？他的长处是否确为某一任务所需？这个人如果担当这项任务，是否确能表现得与众不同？”，如果答案为“是”，就不必犹豫，延用此人。</p>
<p>只有经得起绩效考验的人才是可以提升的人。对一个没有突出表现的人，尤其是一个没有突出表现的主管，应该无情的调职，这是管理者的责任。任他留下来，必将影响全体人员，而且对于整个组织也是不公平的。对他的下属则尤为不公平，因为主管无能，则不免剥夺了下属发挥其长处的机会。</p>
<blockquote>
<p>日本的终身雇用和西方国家的文官制度，都不主张撤换已被证实不胜任的人，这是个严重的错误，我们没有必要再犯这样的错误。</p>
<p>第二次世界大战时，马歇尔将军也曾说过：一位将军如果没有特优表现，就必须立即调职。但常有人说：“主管调职，我们找不出继任人选了”。而马歇尔将军表示：“我们重视的只是这位主管不能胜任工作，至于如何去物色继任人选，那是另一回事。”</p>
<p>但马歇尔将军还认为，将一位不称职人员调职，与其说是反映了对这个人的看法，倒不如说是对任命他的人有看法。他说：“某人不称职，只是不称于‘此’职，并不表示他不能胜任别的职务。所以，选派某人出任这个职务，是我的错误，我应该负责再给他找到适合的工作。”</p>
<p>马歇尔将军任命一个人出任某个新职，从来不考虑此人在原单位“如何重要，如何缺少不了”。他的答复都是：“调他出任新职，是工作的需要，是为了他本身，也是为了部队”。</p>
</blockquote>
<p>任何一项人事任命都是一个赌注，但是，只要能抓住某人的长处是什么，至少是合理的赌注。主管对下属的工作负有责任，也掌握了下属前途发展的权力。用人之所长，不仅是有效性的要素，也是主管对下属的道义责任，是主管对其与自己职位和地位的责任。专注于人之所短，不仅是愚不可及，更是有亏职守。用人之所长是卓有成效的管理者必须具备的一种素质，是一个组织工作是否有效的关键，也是知识工作者和社会不可或缺的素质。</p>
<h2 id="如何管理上司"><a href="#如何管理上司" class="headerlink" title="如何管理上司"></a>如何管理上司</h2><p>如果上级主管的能力不够，没有升迁，下属通常是无法爬升上去的。如果有一天上司因成绩不佳调职了，继任者也往往是来自别的部门，很少在本单位中选人提升。而且新上司到任时，也总是带来他自己的亲信。反之，凡是成功而升迁得快的主管，其下属也是最容易成功的。因此，运用上司的长处，也是下属工作卓有成效的关键。只有如此，身为下属者才能将精力集中在自身的贡献上，完成自己想做的工作，取得希望取得的成就。</p>
<p>要使上司能发挥其所长，不能靠惟命是从，应该从正确的事情着手，并以上司能够接受的方式向其提出建议。上司也是人，肯定有其长处，也有其短处。若能在上司的长处上下功夫，协助他做好想做的工作，便能使上司有效，下属也才能有效。反之，如果下属总强调上司的短处，那就像上司强调下属的短处一样，结果将一无所成。所以，有效的管理者常问：“我的上司究竟能做些什么？他曾有过什么成就？要使他发挥他的长处，他还需要知道些什么？他需要我完成什么？”，至于上司不能作些什么，那就不必细究了。</p>
<p>人大致可以分为两种类型：“读者型”和“听者型”（例外类型不考虑）。我们面对“读者型”的人侃侃而谈，那是徒费口舌，因为他只能在读过之后才能“听”得进去；我们面对听者型的人递送一册厚厚的报告书，那是徒费笔墨，因为他只能“听”了之后才能掌握要点。有人只能阅读浓缩为一页的报告；有人需要了解整个理论推演的过程，所以他要的是厚厚的报告全文或是大串数字；有人喜欢及早了解情况；有人非要等到研究成熟之后才愿意听你的报告。</p>
<p>要了解上司的长处并发挥其长处，需要了解上司属于哪种类型，即“如何提出建议”。向上司提出建议时，应考虑的不光是轻重是非，更重要的是陈述的先后顺序。如果上司长于政治能力，那么我们提出的报告就应以政治方面的问题居先，这样才能使上司易于掌握问题的重心，从而易于发挥其所长。</p>
<h2 id="充分发挥自己的长处"><a href="#充分发挥自己的长处" class="headerlink" title="充分发挥自己的长处"></a>充分发挥自己的长处</h2><p>有效的管理者都能了解自己的类型，配合自己的习惯而行动。</p>
<blockquote>
<p>我们知道自己是在上午还是在晚上最有精神；当自己撰拟一份文稿时，是习惯于先写好草稿再来修改，还是习惯于一字一句推敲后完成全文；当发表演说时，是先准备好全文讲稿，还是只准备一份纲要，或是无需准备就能讲得头头是道；自己是适宜参加一个工作小组，还是一个人单独做事更出色。</p>
<p>有人做事，需要先有一个详细的计划，经过周密的通盘思考之后才能动手。但也有人一开始就做，最多只要先拟订几个要点。有人做事要靠人催逼，有人凡事都心急。有人属于“读者型”，有人属于“听者型”。自己的工作能力和习惯自己最清楚。</p>
</blockquote>
<p>重要的是，有效的管理者会顺应自己的个性特点，不会勉强自己。他注意的是自己的绩效，自己的成果，从而发展出自己的工作方式来。他会问：“哪一类工作别人做起来要费九牛二虎之力，我做起来确是轻而易举？”。</p>
<blockquote>
<p>有人能够很快写出一份报告书，有人却觉得难之又难；有人觉得起草报告容易，但分析报告，并针对报告来做决策却十分困难。这样的人更适合担任幕僚，因为幕僚只需要将材料综合起来，把问题罗列出来，他不适合担任决策者。</p>
<p>有人适宜单独行动，从头到尾一手包办；有人擅长谈判，特别是进行情绪激烈的谈判，例如劳资合约之类的谈判。在这方面，往往需要预测劳方的对策，有人料事如神，有人却常判断错误。</p>
</blockquote>
<p>在讨论一个人的长处和短处时，人们很少考虑到上述这些情况。他们想到的通常只是针对一门学问的知识，或一种艺术才能。但是，人的性情却往往是事情成败的重大关键。我们要求有效，就要以了解自己能做些什么为基础，然后以最适合自己的方式做下去。</p>
<p>在一个组织中，有效性的每一面都是“机会的开发，问题的消失”。有效的管理者把每一个人都视为可以开发的机会，包括他本人在内。任何一个团体，其行事标准都取决于领导人的表现，所以，有效的管理者会把自己的表率作用建立在充分发挥所长上。</p>
<blockquote>
<p>运动场上每出现一个新纪录，这个新纪录必成为全世界的运动员努力的新标准。多年来，谁也没有打破4分钟跑1英里的记录。但后来罗杰·班尼斯特打破了记录。于是，世界上每个田径俱乐部里的一般运动员的成绩都接近了这个记录，而新的领头羊则纷纷突破这个记录。</p>
</blockquote>
<p>领导人和一般人之间总有一段差距。领导人的绩效高了，一般人也竞相争高。有效的管理者要找出有条件做出突出贡献，并能起带头作用的人才，赋予他们领导人的地位，把他们安置到能“制订标准”并能创造成绩的位置上。</p>
]]></content>
      
        <categories>
            
            <category> 其他 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[系统编码问题]]></title>
      <url>http://lizonghang.github.io/2018/01/25/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>使用Python处理某些特殊字符或中文字符时，经常出现<code>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position xxx</code>。</p>
<p>打开一个Python解释器，看一下当前默认的编码，为ASCII码，ASCII码最多只能表示256个字符，因此对于中文字符或特殊字符就无能为力了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import sys</div><div class="line">&gt;&gt;&gt; sys.getdefaultencoding()</div><div class="line">&apos;ascii&apos;</div></pre></td></tr></table></figure>
<p>通常网上的办法为，但这不是一个好方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(&apos;utf8&apos;)</div></pre></td></tr></table></figure>
<p> 在Django Model中上传带有中文名的文件或图片时，也出现了编码错误的问题，建议不要在脚本内更改默认编码，而是将系统locale语言设置为zh_CN.UTF-8。查看系统默认语言：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ cat /etc/default/locale</div><div class="line">LANG=en_CN.UTF-8</div></pre></td></tr></table></figure>
<p>需要下载zh_CN.UTF-8并设置为默认语言:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 安装中文支持</div><div class="line">➜ sudo apt-get install language-pack-zh-hans</div><div class="line"># 更新locale文件并设置为默认语言。注意：此过程会在Shell中显示UI界面，先选中下载zh_CN.UTF-8 UTF-8语言集，回车确认，再选择设置zh_CN.UTF-8为系统默认语言。</div><div class="line">➜ dpkg-reconfigure locales</div><div class="line"># 查看当前系统语言</div><div class="line">➜ cat /etc/default/locale</div><div class="line">LANG=zh_CN.UTF-8</div></pre></td></tr></table></figure>
<p>将<code>export LC_ALL=zh_CN.UTF-8</code>添加到.bashrc并重载配置文件。</p>
<p>至此Django Model上传文件为中文文件名的UnicodeEncodeError就解决了。</p>
]]></content>
      
        <categories>
            
            <category> 服务器/后台 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark Yarn集群模式]]></title>
      <url>http://lizonghang.github.io/2018/01/14/Spark-Yarn%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>前置条件:</p>
<ul>
<li><a href="https://lizonghang.github.io/2018/01/09/Hadoop安装与伪分布式部署/#more">Hadoop+ZooKeeper</a></li>
<li><a href="https://lizonghang.github.io/2018/01/14/Spark-Standalone集群模式与ZooKeeper搭建热备HA/">Spark</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">➜ ssh parallels@master jps</div><div class="line">5763 NameNode</div><div class="line">6728 Jps</div><div class="line">6056 SecondaryNameNode</div><div class="line">3806 QuorumPeerMain</div><div class="line">➜ ssh parallels@slave1 jps</div><div class="line">3728 QuorumPeerMain</div><div class="line">4577 DataNode</div><div class="line">4789 ResourceManager</div><div class="line">5419 Jps</div><div class="line">4910 NodeManager</div><div class="line">➜ ssh parallels@slave2 jps</div><div class="line">4807 NodeManager</div><div class="line">5145 Jps</div><div class="line">3577 QuorumPeerMain</div><div class="line">4474 DataNode</div><div class="line">4686 ResourceManager</div></pre></td></tr></table></figure>
<p>修改spark-2.2.1/conf/spark-env.sh:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜ vim spark-env.sh</div><div class="line">...</div><div class="line">export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop</div><div class="line">export YARN_CONF_DIR=$HADOOP_HOME/etc/hadoop</div><div class="line"># If echo $JAVA_HOME is blank</div><div class="line">export JAVA_HOME=/usr/lib/jvm/java-8-oracle</div><div class="line">export PATH=$PATH:$JAVA_HOME/bin</div></pre></td></tr></table></figure>
<p>将spark-2.2.1/jars/*上传到HDFS文件系统中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ hadoop fs -mkdir /spark_jars</div><div class="line">➜ hadoop fs -put spark-2.2.1/jars/* /spark_jars</div></pre></td></tr></table></figure>
<p>编辑spark-default.conf:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ cp spark-defaults.conf.template spark-defaults.conf</div><div class="line">➜ vim spark-defaults.conf</div><div class="line">...</div><div class="line">spark.yarn.jars=hdfs://master:9000/spark_jars/*</div></pre></td></tr></table></figure>
<p>Cluster集群模式测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜ spark-submit --class org.apache.spark.examples.SparkPi \</div><div class="line">    --master yarn \</div><div class="line">    --deploy-mode cluster \</div><div class="line">    --driver-memory 1g \</div><div class="line">    --executor-memory 1g \</div><div class="line">    --executor-cores 1 \</div><div class="line">    examples/jars/spark-examples_2.11-2.2.1.jar \</div><div class="line">    10</div></pre></td></tr></table></figure>
<p>查看<a href="http://slave1:8088" target="_blank" rel="external">http://slave1:8088</a>该Application的状态，若State为FINISHED，FinalStatus为SUCCEEDED，则YARN集群正常工作。</p>
<p>Client集群模式测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ pyspark --master yarn --deploy-mode client</div></pre></td></tr></table></figure>
<p>Client模式运行过程中可能会报java.nio.channels.ClosedChannelException、java.io.IOException: Failed to send RPC等一堆错，查看NodeManager的日志:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Container is running beyond virtual memory limits. Current usage: 192.9 MB of 1 GB physical memory used; 2.1 GB of 2.1 GB virtual memory used. Killing container.</div></pre></td></tr></table></figure>
<p>可以判断出是虚拟内存不足导致Container关闭。</p>
<p>网上的解决办法：</p>
<p>一、根据主机内存分配设置hadoop-3.0.0/etc/hadoop/yarn-site.xml改变内存限制（无作用）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;/name&gt;</div><div class="line">&lt;value&gt;8192&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt;</div><div class="line">&lt;value&gt;1024&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.nodemanager.vmem-pmem-ratio&lt;/name&gt;</div><div class="line">&lt;value&gt;2.1&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure>
<p>二、直接关闭虚拟内存检测（无作用）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt;</div><div class="line">&lt;value&gt;false&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;</div><div class="line">&lt;value&gt;false&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure>
<p>三、给虚拟机多分配些内存</p>
]]></content>
      
        <categories>
            
            <category> Hadoop/Spark </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark Standalone集群模式与ZooKeeper搭建热备HA]]></title>
      <url>http://lizonghang.github.io/2018/01/14/Spark-Standalone%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%8EZooKeeper%E6%90%AD%E5%BB%BA%E7%83%AD%E5%A4%87HA/</url>
      <content type="html"><![CDATA[<p>集群环境说明: 开启三台Linux虚拟机，一台作为Master，两台作为Slave，NAT模式或桥接模式均可，信息如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Master</div><div class="line">    IP: 10.211.55.3</div><div class="line">    Hostname: master</div><div class="line">    Cores: 2</div><div class="line">    Memory: 2G</div><div class="line">    </div><div class="line">Slave1</div><div class="line">    IP: 10.211.55.4</div><div class="line">    Hostname: slave1</div><div class="line">    Cores: 2</div><div class="line">    Memory: 2G</div><div class="line"></div><div class="line">Slave2</div><div class="line">    IP: 10.211.55.5</div><div class="line">    Hostname: slave2</div><div class="line">    Cores: 2</div><div class="line">    Memory: 2G</div></pre></td></tr></table></figure></p>
<h1 id="Spark下载与配置"><a href="#Spark下载与配置" class="headerlink" title="Spark下载与配置"></a>Spark下载与配置</h1><h2 id="Spark下载"><a href="#Spark下载" class="headerlink" title="Spark下载"></a>Spark下载</h2><p>从官网下载适合适合本机Hadoop版本的<a href="http://spark.apache.org/downloads.html" target="_blank" rel="external">spark</a>，作者使用<a href="https://www.apache.org/dyn/closer.lua/spark/spark-2.2.1/spark-2.2.1-bin-hadoop2.7.tgz" target="_blank" rel="external">spark-2.2.1-bin-hadoop2.7.tgz</a>。假设解压到~/spark-2.2.1。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>添加环境变量：将spark-2.2.1/bin添加到$PATH$中。</p>
<p>注意: spark-2.2.1/sbin中含有与hadoop-3.0.0/sbin中相同文件名的脚本，因此不要将spark-2.2.1/sbin添加到$PATH$。</p>
<h2 id="Spark-Standalone集群模式配置"><a href="#Spark-Standalone集群模式配置" class="headerlink" title="Spark Standalone集群模式配置"></a>Spark Standalone集群模式配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜ cd spark-2.2.1/conf</div><div class="line">➜ cp slaves.template slaves</div><div class="line">➜ cp spark-env.sh.template spark-env.sh</div><div class="line">➜ vim spark-env.sh</div><div class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_111</div><div class="line">export SPARK_MASTER_IP=master</div><div class="line">export SPARK_MASTER_PORT=7077</div><div class="line">export SPARK_WORKER_CORES=1</div><div class="line">export SPARK_WORKER_INSTANCES=1</div><div class="line">export SPARK_WORKER_MEMORY=1g</div><div class="line">➜ vim slaves</div><div class="line">slave1</div><div class="line">slave2</div></pre></td></tr></table></figure>
<p>编辑好后，将spark-env.sh和slaves文件复制到slave1和slave2主机的spark-2.2.1/conf目录中。</p>
<h2 id="Spark运行与测试"><a href="#Spark运行与测试" class="headerlink" title="Spark运行与测试"></a>Spark运行与测试</h2><h3 id="启动Spark"><a href="#启动Spark" class="headerlink" title="启动Spark"></a>启动Spark</h3><p>使用spark-2.2.1/sbin/start-all.sh脚本启动Spark。</p>
<p>注意: 不是直接使用start-all.sh，因为PATH中start-all.sh对应的可能是hadoop-3.0.0/sbin/start-all.sh。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ cd spark-2.2.1</div><div class="line">➜ spark-2.2.1/sbin/start-all.sh</div><div class="line">starting org.apache.spark.deploy.master.Master, logging to /home/parallels/Desktop/spark-2.2.1/logs/spark-parallels-org.apache.spark.deploy.master.Master-1-master.out</div><div class="line">slave2: starting org.apache.spark.deploy.worker.Worker, logging to /home/parallels/Desktop/spark-2.2.1/logs/spark-parallels-org.apache.spark.deploy.worker.Worker-1-slave2.out</div><div class="line">slave1: starting org.apache.spark.deploy.worker.Worker, logging to /home/parallels/Desktop/spark-2.2.1/logs/spark-parallels-org.apache.spark.deploy.worker.Worker-1-slave1.out</div></pre></td></tr></table></figure>
<p>查看master-Master、slave1-Worker、slave2-Woker进程是否启动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">➜ ssh parallels@master jps</div><div class="line">16433 Jps</div><div class="line">16205 Master</div><div class="line">➜ ssh parallels@slave1 jps</div><div class="line">12880 Jps</div><div class="line">12465 Worker</div><div class="line">➜ ssh parallels@slave2 jps</div><div class="line">10468 Worker</div><div class="line">10890 Jps</div></pre></td></tr></table></figure>
<p>Spark可视化页面8080端口: <a href="http://master:8080。" target="_blank" rel="external">http://master:8080。</a></p>
<h3 id="Client与Cluster模式集群测试"><a href="#Client与Cluster模式集群测试" class="headerlink" title="Client与Cluster模式集群测试"></a>Client与Cluster模式集群测试</h3><h4 id="Client模式集群测试"><a href="#Client模式集群测试" class="headerlink" title="Client模式集群测试"></a>Client模式集群测试</h4><p>Client模式下Driver与Client位于同一主机master，输出直接打印到Client。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜ spark-submit --class org.apache.spark.examples.SparkPi --master spark://master:7077 --executor-memory 1G --total-executor-cores 2 spark-2.2.1/examples/jars/spark-examples_2.11-2.2.1.jar 1000</div><div class="line">...</div><div class="line">Pi is roughly 3.141622391416224</div></pre></td></tr></table></figure>
<h4 id="Cluster模式集群测试"><a href="#Cluster模式集群测试" class="headerlink" title="Cluster模式集群测试"></a>Cluster模式集群测试</h4><p>Cluster模式下Driver位于Worker的某个节点中，Client与Worker分离，输出不打印到Client，可在8080端口对应页面中Application的stdout中查看打印结果。该模式可用于长时间运行的程序。</p>
<p>注意: <code>—deploy-mode</code>默认为<code>client</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ spark-submit --class org.apache.spark.examples.SparkPi --master spark://master:7077 --deploy-mode cluster --supervise --executor-memory 1G --total-executor-cores 2 spark-2.2.1/examples/jars/spark-examples_2.11-2.2.1.jar 1000</div></pre></td></tr></table></figure>
<p>运行时可在8080端口对应页面中看到某个Worker节点上启动了Driver。</p>
<h1 id="ZooKeeper搭建热备HA"><a href="#ZooKeeper搭建热备HA" class="headerlink" title="ZooKeeper搭建热备HA"></a>ZooKeeper搭建热备HA</h1><p>官方说明: <a href="http://spark.apache.org/docs/latest/spark-standalone.html#high-availability" target="_blank" rel="external">Standby Masters with ZooKeeper</a>。</p>
<h2 id="ZooKeeper下载与配置"><a href="#ZooKeeper下载与配置" class="headerlink" title="ZooKeeper下载与配置"></a>ZooKeeper下载与配置</h2><p>参考前文<a href="https://lizonghang.github.io/2018/01/09/Hadoop安装与伪分布式部署/">Hadoop安装与伪分布式部署</a>中的”ZooKeeper安装与配置”一节。假设<code>clientPort=2181</code>。</p>
<p>启动ZooKeeper:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">➜ ssh parallels@master $ZK_HOME/bin/zkServer.sh start</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/parallels/Desktop/zookeeper-3.4.11/bin/../conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div><div class="line">➜ ssh parallels@slave1 $ZK_HOME/bin/zkServer.sh start</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/parallels/Desktop/zookeeper-3.4.11/bin/../conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div><div class="line">➜ ssh parallels@slave2 $ZK_HOME/bin/zkServer.sh start</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/parallels/Desktop/zookeeper-3.4.11/bin/../conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div><div class="line">➜ ssh parallels@master $ZK_HOME/bin/zkServer.sh status</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/parallels/Desktop/zookeeper-3.4.11/bin/../conf/zoo.cfg</div><div class="line">Mode: follower</div><div class="line">➜ ssh parallels@slave1 $ZK_HOME/bin/zkServer.sh status</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/parallels/Desktop/zookeeper-3.4.11/bin/../conf/zoo.cfg</div><div class="line">Mode: leader</div><div class="line">➜ ssh parallels@slave2 $ZK_HOME/bin/zkServer.sh status</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/parallels/Desktop/zookeeper-3.4.11/bin/../conf/zoo.cfg</div><div class="line">Mode: follower</div></pre></td></tr></table></figure></p>
<p>此时三台主机中应各有一个QuorumPeerMain进程。</p>
<h3 id="Spark-HA配置"><a href="#Spark-HA配置" class="headerlink" title="Spark HA配置"></a>Spark HA配置</h3><p>在spark-2.2.1/conf/spark-env.sh中添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export SPARK_DAEMON_JAVA_OPTS=&quot;-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=master:2181,slave1:2181,slave2:2181&quot;</div></pre></td></tr></table></figure></p>
<p>并将该文件复制到slave1和slave2中，重启Spark:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ spark-2.2.1/sbin/stop-all.sh</div><div class="line">➜ spark-2.2.1/sbin/start-all.sh</div></pre></td></tr></table></figure>
<p>此时三台主机中仍然只有master一台有Master进程，slave1和slave2只有Worker进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">➜ ssh parallels@master jps</div><div class="line">21894 Master</div><div class="line">21146 QuorumPeerMain</div><div class="line">22458 Jps</div><div class="line">➜ ssh parallels@slave1 jps</div><div class="line">17475 QuorumPeerMain</div><div class="line">18234 Worker</div><div class="line">18746 Jps</div><div class="line">➜ ssh parallels@slave2 jps</div><div class="line">15315 QuorumPeerMain</div><div class="line">16056 Worker</div><div class="line">16575 Jps</div></pre></td></tr></table></figure>
<p>假设启用slave1作为备用Master（Standby），编辑slave1中的spark-2.2.1/conf/spark-env.sh文件，将<code>SPARK_MASTER_IP</code>改为其自己。随后使用spark-2.2.1/sbin/start-master.sh&lt;/code&gt;启动slave1的Master进程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># slave1</div><div class="line">➜ spark-2.2.1/sbin/start-master.sh</div><div class="line">➜ jps</div><div class="line">17475 QuorumPeerMain</div><div class="line">19623 Jps</div><div class="line">18234 Worker</div><div class="line">19454 Master</div></pre></td></tr></table></figure>
<p>此时slave1上同时运行了Master进程和Worker进程，通过<a href="http://master:8080" target="_blank" rel="external">http://master:8080</a>和<a href="http://slave1:8080" target="_blank" rel="external">http://slave1:8080</a>可以看出master上的Master进程处于ALIVE状态，slave1上的Master进程处于STANDBY状态。</p>
<p>手动杀死master上的Master进程，隔一段时间（1-2min）可以看到slave1上的Master进程切换为ALIVE状态，并且原master上的Application信息转移到slave1。</p>
<h1 id="Spark使用Standalone集群模式运行"><a href="#Spark使用Standalone集群模式运行" class="headerlink" title="Spark使用Standalone集群模式运行"></a>Spark使用Standalone集群模式运行</h1><p>交互式环境:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ pyspark --master spark://master:7077</div></pre></td></tr></table></figure></p>
<p>脚本文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from pyspark import SparkConf, SparkContext</div><div class="line">conf = SparkConf().setMaster(&quot;spark://master:7077&quot;)</div><div class="line">sc = SparkContext(conf=conf)</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Hadoop/Spark </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hive+MySQL安装与伪分布式配置]]></title>
      <url>http://lizonghang.github.io/2018/01/10/Hive-MySQL%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="下载Hive"><a href="#下载Hive" class="headerlink" title="下载Hive"></a>下载<a href="http://mirror.bit.edu.cn/apache/hive/" target="_blank" rel="external">Hive</a></h1><p>作者使用的是hive-2.3.2，解压到~/hive-2.3.2。</p>
<h1 id="Hive配置"><a href="#Hive配置" class="headerlink" title="Hive配置"></a>Hive配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ cd cd hive-2.3.2/conf</div><div class="line">➜ cp hive-log4j2.properties.template hive-log4j2.properties</div><div class="line">➜ cp hive-default.xml.template hive-site.xml</div><div class="line">➜ cp hive-env.sh.template hive-env.sh</div><div class="line">➜ cp hive-exec-log4j2.properties.template hive-exec-log4j2.properties</div></pre></td></tr></table></figure>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ vim ~/.zshrc</div><div class="line"># Hive</div><div class="line">export HIVE_HOME=~/hive-2.3.2</div><div class="line">export PATH=$PATH:$HIVE_HOME/bin</div><div class="line">➜ source ~/.zshrc</div></pre></td></tr></table></figure>
<h2 id="修改hive-site-xml"><a href="#修改hive-site-xml" class="headerlink" title="修改hive-site.xml:"></a>修改hive-site.xml:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</div><div class="line">&lt;value&gt;jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;</div><div class="line">&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;</div><div class="line">&lt;value&gt;USER&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;</div><div class="line">&lt;value&gt;PASSWORD&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<p>注意: 其中<code>USER</code>和<code>PASSWORD</code>是MySQL中的用户名和密码，在之后设置好MySQL账户密码后修改此处。</p>
<h1 id="MySQL配置"><a href="#MySQL配置" class="headerlink" title="MySQL配置"></a>MySQL配置</h1><p>MySQL的安装参考<a href="https://lizonghang.github.io/2018/01/10/Mac安装MySQL/">Mac安装MySQL</a>或<a href="https://lizonghang.github.io/2018/01/10/Linux安装MySQL/">Linux安装MySQL</a>。</p>
<p>使用root账户以及密码登录MySQL:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ mysql -u root -p</div></pre></td></tr></table></figure></p>
<p>新建hive数据库，用来保存hive的元数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; create database hive;</div></pre></td></tr></table></figure></p>
<p>将hive数据库下的所有表的所有权限赋给hadoop用户(自定义，对应hive-site.xml中的<code>USER</code>)，并将mysql作为登录密码(自定义，对应hive-site.xml中的<code>PASSWORD</code>)，然后刷新系统权限关系表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; CREATE USER  &apos;hadoop&apos;@&apos;%&apos;  IDENTIFIED BY &apos;mysql&apos;;</div><div class="line">mysql&gt; GRANT ALL PRIVILEGES ON  *.* TO &apos;hadoop&apos;@&apos;%&apos; WITH GRANT OPTION;</div><div class="line">mysql&gt; flush privileges;</div></pre></td></tr></table></figure></p>
<p>注意: 在ubuntu系统里，默认情况下MySQL只允许本地登录，所以需要修改配置文件将地址绑定注释。在/etc/mysql/my.cnf中找到<code>bind-address</code>并注释该行。</p>
<p>将MySQL驱动包<a href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="external">mysql-connector-java-5.1.45-bin.jar</a>复制到~/hive-2.3.2/lib。</p>
<h1 id="运行Hive"><a href="#运行Hive" class="headerlink" title="运行Hive"></a>运行Hive</h1><p>先初始化Hive元数据库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ schematool -initSchema -dbType mysql</div></pre></td></tr></table></figure></p>
<p>看一下初始化后的信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜ schematool -dbType mysql -info</div><div class="line">...</div><div class="line">Metastore connection URL:     jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true</div><div class="line">Metastore Connection Driver :     com.mysql.jdbc.Driver</div><div class="line">Metastore connection User:     lizh</div><div class="line">Hive distribution version:     2.3.0</div><div class="line">Metastore schema version:     2.3.0</div><div class="line">schemaTool completed</div></pre></td></tr></table></figure></p>
<p>运行Hive:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">➜  ~ hive</div><div class="line">...</div><div class="line">hive&gt; create table test(id int,name string);</div><div class="line">OK</div><div class="line">Time taken: 0.011 seconds</div><div class="line">hive&gt; show tables;</div><div class="line">OK</div><div class="line">test</div><div class="line">Time taken: 0.022 seconds, Fetched: 1 row(s)</div></pre></td></tr></table></figure></p>
<p>看看Hive在HDFS创建的目录:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜ hadoop fs -ls /user</div><div class="line">Found 2 items</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-10 20:33 /user/hive</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-09 20:09 /user/lizh</div><div class="line">➜ hadoop fs -ls -R /user/hive</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-10 20:33 /user/hive/warehouse</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-10 20:33 /user/hive/warehouse/test</div></pre></td></tr></table></figure></p>
<p>看看Hive在MySQL中创建的新表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; use hive;</div><div class="line">mysql&gt; select * from TBLS;</div><div class="line">+--------+-------------+-------+------------------+-------+-----------+-------+----------+---------------+--------------------+--------------------+--------------------+</div><div class="line">| TBL_ID | CREATE_TIME | DB_ID | LAST_ACCESS_TIME | OWNER | RETENTION | SD_ID | TBL_NAME | TBL_TYPE      | VIEW_EXPANDED_TEXT | VIEW_ORIGINAL_TEXT | IS_REWRITE_ENABLED |</div><div class="line">+--------+-------------+-------+------------------+-------+-----------+-------+----------+---------------+--------------------+--------------------+--------------------+</div><div class="line">|      1 |  1515587593 |     1 |                0 | lizh  |         0 |     1 | test     | MANAGED_TABLE | NULL               | NULL               |                    |</div><div class="line">+--------+-------------+-------+------------------+-------+-----------+-------+----------+---------------+--------------------+--------------------+--------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Hadoop/Spark </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux安装MySQL]]></title>
      <url>http://lizonghang.github.io/2018/01/10/Linux%E5%AE%89%E8%A3%85MySQL/</url>
      <content type="html"><![CDATA[<h3 id="检查系统上是否已经装了MySQL"><a href="#检查系统上是否已经装了MySQL" class="headerlink" title="检查系统上是否已经装了MySQL"></a>检查系统上是否已经装了MySQL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ netstat -tap | grep mysql</div></pre></td></tr></table></figure>
<p>如果没有，直接用apt安装；如果已经装好了，但是不知道root密码，且没有办法获取到root密码，需要完全卸载MySQL并重装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ sudo rm -R /var/lib/mysql/</div><div class="line">➜ sudo rm -R /etc/mysql/</div><div class="line">➜ sudo apt-get autoremove mysql* --purge</div><div class="line">➜ sudo apt-get remove apparmor</div></pre></td></tr></table></figure>
<p>注意: 如果使用的shell是zsh，autoremove可能会出现no matches found: mysql<em>。zsh默认对mysql</em>进行解释，而不是传递给autoremove，因此需要在~/.zshrc中加入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setopt no_nomatch</div></pre></td></tr></table></figure>
<h3 id="apt安装MySQL"><a href="#apt安装MySQL" class="headerlink" title="apt安装MySQL"></a>apt安装MySQL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ sudo apt-get install mysql-server mysql-common</div></pre></td></tr></table></figure>
<p>安装过程中会提示输入root密码。</p>
<h3 id="登录测试"><a href="#登录测试" class="headerlink" title="登录测试"></a>登录测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ mysql -u root -p</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Hadoop/Spark </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac安装MySQL]]></title>
      <url>http://lizonghang.github.io/2018/01/10/Mac%E5%AE%89%E8%A3%85MySQL/</url>
      <content type="html"><![CDATA[<h3 id="更新-Homebrew-后安装MySQL"><a href="#更新-Homebrew-后安装MySQL" class="headerlink" title="更新 Homebrew 后安装MySQL"></a>更新 Homebrew 后安装MySQL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ brew update</div><div class="line">➜ brew install mysql</div></pre></td></tr></table></figure>
<h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ mysql.server start</div></pre></td></tr></table></figure>
<h3 id="设置登录密码"><a href="#设置登录密码" class="headerlink" title="设置登录密码"></a>设置登录密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">➜ mysql_secure_installation</div><div class="line"></div><div class="line">Securing the MySQL server deployment.</div><div class="line"></div><div class="line">Connecting to MySQL using a blank password.</div><div class="line"></div><div class="line">VALIDATE PASSWORD PLUGIN can be used to test passwords</div><div class="line">and improve security. It checks the strength of password</div><div class="line">and allows the users to set only those passwords which are</div><div class="line">secure enough. Would you like to setup VALIDATE PASSWORD plugin?</div><div class="line"></div><div class="line">Press y|Y for Yes, any other key for No: y</div><div class="line"></div><div class="line">There are three levels of password validation policy:</div><div class="line"></div><div class="line">LOW    Length &gt;= 8</div><div class="line">MEDIUM Length &gt;= 8, numeric, mixed case, and special characters</div><div class="line">STRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary file</div><div class="line"></div><div class="line">Please enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 0</div><div class="line">Please set the password for root here.</div><div class="line"></div><div class="line">New password: PASSWORD_HERE</div><div class="line"></div><div class="line">Re-enter new password: PASSWORD_HERE</div><div class="line"></div><div class="line">Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : y</div><div class="line"></div><div class="line">By default, a MySQL installation has an anonymous user,</div><div class="line">allowing anyone to log into MySQL without having to have</div><div class="line">a user account created for them. This is intended only for</div><div class="line">testing, and to make the installation go a bit smoother.</div><div class="line">You should remove them before moving into a production</div><div class="line">environment.</div><div class="line"></div><div class="line">Remove anonymous users? (Press y|Y for Yes, any other key for No) : y</div><div class="line">Success.</div><div class="line"></div><div class="line">Normally, root should only be allowed to connect from</div><div class="line">&apos;localhost&apos;. This ensures that someone cannot guess at</div><div class="line">the root password from the network.</div><div class="line"></div><div class="line">Disallow root login remotely? (Press y|Y for Yes, any other key for No) : n</div><div class="line"></div><div class="line">... skipping.</div><div class="line">By default, MySQL comes with a database named &apos;test&apos; that</div><div class="line">anyone can access. This is also intended only for testing,</div><div class="line">and should be removed before moving into a production</div><div class="line">environment.</div><div class="line"></div><div class="line">Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y</div><div class="line">- Dropping test database...</div><div class="line">Success.</div><div class="line"></div><div class="line">- Removing privileges on test database...</div><div class="line">Success.</div><div class="line"></div><div class="line">Reloading the privilege tables will ensure that all changes</div><div class="line">made so far will take effect immediately.</div><div class="line"></div><div class="line">Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y</div><div class="line">Success.</div><div class="line"></div><div class="line">All done!</div></pre></td></tr></table></figure>
<h3 id="使用设置的密码测试登录"><a href="#使用设置的密码测试登录" class="headerlink" title="使用设置的密码测试登录"></a>使用设置的密码测试登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ mysql -u root -p</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Hadoop/Spark </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[HBase安装与伪分布式部署]]></title>
      <url>http://lizonghang.github.io/2018/01/10/HBase%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<p>注意: 使用HBase需要确保已启动HDFS和ZooKeeper。</p>
<p>下载<a href="https://mirrors.cnnic.cn/apache/hbase/" target="_blank" rel="external">HBase安装包</a>，作者使用的是hbase-1.2.6。假设解压到~/hbase-1.2.6。</p>
<p>将Hadoop下的hdfs-site.xml和core-site.xml复制到HBase的conf目录下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ cp ~/hadoop-3.0.0/etc/hadoop/hdfs-site.xml ~/hbase-1.2.6/conf/</div><div class="line">➜ cp ~/hadoop-3.0.0/etc/hadoop/core-site.xml ~/hbase-1.2.6/conf/</div></pre></td></tr></table></figure>
<p>将路径~/hbase-1.2.6/bin添加到<code>PATH</code>中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># HBase</div><div class="line">export HBASE_HOME=~/hbase-1.2.6</div><div class="line">export PATH=$PATH:$HBASE_HOME/bin</div></pre></td></tr></table></figure>
<p>设置hbase-env.sh中的<code>JAVA_HOME</code>，并告诉HBase使用外部ZK:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜ vim hbase-1.2.6/conf/hbase-env.sh</div><div class="line"></div><div class="line"># The java implementation to use.  Java 1.7+ required.</div><div class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_111</div><div class="line"></div><div class="line"># Tell HBase whether it should manage it&apos;s own instance of Zookeeper or not.</div><div class="line">export HBASE_MANAGES_ZK=false</div></pre></td></tr></table></figure>
<p>配置hbase-site.xml:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">➜ vim hbase-1.2.6/conf/hbase-site.xml</div><div class="line"></div><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;hbase.rootdir&lt;/name&gt;</div><div class="line">&lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;hbase.cluster.distributed&lt;/name&gt;</div><div class="line">&lt;value&gt;true&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;hbase.master.info.port&lt;/name&gt;</div><div class="line">&lt;value&gt;60010&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;</div><div class="line">&lt;value&gt;localhost:2181,localhost:2182,localhost:2183&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<p>设置slave的集群:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜ vim hbase-1.2.6/conf/regionservers</div><div class="line"></div><div class="line">localhost</div></pre></td></tr></table></figure>
<p>注意: 若为全分布式部署，需要修改<code>hbase.rootdir</code>与<code>hbase.zookeeper.quorum</code>，并在regionservers中添加DataNode主机名。将hbase-1.2.6文件夹复制到其它节点，并启动所有节点的HBase。</p>
<p>注意: 需要提前启动ZooKeeper和HDFS。</p>
<p>启动HBase:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ start-hbase.sh</div><div class="line">➜ jps</div><div class="line">45043 HMaster</div><div class="line">45283 HRegionServer</div><div class="line">...</div></pre></td></tr></table></figure>
<p>查看HBase Web是否可访问，<a href="http://127.0.0.1:60010" target="_blank" rel="external">http://127.0.0.1:60010</a>，可以使用命令<code>netstat -tpnl | grep 60010</code>查看60010端口是否开启。</p>
<p>注意: 全分布模式下，为保证集群的可靠性，要启动多个HMaster:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ hbase-daemon.sh start master</div></pre></td></tr></table></figure>
<p>使用Shell操作HBase:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ hbase shell</div></pre></td></tr></table></figure>
<p>官方文档: <a href="http://hbase.apache.org/book.html" target="_blank" rel="external">Apache HBase ™ Reference Guide</a></p>
]]></content>
      
        <categories>
            
            <category> Hadoop/Spark </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop安装与伪分布式部署]]></title>
      <url>http://lizonghang.github.io/2018/01/09/Hadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<p>注意: 本文中<code>~</code>建议换成完整路径。</p>
<p>注意: 由于对内存要求较高，建议直接在本机，而不是在虚拟机进行实验。</p>
<h1 id="Java环境要求"><a href="#Java环境要求" class="headerlink" title="Java环境要求"></a>Java环境要求</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜ java -version</div><div class="line">java version &quot;1.8.0_91&quot;</div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_91-b14)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)</div><div class="line">➜ javac -version</div><div class="line">javac 1.8.0_111</div><div class="line">➜ jps</div><div class="line">28460 Jps</div></pre></td></tr></table></figure>
<p>若Java版本较低，建议升级到Java1.8，在官网下载对应系统的<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">jdk-8u151或jdk-8u152</a>覆盖当前版本。</p>
<h1 id="ZooKeeper安装与配置"><a href="#ZooKeeper安装与配置" class="headerlink" title="ZooKeeper安装与配置"></a>ZooKeeper安装与配置</h1><h2 id="ZooKeeper安装"><a href="#ZooKeeper安装" class="headerlink" title="ZooKeeper安装"></a>ZooKeeper安装</h2><p>在<a href="https://www.apache.org/dyn/closer.cgi/zookeeper/" target="_blank" rel="external">ZooKeeper</a>官网下载较新版本的ZooKeeper。作者使用的ZooKeeper 3.4.11。假设解压到目录<code>~/zookeeper/zookeeper-3.4.11-0</code>。</p>
<h2 id="ZooKeeper配置"><a href="#ZooKeeper配置" class="headerlink" title="ZooKeeper配置"></a>ZooKeeper配置</h2><p>进入ZooKeeper根目录，添加配置文件<code>zoo.cfg</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ cp conf/zoo_sample.cfg conf/zoo.cfg</div><div class="line">➜ vim conf/zoo.cfg</div></pre></td></tr></table></figure>
<p><code>zoo.cfg</code>配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">tickTime=2000</div><div class="line">initLimit=10</div><div class="line">syncLimit=5</div><div class="line">dataDir=~/zookeeper/zookeeper-3.4.11-0/data</div><div class="line">clientPort=2181</div><div class="line"></div><div class="line">server.0=127.0.0.1:8880:7770</div><div class="line">server.1=127.0.0.1:8881:7771</div><div class="line">server.2=127.0.0.1:8882:7772</div></pre></td></tr></table></figure>
<p>在ZooKeeper根目录下新建<code>./data/myid</code>，其记录值为<code>server.X</code>的<code>X</code>值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ mkdir data</div><div class="line">➜ echo 0 &gt; data/myid</div></pre></td></tr></table></figure>
<p>复制ZooKeeper两次，得到三个ZooKeeper文件夹:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜ cd ~/zookeeper</div><div class="line">➜ cp zookeeper-3.4.11-0 zookeeper-3.4.11-1</div><div class="line">➜ cp zookeeper-3.4.11-0 zookeeper-3.4.11-2</div></pre></td></tr></table></figure>
<p>分别修改<code>zookeeper-3.4.11-1/conf/zoo.cfg</code>和<code>zookeeper-3.4.11-2/conf/zoo.cfg</code>，将<code>dataDir</code>中的路径修改为对应文件夹名称的路径，并修改对应的<code>data/myid</code>记录值。</p>
<h2 id="ZooKeeper启动、停止与状态查询"><a href="#ZooKeeper启动、停止与状态查询" class="headerlink" title="ZooKeeper启动、停止与状态查询"></a>ZooKeeper启动、停止与状态查询</h2><h3 id="ZooKeeper启动"><a href="#ZooKeeper启动" class="headerlink" title="ZooKeeper启动"></a>ZooKeeper启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/zookeeper/zookeeper-3.4.11-0</div><div class="line">bin/zkServer.sh start conf/zoo.cfg</div></pre></td></tr></table></figure>
<h3 id="ZooKeeper停止"><a href="#ZooKeeper停止" class="headerlink" title="ZooKeeper停止"></a>ZooKeeper停止</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/zkServer.sh stop</div></pre></td></tr></table></figure>
<h3 id="ZooKeeper状态查询"><a href="#ZooKeeper状态查询" class="headerlink" title="ZooKeeper状态查询"></a>ZooKeeper状态查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/zkServer.sh status</div></pre></td></tr></table></figure>
<h2 id="ZooKeeper批量操作脚本"><a href="#ZooKeeper批量操作脚本" class="headerlink" title="ZooKeeper批量操作脚本"></a>ZooKeeper批量操作脚本</h2><p>在<code>~/zookeeper</code>新建一个文件夹<code>scripts</code>以存放脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ ls</div><div class="line">zoo-start-all.sh  zoo-status-all.sh  zoo-stop-all.sh</div></pre></td></tr></table></figure>
<p><code>zoo-start-all.sh</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">ZK_HOME_0=/home/lizh/zookeeper/zookeeper-3.4.11-0</div><div class="line">ZK_HOME_1=/home/lizh/zookeeper/zookeeper-3.4.11-1</div><div class="line">ZK_HOME_2=/home/lizh/zookeeper/zookeeper-3.4.11-2</div><div class="line"></div><div class="line">$ZK_HOME_0/bin/zkServer.sh start $ZK_HOME_0/conf/zoo.cfg</div><div class="line">$ZK_HOME_1/bin/zkServer.sh start $ZK_HOME_1/conf/zoo.cfg</div><div class="line">$ZK_HOME_2/bin/zkServer.sh start $ZK_HOME_2/conf/zoo.cfg</div><div class="line"></div><div class="line">jps</div></pre></td></tr></table></figure>
<p><code>zoo-stop-all.sh</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">ZK_HOME_0=/home/lizh/zookeeper/zookeeper-3.4.11-0</div><div class="line">ZK_HOME_1=/home/lizh/zookeeper/zookeeper-3.4.11-1</div><div class="line">ZK_HOME_2=/home/lizh/zookeeper/zookeeper-3.4.11-2</div><div class="line"></div><div class="line">$ZK_HOME_0/bin/zkServer.sh stop</div><div class="line">$ZK_HOME_1/bin/zkServer.sh stop</div><div class="line">$ZK_HOME_2/bin/zkServer.sh stop</div><div class="line"></div><div class="line">jps</div></pre></td></tr></table></figure></p>
<p><code>zoo-status-all.sh</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">ZK_HOME_0=/home/lizh/zookeeper/zookeeper-3.4.11-0</div><div class="line">ZK_HOME_1=/home/lizh/zookeeper/zookeeper-3.4.11-1</div><div class="line">ZK_HOME_2=/home/lizh/zookeeper/zookeeper-3.4.11-2</div><div class="line"></div><div class="line">$ZK_HOME_0/bin/zkServer.sh status</div><div class="line">$ZK_HOME_1/bin/zkServer.sh status</div><div class="line">$ZK_HOME_2/bin/zkServer.sh status</div><div class="line"></div><div class="line">jps</div></pre></td></tr></table></figure></p>
<p>并将路径<code>~/zookeeper/scripts</code>添加到<code>PATH</code>中，便可方便地批量启动、停止、查看ZooKeeper的状态。</p>
<h2 id="ZooKeeper启动与状态"><a href="#ZooKeeper启动与状态" class="headerlink" title="ZooKeeper启动与状态"></a>ZooKeeper启动与状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜ zoo-start-all.sh</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-0/conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-1/conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-2/conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div><div class="line">27895 QuorumPeerMain</div><div class="line">27752 QuorumPeerMain</div><div class="line">27821 QuorumPeerMain</div></pre></td></tr></table></figure>
<p>可以看到ZooKeeper启动了三个<code>QuorumPeerMain</code>进程。因为ZooKeeper采用投票机制选举Leader，因此至少需要启动三个进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜ zoo-status-all.sh</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-0/bin/../conf/zoo.cfg</div><div class="line">Mode: follower</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-1/bin/../conf/zoo.cfg</div><div class="line">Mode: leader</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /home/lizh/zookeeper/zookeeper-3.4.11-2/bin/../conf/zoo.cfg</div><div class="line">Mode: follower</div><div class="line">27895 QuorumPeerMain</div><div class="line">27752 QuorumPeerMain</div><div class="line">27821 QuorumPeerMain</div></pre></td></tr></table></figure>
<p>一个ZooKeeper集群中有且仅能有一个投票选出的Leader，其它都是Learner(包括ObServer和Follower)。此时Client可以通过端口2181~2183连接任意一个ZooKeeper:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">➜ ~/zookeeper/zookeeper-3.4.11-0/bin/zkCli.sh -server 127.0.0.1:2181</div><div class="line">...</div><div class="line">[zk: 127.0.0.1:2181(CONNECTED) 0] help</div><div class="line">ZooKeeper -server host:port cmd args</div><div class="line">        stat path [watch]</div><div class="line">        set path data [version]</div><div class="line">        ls path [watch]</div><div class="line">        delquota [-n|-b] path</div><div class="line">        ls2 path [watch]</div><div class="line">        setAcl path acl</div><div class="line">        setquota -n|-b val path</div><div class="line">        history</div><div class="line">        redo cmdno</div><div class="line">        printwatches on|off</div><div class="line">        delete path [version]</div><div class="line">        sync path</div><div class="line">        listquota path</div><div class="line">        rmr path</div><div class="line">        get path [watch]</div><div class="line">        create [-s] [-e] path data acl</div><div class="line">        addauth scheme auth</div><div class="line">        quit</div><div class="line">        getAcl path</div><div class="line">        close</div><div class="line">        connect host:port</div><div class="line">[zk: 127.0.0.1:2181(CONNECTED) 1]</div></pre></td></tr></table></figure>
<h1 id="安装Hadoop"><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h1><p>在<a href="http://hadoop.apache.org/releases.html" target="_blank" rel="external">Hadoop官网</a>下载较新版本的Hadoop binary版本。作者使用的Hadoop 3.0.0。假设解压到用户目录<code>~/hadoop-3.0.0</code>。</p>
<p>进入Hadoop根目录后，首先需要配置JAVA_HOME:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ vim etc/hadoop/hadoop-env.sh</div><div class="line">...</div><div class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_111</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>查看Hadoop是否能正常运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜ hadoop version</div><div class="line">Hadoop 3.0.0</div><div class="line">Source code repository https://git-wip-us.apache.org/repos/asf/hadoop.git -r c25427ceca461ee979d30edd7a4b0f50718e6533</div><div class="line">Compiled by andrew on 2017-12-08T19:16Z</div><div class="line">Compiled with protoc 2.5.0</div><div class="line">From source with checksum 397832cb5529187dc8cd74ad54ff22</div><div class="line">This command was run using /home/lizh/hadoop-3.0.0/share/hadoop/common/hadoop-common-3.0.0.jar</div></pre></td></tr></table></figure></p>
<h2 id="添加Hadoop可执行文件路径到PATH"><a href="#添加Hadoop可执行文件路径到PATH" class="headerlink" title="添加Hadoop可执行文件路径到PATH"></a>添加Hadoop可执行文件路径到PATH</h2><p>在<code>~/.bashrc</code>中添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Hadoop</div><div class="line">export HADOOP_HOME=~/hadoop-3.0.0</div><div class="line">export HADOOP_MAPRED_HOME=$HADOOP_HOME</div><div class="line">export PATH=$PATH:$HADOOP_HOME/bin</div><div class="line">export PATH=$PATH:$HADOOP_HOME/sbin</div></pre></td></tr></table></figure></p>
<p>以便快捷使用Hadoop可执行程序<code>bin/*</code>与脚本<code>sbin/*</code>。</p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><h3 id="log4j-properties"><a href="#log4j-properties" class="headerlink" title="log4j.properties"></a>log4j.properties</h3><p>修改<code>etc/hadoop/log4j.properties</code>文件中的<code>hadoop.root.logger</code>可控制输出日志级别。</p>
<h3 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h3><p><code>etc/hadoop/core-site.xml</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;fs.defaultFS&lt;/name&gt;</div><div class="line">&lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;</div><div class="line">&lt;value&gt;localhost:2181,localhost:2182,localhost:2183&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<h3 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h3><p><code>etc/hadoop/mapred-site.xml</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;mapreduce.framework.name&lt;/name&gt;</div><div class="line">&lt;value&gt;yarn&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt;</div><div class="line">&lt;value&gt;HADOOP_MAPRED_HOME=$HADOOP_MAPRED_HOME&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;mapreduce.map.env&lt;/name&gt;</div><div class="line">&lt;value&gt;HADOOP_MAPRED_HOME=$HADOOP_MAPRED_HOME&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;mapreduce.reduce.env&lt;/name&gt;</div><div class="line">&lt;value&gt;HADOOP_MAPRED_HOME=$HADOOP_MAPRED_HOME&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<h3 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h3><p><code>etc/hadoop/hdfs-site.xml</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;dfs.replication&lt;/name&gt;</div><div class="line">&lt;value&gt;1&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;dfs.http.address&lt;/name&gt;</div><div class="line">&lt;value&gt;0.0.0.0:50070&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;dfs.namenode.datanode.registration.ip-hostname-check&lt;/name&gt;</div><div class="line">&lt;value&gt;true&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<h3 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h3><p><code>etc/hadoop/yarn-site.xml</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.resourcemanager.zk-address&lt;/name&gt;</div><div class="line">&lt;value&gt;master:2181,slave1:2181,slave2:2181&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</div><div class="line">&lt;value&gt;mapreduce_shuffle&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<h3 id="workers"><a href="#workers" class="headerlink" title="workers"></a>workers</h3><p><code>etc/hadoop/workers</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">localhost</div></pre></td></tr></table></figure></p>
<p>注意: 若workers中直接指定服务器IP，则需要将<code>hdfs-site.xml</code>中的<code>dfs.namenode.datanode.registration.ip-hostname-check</code>指定为<code>false</code>。</p>
<p>注意: 在全分布模式下，若需要在workers中使用主机名，参考之前的文章<a href="https://lizonghang.github.io/2018/01/09/Ubuntu设置静态IP与主机名/">Ubuntu设置静态IP与主机名</a>。</p>
<h2 id="开启SSH免密登录"><a href="#开启SSH免密登录" class="headerlink" title="开启SSH免密登录"></a>开启SSH免密登录</h2><p>注意: 若为全分布模式，每两对主机之间都需要配置SSH免密；若为伪分布模式，能够<code>ssh localhost</code>即可。</p>
<h3 id="OSX系统"><a href="#OSX系统" class="headerlink" title="OSX系统"></a>OSX系统</h3><p>默认安装有sshd，需要在”系统偏好设置—&gt;共享”中打开远程登录，并将本机<code>~/.ssh/id_rsa.pub</code>添加到<code>~/.ssh/authorized_keys</code>，确认<code>ssh localhost</code>能够免密登录。</p>
<h3 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h3><p>确认系统是否按照有sshd服务，若没有，需要安装openssh-server，开启sshd服务，并将本机<code>~/.ssh/id_rsa.pub</code>添加到<code>~/.ssh/authorized_keys</code>，确认<code>ssh localhost</code>能够免密登录。</p>
<h2 id="启动Hadoop伪分布集群"><a href="#启动Hadoop伪分布集群" class="headerlink" title="启动Hadoop伪分布集群"></a>启动Hadoop伪分布集群</h2><h3 id="格式化NameNode"><a href="#格式化NameNode" class="headerlink" title="格式化NameNode"></a>格式化NameNode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ hdfs namenode -format</div></pre></td></tr></table></figure>
<p>注意: 若曾多次格式化，可能出现版本冲突导致DataNode无法启动(版本遗留问题)，删除<code>/tmp/hadoop-lizh/dfs/name/current</code>后重新格式化并启动即可。</p>
<h3 id="启动DFS与YARN"><a href="#启动DFS与YARN" class="headerlink" title="启动DFS与YARN"></a>启动DFS与YARN</h3><h4 id="一次性启动"><a href="#一次性启动" class="headerlink" title="一次性启动"></a>一次性启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">➜ start-all.sh</div><div class="line">WARNING: Attempting to start all Apache Hadoop daemons as lizh in 10 seconds.</div><div class="line">WARNING: This is not a recommended production deployment configuration.</div><div class="line">WARNING: Use CTRL-C to abort.</div><div class="line">Starting namenodes on [localhost]</div><div class="line">Starting datanodes</div><div class="line">Starting secondary namenodes [Slave8]</div><div class="line">Starting resourcemanager</div><div class="line">Starting nodemanagers</div><div class="line">➜ jps</div><div class="line">30450 NameNode</div><div class="line">31381 ResourceManager</div><div class="line">27895 QuorumPeerMain</div><div class="line">31000 SecondaryNameNode</div><div class="line">27752 QuorumPeerMain</div><div class="line">30649 DataNode</div><div class="line">31757 NodeManager</div><div class="line">27821 QuorumPeerMain</div><div class="line">32109 Jps</div></pre></td></tr></table></figure>
<h4 id="分别启动"><a href="#分别启动" class="headerlink" title="分别启动"></a>分别启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">➜ start-dfs.sh</div><div class="line">Starting namenodes on [localhost]</div><div class="line">Starting datanodes</div><div class="line">Starting secondary namenodes [Slave8]</div><div class="line">➜ jps</div><div class="line">33760 DataNode</div><div class="line">34353 Jps</div><div class="line">27895 QuorumPeerMain</div><div class="line">33559 NameNode</div><div class="line">27752 QuorumPeerMain</div><div class="line">27821 QuorumPeerMain</div><div class="line">34109 SecondaryNameNode</div><div class="line">➜ start-yarn.sh</div><div class="line">Starting resourcemanager</div><div class="line">Starting nodemanagers</div><div class="line">➜ jps</div><div class="line">33760 DataNode</div><div class="line">35268 Jps</div><div class="line">27895 QuorumPeerMain</div><div class="line">33559 NameNode</div><div class="line">27752 QuorumPeerMain</div><div class="line">34552 ResourceManager</div><div class="line">27821 QuorumPeerMain</div><div class="line">34109 SecondaryNameNode</div><div class="line">34926 NodeManager</div></pre></td></tr></table></figure>
<h3 id="查看Hadoop集群是否正常启动"><a href="#查看Hadoop集群是否正常启动" class="headerlink" title="查看Hadoop集群是否正常启动"></a>查看Hadoop集群是否正常启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">➜ hdfs dfsadmin -report</div><div class="line">Configured Capacity: 226804576256 (211.23 GB)</div><div class="line">Present Capacity: 168025718784 (156.49 GB)</div><div class="line">DFS Remaining: 168025432064 (156.49 GB)</div><div class="line">DFS Used: 286720 (280 KB)</div><div class="line">DFS Used%: 0.00%</div><div class="line">Replicated Blocks:</div><div class="line">Under replicated blocks: 0</div><div class="line">Blocks with corrupt replicas: 0</div><div class="line">Missing blocks: 0</div><div class="line">Missing blocks (with replication factor 1): 0</div><div class="line">Pending deletion blocks: 0</div><div class="line">Erasure Coded Block Groups:</div><div class="line">Low redundancy block groups: 0</div><div class="line">Block groups with corrupt internal blocks: 0</div><div class="line">Missing block groups: 0</div><div class="line">Pending deletion blocks: 0</div><div class="line"></div><div class="line">-------------------------------------------------</div><div class="line">Live datanodes (1):</div><div class="line"></div><div class="line">Name: 127.0.0.1:9866 (localhost)</div><div class="line">Hostname: Slave8</div><div class="line">Decommission Status : Normal</div><div class="line">Configured Capacity: 226804576256 (211.23 GB)</div><div class="line">DFS Used: 286720 (280 KB)</div><div class="line">Non DFS Used: 47234248704 (43.99 GB)</div><div class="line">DFS Remaining: 168025432064 (156.49 GB)</div><div class="line">DFS Used%: 0.00%</div><div class="line">DFS Remaining%: 74.08%</div><div class="line">Configured Cache Capacity: 0 (0 B)</div><div class="line">Cache Used: 0 (0 B)</div><div class="line">Cache Remaining: 0 (0 B)</div><div class="line">Cache Used%: 100.00%</div><div class="line">Cache Remaining%: 0.00%</div><div class="line">Xceivers: 1</div><div class="line">Last contact: Tue Jan 09 19:36:16 CST 2018</div><div class="line">Last Block Report: Tue Jan 09 19:31:49 CST 2018</div></pre></td></tr></table></figure>
<h3 id="查看Web端口是否开启服务"><a href="#查看Web端口是否开启服务" class="headerlink" title="查看Web端口是否开启服务"></a>查看Web端口是否开启服务</h3><ul>
<li>50070端口查看HDFS信息。</li>
<li>8088端口查看ResourceManager信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜ netstat -tpnl | grep 50070</div><div class="line">(Not all processes could be identified, non-owned process info</div><div class="line">will not be shown, you would have to be root to see it all.)</div><div class="line">tcp        0      0 127.0.0.1:50070         0.0.0.0:*               LISTEN      33559/java</div><div class="line">➜ netstat -tpnl | grep 8088</div><div class="line">(Not all processes could be identified, non-owned process info</div><div class="line">will not be shown, you would have to be root to see it all.)</div><div class="line">tcp        0      0 0.0.0.0:8088            0.0.0.0:*               LISTEN      34552/java</div></pre></td></tr></table></figure>
<p>浏览器访问<code><a href="http://localhost:50070" target="_blank" rel="external">http://localhost:50070</a></code>和<code><a href="http://localhost:8088" target="_blank" rel="external">http://localhost:8088</a></code>可进入Web页面。</p>
<p>注意: 全分布模式下50070端口需要由<code><a href="http://master:50070" target="_blank" rel="external">http://master:50070</a></code>访问，8088端口需要在开启了ResourceManager的主机(即DataNode)<code><a href="http://slave:8088" target="_blank" rel="external">http://slave:8088</a></code>访问。</p>
<p>注意: 若使用YARN作为资源管理器，但没有开启ZooKeeper，可能会导致8088端口无法访问。</p>
<h2 id="关闭Hadoop集群"><a href="#关闭Hadoop集群" class="headerlink" title="关闭Hadoop集群"></a>关闭Hadoop集群</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜ stop-all.sh</div><div class="line">WARNING: Stopping all Apache Hadoop daemons as lizh in 10 seconds.</div><div class="line">WARNING: Use CTRL-C to abort.</div><div class="line">Stopping namenodes on [localhost]</div><div class="line">Stopping datanodes</div><div class="line">Stopping secondary namenodes [Slave8]</div><div class="line">Stopping nodemanagers</div><div class="line">Stopping resourcemanager</div><div class="line">➜ jps</div><div class="line">27895 QuorumPeerMain</div><div class="line">27752 QuorumPeerMain</div><div class="line">36745 Jps</div><div class="line">27821 QuorumPeerMain</div></pre></td></tr></table></figure>
<h1 id="HDFS文件操作指令与MapReduce测试"><a href="#HDFS文件操作指令与MapReduce测试" class="headerlink" title="HDFS文件操作指令与MapReduce测试"></a>HDFS文件操作指令与MapReduce测试</h1><h2 id="HDFS文件操作指令"><a href="#HDFS文件操作指令" class="headerlink" title="HDFS文件操作指令"></a>HDFS文件操作指令</h2><p>文件指令格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop fs &lt;args&gt;</div></pre></td></tr></table></figure></p>
<p>详细指令可参考<a href="http://hadoop.apache.org/docs/r3.0.0/hadoop-project-dist/hadoop-common/FileSystemShell.html" target="_blank" rel="external">Hadoop 3.0.0官方文档</a></p>
<p>可通过<code>hadoop fs -help ls</code>查看指令描述:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">➜ hadoop fs -help ls</div><div class="line">-ls [-C] [-d] [-h] [-q] [-R] [-t] [-S] [-r] [-u] [-e] [&lt;path&gt; ...] :</div><div class="line">List the contents that match the specified file pattern. If path is not</div><div class="line">specified, the contents of /user/&lt;currentUser&gt; will be listed. For a directory a</div><div class="line">list of its direct children is returned (unless -d option is specified).</div><div class="line"></div><div class="line">Directory entries are of the form:</div><div class="line">permissions - userId groupId sizeOfDirectory(in bytes)</div><div class="line">modificationDate(yyyy-MM-dd HH:mm) directoryName</div><div class="line"></div><div class="line">and file entries are of the form:</div><div class="line">permissions numberOfReplicas userId groupId sizeOfFile(in bytes)</div><div class="line">modificationDate(yyyy-MM-dd HH:mm) fileName</div><div class="line"></div><div class="line">-C  Display the paths of files and directories only.</div><div class="line">-d  Directories are listed as plain files.</div><div class="line">-h  Formats the sizes of files in a human-readable fashion</div><div class="line">rather than a number of bytes.</div><div class="line">-q  Print ? instead of non-printable characters.</div><div class="line">-R  Recursively list the contents of directories.</div><div class="line">-t  Sort files by modification time (most recent first).</div><div class="line">-S  Sort files by size.</div><div class="line">-r  Reverse the order of the sort.</div><div class="line">-u  Use time of last access instead of modification for</div><div class="line">display and sorting.</div><div class="line">-e  Display the erasure coding policy of files and directories.</div></pre></td></tr></table></figure></p>
<p>例如使用<code>hadoop fs -ls -R /</code>可递归显示根目录下所有文件。</p>
<h2 id="MapReduce测试"><a href="#MapReduce测试" class="headerlink" title="MapReduce测试"></a>MapReduce测试</h2><ol>
<li><p>在Hadoop文件系统中创建用户文件夹，注意user为当前登录用户名，此处作者的用户名为lizh。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ hadoop fs -ls /</div><div class="line">➜ hadoop fs -mkdir -p /user/lizh</div><div class="line">➜ hadoop fs -ls -R /</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-09 20:02 /user</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-09 20:02 /user/lizh</div></pre></td></tr></table></figure>
</li>
<li><p>上传本地文本文件到HDFS(可以将hadoop-3.0.0/NOTICE.txt作为测试文本)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ hadoop fs -put hadoop-3.0.0/NOTICE.txt .</div><div class="line">➜ hadoop fs -ls</div><div class="line">Found 1 items</div><div class="line">-rw-r--r--   1 lizh supergroup      20891 2018-01-09 20:05 NOTICE.txt</div></pre></td></tr></table></figure>
</li>
</ol>
<p><code>-put hadoop-3.0.0/NOTICE.txt .</code>表示将本地NOTICE.txt文件上传到HDFS的用户主目录<code>/user/lizh</code>下，以<code>.</code>表示。当<code>-ls</code>不带路径时，默认为用户主目录。这就是必须创建路径<code>/user/username</code>而不是随意新建的原因。</p>
<ol>
<li>使用Hadoop自带测试程序wordcount来测试集群是否能够正常工作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">➜ hadoop jar hadoop-3.0.0/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.0.0.jar wordcount ./NOTICE.txt ./out/</div><div class="line">...</div><div class="line">➜ hadoop fs -ls</div><div class="line">Found 2 items</div><div class="line">-rw-r--r--   1 lizh supergroup      20891 2018-01-09 20:05 NOTICE.txt</div><div class="line">drwxr-xr-x   - lizh supergroup          0 2018-01-09 20:09 out</div><div class="line">➜ hadoop fs -ls out</div><div class="line">Found 2 items</div><div class="line">-rw-r--r--   1 lizh supergroup          0 2018-01-09 20:09 out/_SUCCESS</div><div class="line">-rw-r--r--   1 lizh supergroup      11905 2018-01-09 20:09 out/part-r-00000</div></pre></td></tr></table></figure>
</li>
</ol>
<p>程序将输出结果输出到了<code>/user/lizh/out<code>文件夹，也表明集群是正常工作的。可通过<code>hadoop fs -cat ./out/part-r-00000</code>查看输出结果:</code></code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">➜  ~ hadoop fs -cat ./out/part-r-00000</div><div class="line">&quot;AS    1</div><div class="line">&quot;GCC    1</div><div class="line">&quot;Java    1</div><div class="line">&quot;License&quot;);    1</div><div class="line">#    6</div><div class="line">&amp;    1</div><div class="line">&apos;Aalto    1</div><div class="line">&apos;Apache    4</div><div class="line">&apos;ArrayDeque&apos;,    1</div><div class="line">&apos;Bouncy    1</div><div class="line">...</div></pre></td></tr></table></figure>
<p>注意: 该步骤对于DataNode内存要求较高，虚拟机难以满足其内存需求，因此建议在单机上运行伪分布模式来测试。</p>
<p>至此，一个简易的Hadoop伪分布集群(1个NameNode，1个DataNode)就部署完成了。通过伪分布式仅是用于调试与测试，后续文章中将会讲到全分布模式的部署以及在全分布模式下如何动态增加DataNode到集群等。</p>
]]></content>
      
        <categories>
            
            <category> Hadoop/Spark </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[保持SSH长期连接]]></title>
      <url>http://lizonghang.github.io/2018/01/09/%E4%BF%9D%E6%8C%81SSH%E9%95%BF%E6%9C%9F%E8%BF%9E%E6%8E%A5/</url>
      <content type="html"><![CDATA[<p>为避免长时间无数据传输导致网络中间节点断开SSH连接的问题，在SSH服务端或客户端开启心跳报文。</p>
<ol>
<li>在客户端<code>/etc/ssh/ssh_config</code>添加<code>ServerAliveInterval 60</code>。</li>
<li>在服务端<code>/etc/ssh/sshd_config</code>添加<code>ClientAliveInterval 60</code>后重启SSH服务。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 服务器/后台 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu设置静态IP与主机名]]></title>
      <url>http://lizonghang.github.io/2018/01/09/Ubuntu%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%90%8D/</url>
      <content type="html"><![CDATA[<h1 id="设置静态IP与DNS服务器"><a href="#设置静态IP与DNS服务器" class="headerlink" title="设置静态IP与DNS服务器"></a>设置静态IP与DNS服务器</h1><p>假设子网为10.211.55.0。</p>
<p>编辑<code>/etc/network/interfaces</code>文件，添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">auto eth1</div><div class="line">iface eth1 inet static</div><div class="line">address 10.211.55.3</div><div class="line">netmask 255.255.255.0</div><div class="line">network 10.211.55.0</div><div class="line">broadcast 10.211.55.255</div><div class="line">gateway 10.211.55.1</div></pre></td></tr></table></figure>
<p>为了使主机能够上外网，确认是否指定了DNS服务器，编辑<code>/etc/resolvconf/resolv.conf.d/base</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nameserver 8.8.8.8</div></pre></td></tr></table></figure>
<p>编辑完成后，重新读取配置文件并重启网络：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo resolvconf -u</div><div class="line">sudo /etc/init.d/networking restart</div></pre></td></tr></table></figure>
<h1 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h1><p>使用命令<code>hostname</code>可查看当前主机名，编辑文件<code>/etc/hostname</code>后重启主机可修改主机名。假设有两台主机名为master和slave的主机，在修改域名映射关系后可在master上直接通过主机名访问slave提供的服务，如浏览器直接输入<code><a href="http://slave:8088" target="_blank" rel="external">http://slave:8088</a></code>。</p>
<p>假设IP-A(master)=10.211.55.3，IP-B(slave)=10.211.55.4，在A和B的<code>/etc/hosts</code>文件里都添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">10.211.55.3 master</div><div class="line">10.211.55.4 slave</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 服务器/后台 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[AliCloud-Ubuntu-Server-With-IPv6]]></title>
      <url>http://lizonghang.github.io/2016/12/09/AliCloud-Ubuntu-Server-With-IPv6/</url>
      <content type="html"><![CDATA[<h1 id="Ubuntu支持IPv6"><a href="#Ubuntu支持IPv6" class="headerlink" title="Ubuntu支持IPv6"></a>Ubuntu支持IPv6</h1><p>阿里云服务器默认是不支持IPv6协议的，需要修改<code>/etc/sysctl.conf</code>文件解除对IPv6的禁止:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">net.ipv6.conf.all.disable_ipv6 = 0</div><div class="line">net.ipv6.conf.default.disable_ipv6 = 0</div><div class="line">net.ipv6.conf.lo.disable_ipv6 = 0</div></pre></td></tr></table></figure>
<p>修改完成后，启用新的配置，为服务器分配公网IPv6地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># sysctl -p</div></pre></td></tr></table></figure>
<p>使用命令<code>ifconfig</code>应该可以在公网IPv4对应的网卡中找到对应的IPv6地址，若没有重启服务器。</p>
<h1 id="nginx支持并监听IPv6的80端口"><a href="#nginx支持并监听IPv6的80端口" class="headerlink" title="nginx支持并监听IPv6的80端口"></a>nginx支持并监听IPv6的80端口</h1><p>首先查看当前的nginx是否支持IPv6协议，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nginx -V</div></pre></td></tr></table></figure>
<p>若输出的<code>configure arguments</code>中含有<code>—-with-ipv6</code>，则当前nginx支持IPv6协议，否则需要重新编译安装nginx，编译nginx时需要加上<code>—-with-ipv6</code>。</p>
<p>确认当前nginx支持ipv6后，修改<code>nginx.conf</code>中的server段，除了监听IPv4的80端口外还需要监听IPv6的80端口,若有需要还需要监听HTTPS协议的IPv6的443端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 80; // 监听IPv4的80端口,HTTP协议</div><div class="line">    listen [::]:80; // 监听IPv6的80端口,HTTP协议</div><div class="line">    ……</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen 443; // 监听IPv4的443端口,HTTPS协议</div><div class="line">    listen [::]:443; // 监听IPv6的443端口,HTTPS协议</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="申请IPv6中转隧道"><a href="#申请IPv6中转隧道" class="headerlink" title="申请IPv6中转隧道"></a>申请IPv6中转隧道</h1><p>由于国内阿里云不提供IPv6服务，实现IPv6需要申请中转服务，可以使用<a href="https://tunnelbroker.net" target="_blank" rel="external">tunnelbroker.net</a>提供的中转服务。</p>
<ol>
<li>在tunnelbroker.net注册一个账号</li>
<li>登录后进入左侧导航栏中的<code>Create Regular Tunnel</code>，在<code>IPv4 Endpoint</code>输入你的服务器的外网IPv4地址，选择<code>Hong Kong,HK</code>隧道服务器，创建一个新的ipv6隧道</li>
<li>创建好隧道后跳转到了Tunnel Details页，IPv6 Tunnel页是隧道的基本信息，你需要验证的是<code>Client IPv4 Address</code>是否为你的服务器外网IPv4地址，需要记录<code>Client IPv6 Address</code>对应的中转IPv6地址。</li>
<li>转到Example Configurations页，选择服务器操作系统类型，比如我的服务器使用的是Ubuntu，所以选择<code>Debian/Ubuntu</code>。按要求复制文本框中的内容并粘贴到服务器上对应的文件内。例如：</li>
</ol>
<p>Paste the following into /etc/network/interfaces:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">auto he-ipv6</div><div class="line">iface he-ipv6 inet6 v4tunnel</div><div class="line">        address 2001:470:18:8cb::2</div><div class="line">        netmask 64</div><div class="line">        endpoint 216.218.221.6</div><div class="line">        local 114.215.121.63</div><div class="line">        ttl 255</div><div class="line">        gateway 2001:470:18:8cb::1</div></pre></td></tr></table></figure>
<p>我们就需要将以上he-ipv6的网卡信息写入网卡配置文件<code>/etc/network/interfaces</code>中，保存后使用以下命令启动网卡:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/networking restart</div></pre></td></tr></table></figure>
<p>重启服务器后使用命令<code>ifconfig</code>应当可以看到新增了的he-ipv6网卡。</p>
<h1 id="检查防火墙规则"><a href="#检查防火墙规则" class="headerlink" title="检查防火墙规则"></a>检查防火墙规则</h1><p>要确保防火墙没有丢弃IPv6报文的规则，若服务器没有防火墙的相关需求，可简单的通过下述方式检查防火墙规则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root@iZ28zgwg61iZ:~# iptables -nL</div><div class="line">Chain INPUT (policy ACCEPT)</div><div class="line">target     prot opt source               destination</div><div class="line"></div><div class="line">Chain FORWARD (policy ACCEPT)</div><div class="line">target     prot opt source               destination</div><div class="line"></div><div class="line">Chain OUTPUT (policy ACCEPT)</div><div class="line">target     prot opt source               destination</div></pre></td></tr></table></figure>
<p>这是一个没有设置任何规则的防火墙，对于接收、发出、转发的报文的默认策略都是ACCEPT，在这种环境下IPv6报文不受影响。</p>
<p>若需要设置一些过滤规则最好将INPUT、OUTPUT链的默认策略设置为ACCEPT，保证IPv6报文能正常收发或作一些合理的过滤，参阅相关书籍谨慎设置，不熟悉iptables的话建议先熟悉了再到VPS上设置，或者简单的将所有规则清除并设置默认策略为ACCEPT，否则很可能将自己与服务器之间的连接断开，那就只有联系机房管理员清除了。</p>
<h1 id="添加AAAA域名解析"><a href="#添加AAAA域名解析" class="headerlink" title="添加AAAA域名解析"></a>添加AAAA域名解析</h1><p>进入阿里云的管理控制台，进入云解析DNS，选择相应的域名，添加一条AAAA解析，记录值填写之前记录的<code>Client IPv6 Address</code>中记录的IPv6地址。保存后等待几分钟，等DNS服务器刷新记录。</p>
<p>注意：AAAA解析的记录值填用于中转的IPv6地址，即网卡he-ipv6中的<code>Scope:Global</code>对应的IPv6地址，而不是由第一步生成的服务器本身的外网IPv6地址。</p>
<h1 id="验证IPv6网络是否有效"><a href="#验证IPv6网络是否有效" class="headerlink" title="验证IPv6网络是否有效"></a>验证IPv6网络是否有效</h1><p>在<a href="http://ipv6-test.com/validate.php" target="_blank" rel="external">ipv6-test</a>网站中输入域名验证，若<code>AAAA DNS record</code>和<code>IPv6 web server</code>都验证通过就可以判断IPv6网络是有效的，也可以使用国外的服务器使用命令<code>ping6</code>或命令<code>curl -6</code>查看是否有返回数据。</p>
<p>注意：不建议使用国内网络测试服务器IPv6环境是否有效，因为国内大多数服务器不支持IPv6，测试者所在的网络也不一定支持IPv6网络，因此建议使用国外服务器进行测试。</p>
]]></content>
      
        <categories>
            
            <category> 服务器/后台 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[CORS跨站请求与https服务器配置]]></title>
      <url>http://lizonghang.github.io/2016/09/27/CORS%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%B8%8Ehttps%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="CORS跨站资源共享"><a href="#CORS跨站资源共享" class="headerlink" title="CORS跨站资源共享"></a>CORS跨站资源共享</h1><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>很多习惯了自己做网站的后台开发者在初次与前端或移动端合作开发时，常常遇到这么一个问题: 后台所开发出的 API 都是经过 Postman 或其他接口测试工具测试过，确认提供的这些 API 并没有异常后，将这些 API 整理成文档发给前端，但是前端的小伙伴并不能成功访问到这些接口，而是会报错: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">XMLHttpRequest cannot load http://www.desckie.com/iwantrent/getAllProduct</div><div class="line">/. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested re</div><div class="line">source. Origin &apos;http://www.puahome.com&apos; is therefore not allowed access.</div></pre></td></tr></table></figure>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这是由于浏览器安全的基石是”同源政策”，同源指是协议相同、域名相同、端口相同。同源政策的目的是为了保证用户信息的安全，防止恶意网站窃取数据。因此现在我们用 JS 或 AJAX 进行跨站请求时，由于浏览器的同源原则，使得 <code>XMLHttpRequest</code> 不能跨域通讯。</p>
<p>为了实现跨域有多种做法，其中一种较为优雅的是使用 <code>JSONP</code> 方案，但 <code>JSONP</code> 仅限于 <code>GET</code> 方法，局限性较大。</p>
<p>报错信息中有这么一句话: <code>No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</code>。请求的资源中没有 <code>‘Access-Control-Allow-Origin’</code> 请求头，它指定服务器端允许进行跨域资源访问的来源域，允许任何域的 Javascript 访问资源的方式为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Accesss-Control-Allow-Origin: *</div></pre></td></tr></table></figure>
<p>或指定具体的域可访问，如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://foo.example.com</div></pre></td></tr></table></figure>
<p>如此一来，除了 foo.example.com ，其他站点都不能跨站访问本站的资源。那么如何添加请求头呢？</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="直接处理请求头"><a href="#直接处理请求头" class="headerlink" title="直接处理请求头"></a>直接处理请求头</h3><p>在 Django 后台中我们可以通过简单的方式添加请求头，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">response[&apos;Access-Control-Allow-Origin&apos;] = &apos;*&apos;</div><div class="line">return response</div></pre></td></tr></table></figure>
<p>这也是实现跨站登录最基本的实现，但不推荐这种跨站访问方式。</p>
<h3 id="CORS跨站资源共享-1"><a href="#CORS跨站资源共享-1" class="headerlink" title="CORS跨站资源共享"></a>CORS跨站资源共享</h3><p>在 Django 中有CORS-header开源的中间件，利用这些现成的中间件，我们只需要在 settings.py 中做一些简单的配置即可实现 CORS 跨站资源共享，使得服务器端 API 完全开放，使得前后台能够较为独立的工作。</p>
<p>django-cors-headers开源项目地址为: <a href="https://github.com/ottoyiu/django-cors-headers/" target="_blank" rel="external">https://github.com/ottoyiu/django-cors-headers/</a></p>
<p>使用方法如下:</p>
<ol>
<li>安装django-cors-headers</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install django-cors-headers</div></pre></td></tr></table></figure>
<ol>
<li>将 corsheaders 加入 installed apps:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">INSTALLED_APPS = (</div><div class="line">    ...</div><div class="line">    &apos;corsheaders&apos;,</div><div class="line">    ...</div><div class="line">)</div></pre></td></tr></table></figure>
<ol>
<li>添加中间件类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">MIDDLEWARE_CLASSES = (</div><div class="line">    ...</div><div class="line">    &apos;corsheaders.middleware.CorsMiddleware&apos;,</div><div class="line">    &apos;django.middleware.common.CommonMiddleware&apos;,</div><div class="line">    ...</div><div class="line">)</div></pre></td></tr></table></figure>
<p><strong>Note</strong>: CorsMiddleware needs to come before Django’s CommonMiddleware if you are using Django’s <code>USE_ETAGS = True</code> setting, otherwise the CORS headers will be lost from the 304 not-modified responses, causing errors in some browsers.</p>
<ol>
<li>添加配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CORS_ORIGIN_ALLOW_ALL = True</div><div class="line">CORS_URLS_REGEX = r&apos;^/api/.*$&apos;</div><div class="line">CORS_ALLOW_METHODS = (&apos;GET&apos;, &apos;POST&apos;, &apos;PUT&apos;, &apos;DELETE&apos;, &apos;HEAD&apos;, &apos;PATCH&apos;, &apos;OPTIONS&apos;)</div></pre></td></tr></table></figure>
<p>生产环境中推荐使用白名单，此处为测试才设为全域。按照需要可以设置其他配置，具体设置见 <a href="https://github.com/ottoyiu/django-cors-headers/#configuration。" target="_blank" rel="external">https://github.com/ottoyiu/django-cors-headers/#configuration。</a></p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>重新用 JS 或 AJAX 跨站访问，没有出现 No ‘Access-Control-Allow-Origin’ header 报错。</p>
<h1 id="HTTPS-Nginx服务器部署"><a href="#HTTPS-Nginx服务器部署" class="headerlink" title="HTTPS Nginx服务器部署"></a>HTTPS Nginx服务器部署</h1><h2 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h2><p>跨站访问的问题解决了，再次测试又出现了新的错误，错误信息如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[blocked] The page at https://www.baidu.com/… was not allowed to display insecure content from http://www.desckie.com/iwantrent/getAllProduct/.</div></pre></td></tr></table></figure>
<h2 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h2><p>从报错信息上我们可以判断出，请求的网页被作为不安全的网页给浏览器阻塞了，原因就出在使用的协议为 http 协议。http 协议传输的数据在网络上为明文传输，容易被中间人窃取导致用户信息泄露，因此 http 协议实际上是不安全的。https 协议是 http 的安全版，即 http 下加入 SSL 层。要解决这个问题我们需要将协议更改为 https 协议。以 Nginx 服务器为例。</p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="申请-SSL-证书"><a href="#申请-SSL-证书" class="headerlink" title="申请 SSL 证书"></a>申请 SSL 证书</h3><p>这里我们使用自行颁发的免费 SSL 证书，它虽然能实现加密传输功能，但这类证书是不受浏览器信任的。用户在进入该网站时可能会出现提示: 此网站的安全证书有问题。但向专业机构申请 SSL 证书不仅需要出示相关证件，而且还要付费，所以我们这里就使用自行颁发的 SSL 证书。</p>
<ol>
<li>openssl genrsa -des3 -out api.bz.key 1024</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-96-46-ubuntu:~$ openssl genrsa -des3 -out api.bz.key 1024</div><div class="line">Generating RSA private key, 1024 bit long modulus</div><div class="line">............................++++++</div><div class="line">..............++++++</div><div class="line">e is 65537 (0x10001)</div><div class="line">Enter pass phrase for api.bz.key:</div><div class="line">Verifying - Enter pass phrase for api.bz.key:输入密码</div></pre></td></tr></table></figure>
<ol>
<li>openssl req -new -key api.bz.key -out api.bz.csr</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-96-46-ubuntu:~$ openssl req -new -key api.bz.key -out api.bz.csr</div><div class="line">Enter pass phrase for api.bz.key: 刚刚设置的密码</div><div class="line">You are about to be asked to enter information that will be incorporated</div><div class="line">into your certificate request.</div><div class="line">What you are about to enter is what is called a Distinguished Name or a DN.</div><div class="line">There are quite a few fields but you can leave some blank</div><div class="line">For some fields there will be a default value,</div><div class="line">If you enter &apos;.&apos;, the field will be left blank.</div><div class="line">-----</div><div class="line">Country Name (2 letter code) [AU]:CN</div><div class="line">State or Province Name (full name) [Some-State]:Beijing</div><div class="line">Locality Name (eg, city) []:Beijing</div><div class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:API.BZ</div><div class="line">Organizational Unit Name (eg, section) []:API.BZ</div><div class="line">Common Name (e.g. server FQDN or YOUR name) []:*.api.bz</div><div class="line">Email Address []:admin@api.bz</div><div class="line"></div><div class="line">Please enter the following &apos;extra&apos; attributes</div><div class="line">to be sent with your certificate request</div><div class="line">A challenge password []: 回车</div><div class="line">An optional company name []: 回车</div></pre></td></tr></table></figure>
<ol>
<li>openssl rsa -in api.bz.key -out api.bz_nopass.key</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-96-46-ubuntu:~$ openssl rsa -in api.bz.key -out api.bz_nopass.key</div><div class="line">Enter pass phrase for api.bz.key:</div><div class="line">writing RSA key</div></pre></td></tr></table></figure>
<ol>
<li>openssl req -new -x509 -days 3650 -key api.bz_nopass.key -out api.bz.crt</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-96-46-ubuntu:~$ openssl req -new -x509 -days 3650 -key api.bz_nopass.key -out api.bz.crt</div><div class="line">You are about to be asked to enter information that will be incorporated</div><div class="line">into your certificate request.</div><div class="line">What you are about to enter is what is called a Distinguished Name or a DN.</div><div class="line">There are quite a few fields but you can leave some blank</div><div class="line">For some fields there will be a default value,</div><div class="line">If you enter &apos;.&apos;, the field will be left blank.</div><div class="line">-----</div><div class="line">Country Name (2 letter code) [AU]:CN</div><div class="line">State or Province Name (full name) [Some-State]:Beijing</div><div class="line">Locality Name (eg, city) []:Beijing</div><div class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:API.BZ</div><div class="line">Organizational Unit Name (eg, section) []:API.BZ</div><div class="line">Common Name (e.g. server FQDN or YOUR name) []:*.api.bz</div><div class="line">Email Address []:admin@api.bz</div></pre></td></tr></table></figure>
<p>到这里 SSL 证书就申请好了，此时应该有四个文件，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-96-46-ubuntu:~$ ls</div><div class="line">api.bz.crt  api.bz.csr  api.bz.key  api.bz_nopass.key ...</div></pre></td></tr></table></figure>
<p>我们要用的是 <code>api.bz.crt</code> 和 <code>api.bz_nopass.key</code> 两个文件。</p>
<h3 id="更改-Nginx-配置"><a href="#更改-Nginx-配置" class="headerlink" title="更改 Nginx 配置"></a>更改 Nginx 配置</h3><p>在配置文件 nginx.conf 中的 server 字段中有这么一段被注释的 HTTPS 配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># HTTPS server</div><div class="line">#</div><div class="line"># server &#123;</div><div class="line">#   listen 443;</div><div class="line">#   server_name localhost;</div><div class="line">#</div><div class="line">#   root html;</div><div class="line">#   index index.html index.htm;</div><div class="line">#</div><div class="line">#   ssl on;</div><div class="line">#   ssl_certificate cert.pem;</div><div class="line">#   ssl_certificate_key cert.key;</div><div class="line">#</div><div class="line">#   ssl_session_timeout 5m;</div><div class="line">#</div><div class="line">#   ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">#   ssl_ciphers &quot;HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES&quot;;</div><div class="line">#   ssl_prefer_server_ciphers on;</div><div class="line">#</div><div class="line">#   location / &#123;</div><div class="line">#       try_files $uri $uri/ =404;</div><div class="line">#   &#125;</div><div class="line">#&#125;</div></pre></td></tr></table></figure>
<p>我们不需要使用其中所有的配置，根据 SSL 证书的路径修改相应的配置项(省去了注释项):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">        listen 443;</div><div class="line">        server_name sms.api.bz;</div><div class="line"></div><div class="line">        ssl on;</div><div class="line">        ssl_certificate /root/api.bz.crt;</div><div class="line">        ssl_certificate_key /root/api.bz_nopass.key;</div><div class="line">        </div><div class="line">        location / &#123;</div><div class="line">                include /etc/nginx/uwsgi_params;</div><div class="line">                uwsgi_pass 127.0.0.1:8077;</div><div class="line">                include /etc/nginx/mime.types;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        location ~* \.*(gif|png|jpg|jpeg|css|js|ttf|less)$ &#123;</div><div class="line">                root /root/RentMe;</div><div class="line">                access_log /root/nginx_access.log;</div><div class="line">                error_log /root/nginx_error.log;</div><div class="line">                include /etc/nginx/mime.types;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 location 可以从 HTTP 的配置项中复制过来。修改完成后，验证配置文件有效性并重启 nginx 服务器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@iZ28zgwg61iZ:~# /usr/sbin/nginx -t</div><div class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</div><div class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</div><div class="line">root@iZ28zgwg61iZ:~# /usr/sbin/nginx -s reload</div></pre></td></tr></table></figure>
<p>随后使用 https 方式进入你的网站，会先提示网站的安全证书有问题，无需理会。到这里网站就从 http 协议更换成 https 协议了，之后就可以用 https 方式更安全的访问网站。</p>
<h2 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h2><p>下图是从 leancloud.cn 通过 js 跨站访问的截图，没有出现跨站访问错误和安全警告，如图:</p>
<p><img src="/images/https.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 服务器/后台 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Getting Started With Videos]]></title>
      <url>http://lizonghang.github.io/2016/08/16/Getting-Started-With-Videos/</url>
      <content type="html"><![CDATA[<h1 id="Capture-Video-from-Camera"><a href="#Capture-Video-from-Camera" class="headerlink" title="Capture Video from Camera"></a>Capture Video from Camera</h1><p>To capture a video, you need to create a VideoCapture object. Its argument can be either the device index or the name of a video file. Device index is just the number to specify which camera. Normally one camera will be connected (as in my case). So I simply pass 0 (or -1). You can select the second camera by passing 1 and so on. After that, you can capture frame-by-frame. But at the end, don’t forget to release the capture. You can press ESC to quit.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">cap = cv2.VideoCapture(0)</div><div class="line">while True:</div><div class="line">    ret, frame = cap.read()</div><div class="line">    cv2.imshow(&apos;recording&apos;, frame)</div><div class="line">    if cv2.waitKey(25) == 27:</div><div class="line">        break</div><div class="line">cap.release()</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p><code>cap.read()</code> returns a bool (True/False). If frame is read correctly, it will be True. So you can check end of the video by checking this return value.</p>
<p>Sometimes, <code>cap</code> may not have initialized the capture. In that case, this code shows error. You can check whether it is initialized or not by the method <code>cap.isOpened()</code>. Otherwise open it using <code>cap.open()</code>.</p>
<p>You can also access some of the features of this video using <code>cap.get(propId)</code> method where propId is a number from 0 to 18. Each number denotes a property of the video (if it is applicable to that video) and full details can be seen in  <a href="http://docs.opencv.org/2.4/modules/highgui/doc/reading_and_writing_images_and_video.html#videocapture-get" target="_blank" rel="external">Property Identifier</a>. Some of these values can be modified using <code>cap.set(propId, value)</code>. Value is the new value you want.</p>
<p>For example, I can check the frame width and height by <code>cap.get(3)</code> and <code>cap.get(4)</code>. It gives me 640x480 by default. But I want to modify it to 320x240. Just use <code>ret = cap.set(3,320)</code> and <code>ret = cap.set(4,240)</code>.</p>
<p><strong>Note</strong>：If you are getting error, make sure camera is working fine using any other camera application (like Cheese in Linux).</p>
<h1 id="Playing-Video-from-file"><a href="#Playing-Video-from-file" class="headerlink" title="Playing Video from file"></a>Playing Video from file</h1><p>It is same as capturing from Camera, just change camera index with video file name. Also while displaying the frame, use appropriate time for cv2.waitKey(). If it is too less, video will be very fast and if it is too high, video will be slow (Well, that is how you can display videos in slow motion). 25 milliseconds will be OK in normal cases.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">cap = cv2.VideoCapture(&apos;video.mp4&apos;)</div><div class="line">while cap.isOpened():</div><div class="line">    ret, frame = cap.read()</div><div class="line">    cv2.imshow(&apos;playing&apos;, frame)</div><div class="line">    if cv2.waitKey(25) == 27:</div><div class="line">        break</div><div class="line">cap.release()</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p><strong>Note</strong>：Make sure proper versions of ffmpeg or gstreamer is installed. Sometimes, it is a headache to work with Video Capture mostly due to wrong installation of ffmpeg/gstreamer.</p>
<p><strong>Note</strong>：On Mac, you may get trouble while reading frame from a video file or writing frame to file, With no exception occurred but no data read out or write in. I have installed ffmpeg by homebrew, however not work for me. The OpenCV version on my Mac is 2.4.13. I have no idea about it. However, I tried it on Linux and it works without ffmpeg. The OpenCV version on Linux is 2.4.8. If you get the same trouble, maybe you can try uninstall OpenCV and install OpenCV3.x or OpenCV 2.4.8, it may works.</p>
<h1 id="Saving-a-Video"><a href="#Saving-a-Video" class="headerlink" title="Saving a Video"></a>Saving a Video</h1><p>Create a <code>VideoWriter</code> object and specify the output filename. Then specify the FourCC code. Then number of frames per second (fps) and frame size should be passed. And last one is isColor flag. If it is True, encoder expect color frame, otherwise it works with grayscale frame.</p>
<p>FourCC is a 4-byte code used to specify the video codec. The list of available codes can be found in <a href="http://www.fourcc.org/codecs.php" target="_blank" rel="external">fourcc.org</a>. It is platform dependent. </p>
<p>FourCC code is passed as below：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># for OpenCV 2.4.x version</div><div class="line">cv2.cv.CV_FOURCC(&apos;M&apos;,&apos;J&apos;,&apos;P&apos;,&apos;G&apos;)</div><div class="line">cv2.cv.CV_FOURCC(*&apos;M‌​JPG&apos;)</div><div class="line"># for OpenCV 3.0 version</div><div class="line">cv2.VideoWriter_fourcc(&apos;M&apos;,&apos;J&apos;,&apos;P&apos;,&apos;G&apos;)</div><div class="line">cv2.VideoWriter_fourcc(*&apos;MJPG&apos;)</div></pre></td></tr></table></figure>
<p>Below code capture from video file and saves part of it.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import sys</div><div class="line"></div><div class="line">cap = cv2.VideoCapture(&apos;video.avi&apos;)</div><div class="line">fourcc = cv2.cv.CV_FOURCC(*&apos;XVID&apos;)</div><div class="line">fps = 25</div><div class="line">ret, frame = cap.read()</div><div class="line">height, width = frame.shape[:2]</div><div class="line">out = cv2.VideoWriter(&apos;output.avi&apos;, fourcc, fps, (width, height))</div><div class="line"></div><div class="line">startTime = 60 # start at 60s</div><div class="line">endTime = 70 # end at 70s</div><div class="line"></div><div class="line">totalTime = cap.get(cv2.cv.CV_CAP_PROP_FRAME_COUNT) / fps</div><div class="line">if startTime &gt;= totalTime or endTime &gt; totalTime or startTime &gt; endTime:</div><div class="line">    print &apos;Invalid time settings&apos;</div><div class="line">    sys.exit(0)</div><div class="line"></div><div class="line">startFrame = startTime * fps</div><div class="line">stopFrame = endTime * fps</div><div class="line">cap.set(cv2.cv.CV_CAP_PROP_POS_FRAMES, startFrame) # read from startFrame</div><div class="line">duration = stopFrame - startFrame</div><div class="line"></div><div class="line">while duration and cap.isOpened():</div><div class="line">    ret, frame = cap.read()</div><div class="line">    cv2.imshow(&apos;preview&apos;, frame)</div><div class="line">    out.write(frame)</div><div class="line">    if cv2.waitKey(1000/fps) == 27:</div><div class="line">        break</div><div class="line">    duration -= 1</div><div class="line"></div><div class="line">cap.release()</div><div class="line">out.release()</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[BadApple视频转字符动画]]></title>
      <url>http://lizonghang.github.io/2016/08/06/BadApple%E8%A7%86%E9%A2%91%E8%BD%AC%E5%AD%97%E7%AC%A6%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&emsp;&emsp;实现 badapple.mp4 视频转字符动画，在终端显示字符动画。原理比较简单，使用终端命令 <code>ffmpeg</code> 从视频中抽取帧保存为图片，使用函数 <code>image2txt()</code> 将图片转化为字符画，最后使用终端命令 <code>cat</code> 输出字符动画。<br>&emsp;&emsp;源代码、帧图片、txt文本集可以从<a href="https://github.com/Lizonghang/Python-BadApple" target="_blank" rel="external">Github</a>中获取，badapple.mp4 可以从<a href="http://yun.baidu.com/s/1cLvjHG" target="_blank" rel="external">百度云</a>获取。通常视频是以 1 秒 24 帧图片组成的，为了节省时间与容量，采样的帧图片为 1 秒 10 帧，最终字符动画播放流畅，对质量无明显影响。若依旧要采用 1 秒 24 帧，可以修改 getImage.py 中的参数，修改方法见下文。<br>&emsp;&emsp;需要确保已经安装有第三方库 <code>PIL</code> 与 <code>numpy</code>，以及 <code>ffmpeg</code> 插件(可通过 Homebrew 安装)。</p>
<h1 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h1><p>本项目完整的包内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">badapple</div><div class="line">├── README.md</div><div class="line">├── getImage.py</div><div class="line">├── image2txt.py</div><div class="line">├── play.py</div><div class="line">├── images</div><div class="line">│   └── *.png</div><div class="line">└── txt</div><div class="line">    └── *.txt</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;getImage.py 用于从视频中提取帧图片，提取的帧图片存放于 images/ 文件夹，有 2190 张帧图片，若文件夹中已存在帧图片可不运行该程序。若要调整每帧图片数可调整变量 <code>crop_time</code> 累加的数值，清空已存在的图片集，修改视频路径(<code>videoPath</code>)、帧图片目录路径(<code>imagePath</code>)，再运行 getImage.py。由于调用的 <code>ffmpeg</code> 命令会输出很多信息，若要屏蔽这些信息可以修改 <code>os.system()</code> 中的命令，更换标准输出到文件。只需确保有对应图片生成即可。<br>&emsp;&emsp;image2txt.py 用于将图片转化为一定尺寸的字符画，从 images/ 文件夹中提取图片并转化为 txt 文本存放于 txt/ 文件夹。默认要求的终端尺寸为 300x75 ，若屏幕不能支持该大小，可以将参数 <code>charWidth</code> 修改为自定义的每行显示字符数，调整后若运行 play.py 要求终端大小为 (charWidth)x(charWidth/4) 。<br>&emsp;&emsp;play.py 用于获取 txt 文本集与依次显示 txt 文本集，以达到在终端播放字符动画的效果。运行之前请修改视频目录(<code>videoPath</code>)、txt文件夹目录(<code>txt_dir_path</code>)、images文件夹目录(<code>img_dir_path</code>)。若选择默认的终端大小 300x75 运行该程序，请先注释掉 <code>getTxt(img_dir_path, txt_dir_path)</code>，然后运行 play.py。若选择自定义的终端大小运行该程序，需要自行调整终端大小为 (charWidth)x(charWidth/4)，不注释 <code>getTxt(img_dir_path, txt_dir_path)</code>，然后运行 play.py，这需要稍等 10~60 秒。随后就能在终端显示字符动画。</p>
<p><strong>注意</strong>：自定义的 <code>charWidth</code> 过小则会降低播放质量，过大则会出现终端闪烁现象。需要根据实际情况调整 <code>charWidth</code>。<br><strong>注意</strong>：若修改了每帧播放的图片数目，则需要修改 play.py 中的 <code>time.sleep()</code> 数值，这是一个经验数值，用于和视频播放速度同步，修改该数值可加速或减缓字符动画播放速率。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="getImage-py"><a href="#getImage-py" class="headerlink" title="getImage.py"></a>getImage.py</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line"></div><div class="line">def getImage(videoPath, imagePath):</div><div class="line">    img_count = 1</div><div class="line">    crop_time = 0.0</div><div class="line">    while crop_time &lt;= 219.0:</div><div class="line">        os.system(&apos;ffmpeg -i %s -f image2 -ss %s -vframes 1 %s.png&apos; % (videoPath, str(crop_time), imagePath + str(img_count)))</div><div class="line">        img_count += 1</div><div class="line">        print &apos;Geting Image &apos; + str(img_count) + &apos;.png&apos; + &apos; from time &apos; + str(crop_time)</div><div class="line">        crop_time += 0.1</div><div class="line">    print &apos;Image Collected&apos;</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    videoPath = &apos;/Users/mac/Desktop/badapple.avi&apos;</div><div class="line">    imagePath = &apos;/Users/mac/Desktop/badapple/images/&apos;</div><div class="line">    getImage(videoPath, imagePath)</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;该模块用于从视频文件中抽取帧图片，<code>crop_time</code> 为抽取帧的时间，单位为秒，默认从 0 秒开始抽取，直到截取时间到达视频结束时间(219秒)。抽取帧图片使用了终端命令 <code>ffmpeg</code> 。输入文件为 badapple.mp4，输出格式为 <code>image2</code> 图片格式，截取时间为 0.0 秒，帧数为 1 ，输出图片为 1.png ： <code>ffmpeg -i badapple.mp4 -f image2 -ss 0.0 -vframes 1 1.png</code>。<br>&emsp;&emsp;<code>crop_time += 0.1</code> 中的累加数值表示 1 秒获取 1/0.1 张帧图片，调整该值将改变每秒获取的帧数目。<br>&emsp;&emsp;图片存储从 1.png 开始依次累增，直到 2190.png。<br>&emsp;&emsp;<code>videoPath</code> 为视频文件路径， <code>imagePath</code> 为图片文件夹路径。该模块可直接运行，运行之前先确认路径正确。如果已经有图片集，不需要运行该模块。</p>
<h2 id="image2txt-py"><a href="#image2txt-py" class="headerlink" title="image2txt.py"></a>image2txt.py</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line">import numpy</div><div class="line"></div><div class="line">def image2txt(inputFile, outputFile):</div><div class="line">    im = Image.open(inputFile).convert(&apos;L&apos;)</div><div class="line">    charWidth = 300</div><div class="line">    im = im.resize((charWidth, charWidth / 4))</div><div class="line">    target_width, target_height = im.size</div><div class="line">    data = numpy.array(im)[:target_height, :target_width]</div><div class="line">    f = open(outputFile, &apos;w&apos;)</div><div class="line">    for row in data:</div><div class="line">        for pixel in row:</div><div class="line">            if pixel &gt; 127:</div><div class="line">                f.write(&apos;#&apos;)</div><div class="line">            else:</div><div class="line">                f.write(&apos; &apos;)</div><div class="line">        f.write(&apos;\n&apos;)</div><div class="line">    f.close()</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;该模块用于将图片转化为字符画，转化前先将图片转化为灰度图，并将图片“变扁”以适应输出字符画与原画的比例，经验数据高度应为宽度的 1/4 。随后将大于阈值的像素写入’#’，小于阈值的像素写入’ ‘，默认阈值为 127。输出时，’#’ 表示白色，’ ‘ 表示黑色。写入的 txt 文件名需要与对应图片文件名对应，如 ‘1.png’ 对应 ‘1.txt’。转化后的 txt 文件存放于 txt/ 文件夹中。<br>&emsp;&emsp;<code>charWidth</code> 表示终端每行输出的字符数，数值需要根据实际需求调整，默认适应的终端大小为 300x75。</p>
<h2 id="play-py"><a href="#play-py" class="headerlink" title="play.py"></a>play.py</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import sys, os</div><div class="line">import image2txt</div><div class="line">import time</div><div class="line"></div><div class="line">def getTxt(imagePath, txtPath):</div><div class="line">    img_count = 1</div><div class="line">    while img_count &lt;= len(os.listdir(imagePath)):</div><div class="line">        imageFile = imagePath + str(img_count) + &apos;.png&apos;</div><div class="line">        txtFile = txtPath + str(img_count) + &apos;.txt&apos;</div><div class="line">        image2txt.image2txt(imageFile, txtFile)</div><div class="line">        print &apos;txt &apos; + str(img_count) + &apos; collected.&apos;</div><div class="line">        img_count += 1</div><div class="line"></div><div class="line">def play(txtPath):</div><div class="line">    txt_count = 1</div><div class="line">    while txt_count &lt;= len(os.listdir(txtPath)):</div><div class="line">        os.system(&apos;cat &apos; + txtPath + str(txt_count) + &apos;.txt&apos;)</div><div class="line">        time.sleep(1.0/11.25)</div><div class="line">        txt_count += 1</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    txt_dir_path = &apos;/Users/mac/Desktop/badapple/txt/&apos;</div><div class="line">    img_dir_path = &apos;/Users/mac/Desktop/badapple/images/&apos;</div><div class="line">    getTxt(img_dir_path, txt_dir_path)</div><div class="line">    play(txt_dir_path)</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;该模块是主要模块，用于在终端播放字符动画。播放前先按照 <code>charWidth</code> 的数值将帧图片集转换为字符集(若使用默认的 300x75 则忽略该步骤，注释掉函数 <code>getTxt(…)</code> 即可；若使用自定义比例，需要 10~60 秒等待时间)。然后使用终端命令 <code>cat</code> 依次输出各个 txt 文本中的字符画，输出的时间间隔是经验数值，可根据实际播放速度调整，加速或减缓播放速率以和原视频同步。<br>&emsp;&emsp;运行该模块前需要确保 txt/ 文件夹路径与 images/ 文件夹路径正确。</p>
<h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>&emsp;&emsp;左边是终端窗口，右边是 Quicktime Player，显示屏是电视显示屏。效果展示在<a href="https://pan.baidu.com/s/1geQMXvP" target="_blank" rel="external">百度云</a></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[自动化测试模型]]></title>
      <url>http://lizonghang.github.io/2016/08/04/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;一个自动化测试框架就是一个集成体系，在这一体系中包含测试功能的函数库、测试数据源、测试对象识别标准、以及多种可重用的模块。自动化测试框架在发展的过程中经历了几个阶段：模块驱动测试、数据驱动测试、对象驱动测试。</p>
<h1 id="自动化测试模型"><a href="#自动化测试模型" class="headerlink" title="自动化测试模型"></a>自动化测试模型</h1><p>&emsp;&emsp;自动化测试模型是自动化测试架构的基础，自动化测试的发展也经历了不同的阶段，不断有新的模型（概念）被提出，了解和使用这些自动化模型有利于构建一个灵活可维护的自动化架构。</p>
<h2 id="线性测试"><a href="#线性测试" class="headerlink" title="线性测试"></a>线性测试</h2><p>&emsp;&emsp;通过录制或编写脚本，一个脚本完成一个场景（一组完整功能操作），通过对脚本的回放来进行自动化测试。这是早期进行自动化测试的一种形式。例如在<a href="/2016/08/03/Selenium模拟操作实例/">模拟登陆实例</a>中的脚本就是线性测试形式。它的优势是每个脚本都是独立的，任何一个脚本文件可以单独运行。缺点是用例的开发与维护成本很高：</p>
<ul>
<li>一个用例对应一个脚本。如果登陆发送变化，例如用户名的属性发生改变，就不得不对每个脚本进行修改。测试用例形成规模，大量的工作被用于脚本的维护，从而失去自动化的意义。</li>
<li>这种模式下数据和脚本是混合在一起的，如果数据发生改变就需要修改脚本。这种模式下，脚本没有可重复使用的概念。</li>
</ul>
<h2 id="模块化与类库"><a href="#模块化与类库" class="headerlink" title="模块化与类库"></a>模块化与类库</h2><p>&emsp;&emsp;在脚本中有很多内容是重复的，于是可以将重复的部分写成公共模块，在需要的时候进行调用，这样就提高了编写脚本的效率。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># login.py</div><div class="line">def login():</div><div class="line">    driver.find_element_by_id(&quot;username&quot;).send_keys(&quot;username&quot;)</div><div class="line">    driver.find_element_by_id(&quot;password&quot;).send_keys(&quot;password&quot;)</div><div class="line">    driver.find_element_by_id(&quot;btnLogin&quot;).click()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># quit.py</div><div class="line">def quit():</div><div class="line">    driver.find_element_by_id(&quot;btnQuit&quot;).click()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">import login, quit</div><div class="line">driver = webdriver.Chrome()</div><div class="line">driver.get(&apos;http://www.ooxx.com&apos;)</div><div class="line">login.login()</div><div class="line">quit.quit()</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过上述不完整样例发现，可以将脚本中相同的部分代码独立出来形成模块或库。这样做有两方面优点：</p>
<ul>
<li>提高了开发效率，不用重复编写相同的脚本。之后需要时调用已写好的模块即可。</li>
<li>方便代码的维护。如果某个模块发生变化，只需要修改对应模块的代码即可。</li>
</ul>
<h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h2><p>&emsp;&emsp;数据驱动是自动化的进步，数据的改变驱动自动化的执行，从而引起测试结果的改变。简单的说，通过输入数据的不同引起输出结果的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">import time</div><div class="line">values = [&apos;selenium&apos;, &apos;webdriver&apos;]</div><div class="line">for search in values:</div><div class="line">    driver = webdriver.Chrome()</div><div class="line">    driver.get(http://www.baidu.com)</div><div class="line">    driver.find_element_by_id(&apos;kw&apos;).send_keys(search, Keys.RETURN)</div><div class="line">    time.sleep(3)</div><div class="line">    driver.close()</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取的数据源可能是数组、字典、函数、CSV或TXT文件，上面的例子实现了数据与脚本的分离，实现了参数化。同样的脚本执行不同的数据得到不同的结果，从而增强了脚本的复用性。</p>
<h2 id="关键字驱动"><a href="#关键字驱动" class="headerlink" title="关键字驱动"></a>关键字驱动</h2><p>&emsp;&emsp;关键词驱动就是通过关键字的改变引起测试结果改变。QTP、robot framework 等都是以关键字驱动为主的自动化工具，因为这类工具的易用性，‘填表’式的关键字驱动帮助封装了很多底层的东西，测试人员只需要考虑三个问题：做什么、对谁做、怎么做。可以将 Selenium IDE 看做一种关键字驱动的自动化工具，Selenium IDE 脚本分：命令（command）、对象（target）、值（value），通过这样的格式去描述不同的对象，从而引起结果的改变。</p>
<h1 id="登陆模块化"><a href="#登陆模块化" class="headerlink" title="登陆模块化"></a>登陆模块化</h1><p>&emsp;&emsp;在目前的脚本中有很多代码是可以模块化的，比如登陆模块。几乎每一个用例的执行都需要登陆脚本，那么久可以将登陆脚本独立到单独的文件调用。以<a href="/2016/08/03/Selenium模拟操作实例/#模拟百度登入登出">模拟百度登入登出</a>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># login.py</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.common.exceptions import NoSuchElementException</div><div class="line"></div><div class="line">def login(self):</div><div class="line">    driver = self.driver</div><div class="line">    driver.find_element_by_id(&apos;u1&apos;).find_element_by_name(&apos;tj_login&apos;).click()</div><div class="line">    try:</div><div class="line">        usernameInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__userName&apos;)</div><div class="line">        passwordInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__password&apos;)</div><div class="line">        usernameInput.clear()</div><div class="line">        passwordInput.clear()</div><div class="line">        usernameInput.send_keys(self.username)</div><div class="line">        passwordInput.send_keys(self.password)</div><div class="line">        driver.find_element_by_id(&apos;TANGRAM__PSP_8__submit&apos;).submit()</div><div class="line">    except NoSuchElementException as msg:</div><div class="line">        return False</div><div class="line">    return True</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"># baidu.py</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.action_chains import ActionChains</div><div class="line">from selenium.webdriver.common.by import By</div><div class="line">from selenium.webdriver.support.ui import WebDriverWait</div><div class="line">from selenium.webdriver.support import expected_conditions as EC</div><div class="line">import unittest, time</div><div class="line">import login</div><div class="line"></div><div class="line">class Login(unittest.TestCase):</div><div class="line"></div><div class="line">    def setUp(self):</div><div class="line">        self.driver = webdriver.Chrome()</div><div class="line">        self.driver.implicitly_wait(5)</div><div class="line">        self.username = &apos;username&apos;</div><div class="line">        self.password = &apos;password&apos;</div><div class="line"></div><div class="line">    def test_login(self):</div><div class="line">        driver = self.driver</div><div class="line">        driver.get(&apos;https://www.baidu.com&apos;)</div><div class="line">        if login.login(self):</div><div class="line">            ActionChains(driver).move_to_element(driver.find_element_by_id(&apos;s_username_top&apos;)).perform()</div><div class="line">            ActionChains(driver).move_to_element(driver.find_element_by_class_name(&apos;quit&apos;)).click().perform()</div><div class="line">            ActionChains(driver).move_to_element(driver.find_elements_by_xpath(&apos;//div[@class=&quot;button-wrap&quot;]/a&apos;)[2]).click().perform()</div><div class="line">            time.sleep(3)</div><div class="line"></div><div class="line">    def tearDown(self):</div><div class="line">        self.driver.quit()</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    unittest.main()</div></pre></td></tr></table></figure>
<h1 id="数据驱动-1"><a href="#数据驱动-1" class="headerlink" title="数据驱动"></a>数据驱动</h1><h2 id="数据参数化"><a href="#数据参数化" class="headerlink" title="数据参数化"></a>数据参数化</h2><p>&emsp;&emsp;在上面关于数据驱动的介绍中已经示例了使用数组进行参数化设置，这里将通过读取 txt 文件中的数据来实现参数化。</p>
<p>创建一个 data.txt 文件，文件内有三行数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">selenium</div><div class="line">webdriver</div><div class="line">bokeyuan</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过 for 循环，search 可以每次获取到文件中的一行数据，在定位到百度搜索框后将数据传入 send_keys()。这样通过循环调用，直到文件中的所有内容被读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">import time</div><div class="line"></div><div class="line">source = open(&apos;data.txt&apos;)</div><div class="line">values = source.readlines()</div><div class="line">source.close()</div><div class="line">for search in values:</div><div class="line">    driver = webdriver.Chrome()</div><div class="line">    driver.get(&apos;http://www.baidu.com&apos;)</div><div class="line">    driver.find_element_by_id(&apos;kw&apos;).send_keys(search, Keys.RETURN)</div><div class="line">    time.sleep(2)</div><div class="line">    driver.close()</div></pre></td></tr></table></figure>
<h2 id="登录参数化-读取txt文件"><a href="#登录参数化-读取txt文件" class="headerlink" title="登录参数化(读取txt文件)"></a>登录参数化(读取txt文件)</h2><p>&emsp;&emsp;按照上述思路，对自动化脚本中用户名、密码进行参数化。创建 userdata.txt 文件，存放用户名和密码，假设存放格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">username1 password1</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;在之前编写的 login.py 文件基础上作如下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">from selenium.common.exceptions import NoSuchElementException</div><div class="line"></div><div class="line">source = open(&apos;userdata.txt&apos;)</div><div class="line">username, password = source.readlines()[0].split()</div><div class="line">source.close()</div><div class="line"></div><div class="line">def login(self):</div><div class="line">    driver = self.driver</div><div class="line">    driver.find_element_by_id(&apos;u1&apos;).find_element_by_name(&apos;tj_login&apos;).click()</div><div class="line">    try:</div><div class="line">        usernameInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__userName&apos;)</div><div class="line">        passwordInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__password&apos;)</div><div class="line">        usernameInput.clear()</div><div class="line">        passwordInput.clear()</div><div class="line">        usernameInput.send_keys(username)</div><div class="line">        passwordInput.send_keys(password)</div><div class="line">        driver.find_element_by_id(&apos;TANGRAM__PSP_8__submit&apos;).submit()</div><div class="line">    except NoSuchElementException as msg:</div><div class="line">        return False</div><div class="line">    return True</div></pre></td></tr></table></figure>
<h2 id="登录参数化-函数"><a href="#登录参数化-函数" class="headerlink" title="登录参数化(函数)"></a>登录参数化(函数)</h2><p>&emsp;&emsp;函数可以预先给参数化赋值，借助这个特性，可以通过调用函数对用户名和密码进行参数化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># userinfo.py</div><div class="line">def Tester_Li(username=&apos;testusername&apos;, password=&apos;testpassword&apos;):</div><div class="line">    return username, password</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过给函数参数赋予默认值并返回的方法可以在函数中存储一些信息。再次修改 login.py 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># login.py</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.common.exceptions import NoSuchElementException</div><div class="line">import userinfo</div><div class="line"></div><div class="line">username, password = userinfo.Tester_Li()</div><div class="line"></div><div class="line">def login(self):</div><div class="line">    driver = self.driver</div><div class="line">    driver.find_element_by_id(&apos;u1&apos;).find_element_by_name(&apos;tj_login&apos;).click()</div><div class="line">    try:</div><div class="line">        usernameInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__userName&apos;)</div><div class="line">        passwordInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__password&apos;)</div><div class="line">        usernameInput.clear()</div><div class="line">        passwordInput.clear()</div><div class="line">        usernameInput.send_keys(username)</div><div class="line">        passwordInput.send_keys(password)</div><div class="line">        driver.find_element_by_id(&apos;TANGRAM__PSP_8__submit&apos;).submit()</div><div class="line">    except NoSuchElementException as msg:</div><div class="line">        return False</div><div class="line">    return True</div></pre></td></tr></table></figure>
<h2 id="登录参数化-读取字典"><a href="#登录参数化-读取字典" class="headerlink" title="登录参数化(读取字典)"></a>登录参数化(读取字典)</h2><p>&emsp;&emsp;使用一个函数来存储字典，假设文件名为 userinfo.py：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># userinfo.py</div><div class="line">def getUserInfo():</div><div class="line">    data = &#123;</div><div class="line">    &apos;Tester_Li&apos;: &#123;&apos;username&apos;: &apos;Li_username&apos;, &apos;password&apos;: &apos;Li_password&apos;&#125;,</div><div class="line">    &apos;Tester_Wang&apos;: &#123;&apos;username&apos;: &apos;Wang_username&apos;, &apos;password&apos;: &apos;Wang_password&apos;&#125;,</div><div class="line">    &#125;</div><div class="line">    return data</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># login.py</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.common.exceptions import NoSuchElementException</div><div class="line">import userinfo</div><div class="line"></div><div class="line">info_dict = userinfo.getUserInfo()[&apos;Tester_Li&apos;]</div><div class="line">username = info_dict[&apos;username&apos;]</div><div class="line">password = info_dict[&apos;password&apos;]</div><div class="line"></div><div class="line">def login(self):</div><div class="line">    driver = self.driver</div><div class="line">    driver.find_element_by_id(&apos;u1&apos;).find_element_by_name(&apos;tj_login&apos;).click()</div><div class="line">    try:</div><div class="line">        usernameInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__userName&apos;)</div><div class="line">        passwordInput = driver.find_element_by_id(&apos;TANGRAM__PSP_8__password&apos;)</div><div class="line">        usernameInput.clear()</div><div class="line">        passwordInput.clear()</div><div class="line">        usernameInput.send_keys(username)</div><div class="line">        passwordInput.send_keys(password)</div><div class="line">        driver.find_element_by_id(&apos;TANGRAM__PSP_8__submit&apos;).submit()</div><div class="line">    except NoSuchElementException as msg:</div><div class="line">        return False</div><div class="line">    return True</div></pre></td></tr></table></figure>
<h2 id="表单参数化-CSV"><a href="#表单参数化-CSV" class="headerlink" title="表单参数化(CSV)"></a>表单参数化(CSV)</h2><p>&emsp;&emsp;假设自动化脚本中要参数化一张表单，表单需要填写用户名、邮箱、年龄、性别等信息，就适合用读取 CSV 文件的方法来解决。创建 userinfo.csv 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">laowang,123456@126.com,23,男,</div><div class="line">xiaoli,123123@qq.com, 18, 女,</div><div class="line">xiaomin,456123@gmail.com, 29,女,</div></pre></td></tr></table></figure>
<p>使用 csv 库来读取 CSV 文件中的数据并格式化输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># encoding: utf-8</div><div class="line">import csv</div><div class="line">for user in csv.reader(file(&apos;userinfo.csv&apos;, &apos;rb&apos;)):</div><div class="line">    print &apos;Name: %s, Mail: %s, Age: %s, Sex: %s&apos; % tuple(user[0:4])</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Name: laowang, Mail: 123456@126.com, Age: 23, Sex: 男</div><div class="line">Name: xiaoli, Mail: 123123@qq.com, Age:  18, Sex:  女</div><div class="line">Name: xiaomin, Mail: 456123@gmail.com, Age:  29, Sex: 女</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;csv.reader() 用于读取 CSV 文件，每一次循环的 user 变量是一个列表，可以通过 user[index] 来读取其中的数据，上面将 user 中的数据抽取出来并转换为元组来简化代码。通过 csv 读取文件比较灵活，可以循环读取每一条数据，又不局限每次读取数据的个数。</p>
]]></content>
      
        <categories>
            
            <category> 软件测试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Selenium模拟操作实例]]></title>
      <url>http://lizonghang.github.io/2016/08/03/Selenium%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<h1 id="模拟百度登入登出"><a href="#模拟百度登入登出" class="headerlink" title="模拟百度登入登出"></a>模拟百度登入登出</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">from selenium.webdriver.common.by import By</div><div class="line">from selenium.webdriver.common.action_chains import ActionChains</div><div class="line">from selenium.webdriver.common.alert import Alert</div><div class="line">from selenium.webdriver.support.ui import WebDriverWait</div><div class="line">from selenium.webdriver.support import expected_conditions as EC</div><div class="line">import time</div><div class="line"></div><div class="line">driver = webdriver.Chrome()</div><div class="line">driver.get(&apos;https://www.baidu.com&apos;)</div><div class="line">try:</div><div class="line">    driver.find_element_by_id(&apos;u1&apos;).find_element_by_name(&apos;tj_login&apos;).click()</div><div class="line">    WebDriverWait(driver, 3).until(EC.presence_of_element_located((By.ID, &apos;TANGRAM__PSP_8__userName&apos;)))</div><div class="line">    driver.find_element_by_id(&apos;TANGRAM__PSP_8__userName&apos;).send_keys(&apos;username&apos;)</div><div class="line">    driver.find_element_by_id(&apos;TANGRAM__PSP_8__password&apos;).send_keys(&apos;password&apos;)</div><div class="line">    driver.find_element_by_id(&apos;TANGRAM__PSP_8__submit&apos;).submit()</div><div class="line">    WebDriverWait(driver, 3).until(EC.presence_of_element_located((By.ID, &apos;s_username_top&apos;)))</div><div class="line">    ActionChains(driver).move_to_element(driver.find_element_by_id(&apos;s_username_top&apos;)).perform()</div><div class="line">    ActionChains(driver).move_to_element(driver.find_element_by_class_name(&apos;quit&apos;)).click().perform()</div><div class="line">    WebDriverWait(driver, 3).until(EC.presence_of_element_located((By.CLASS_NAME, &apos;button-wrap&apos;)))</div><div class="line">    ActionChains(driver).move_to_element(driver.find_elements_by_xpath(&apos;//div[@class=&quot;button-wrap&quot;]/a&apos;)[2]).click().perform()</div><div class="line">    time.sleep(3)</div><div class="line">finally:</div><div class="line">    driver.quit()</div></pre></td></tr></table></figure>
<h1 id="模拟问卷星发布问卷"><a href="#模拟问卷星发布问卷" class="headerlink" title="模拟问卷星发布问卷"></a>模拟问卷星发布问卷</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"># encoding: utf-8</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">from selenium.webdriver.common.by import By</div><div class="line">from selenium.webdriver.support.ui import WebDriverWait</div><div class="line">from selenium.webdriver.support import expected_conditions as EC</div><div class="line">from selenium.common.exceptions import NoSuchElementException</div><div class="line">from selenium.webdriver.support.select import Select</div><div class="line">from selenium.webdriver.common.alert import Alert</div><div class="line">import time, sys</div><div class="line"></div><div class="line"># settings</div><div class="line">username = &apos;username&apos;</div><div class="line">password = &apos;password&apos;</div><div class="line"></div><div class="line">driver = webdriver.Chrome()</div><div class="line">driver.implicitly_wait(5)</div><div class="line">driver.get(&apos;http://www.baidu.com&apos;)</div><div class="line">driver.find_element_by_id(&apos;kw&apos;).send_keys(u&apos;问卷星&apos;, Keys.RETURN)</div><div class="line">driver.find_element_by_xpath(&apos;//div[@id=&quot;1&quot;]/h3&apos;).click()</div><div class="line">driver.switch_to_window(driver.window_handles[1])</div><div class="line">driver.find_element_by_id(&apos;ctl00_liLogin&apos;).click()</div><div class="line">time.sleep(1)</div><div class="line">username = driver.find_element_by_id(&apos;ctl00_ContentPlaceHolder1_UserName&apos;)</div><div class="line">password = driver.find_element_by_id(&apos;ctl00_ContentPlaceHolder1_Password&apos;)</div><div class="line">username.clear()</div><div class="line">password.clear()</div><div class="line">username.send_keys(username)</div><div class="line">password.send_keys(password, Keys.RETURN)</div><div class="line"></div><div class="line"># 登陆时可能出现验证码</div><div class="line">try:</div><div class="line">    driver.find_element_by_xpath(&apos;//div[@id=&quot;ctl01_ContentPlaceHolder1_divInfo&quot;]/div/div/span/a&apos;).click()</div><div class="line">except NoSuchElementException:</div><div class="line">    print u&apos;出现验证码，程序退出&apos;</div><div class="line">    sys.exit(0)</div><div class="line"></div><div class="line">driver.find_element_by_xpath(&apos;//ul[@class=&quot;CR-Obox&quot;]/li/a&apos;).click()</div><div class="line">driver.find_elements_by_xpath(&apos;//div[@id=&quot;divSearchResult&quot;]/ul/li&apos;)[0].click()</div><div class="line">driver.find_element_by_class_name(&apos;MOM-bottom&apos;).click()</div><div class="line"></div><div class="line"># 新建问卷时可能出现验证码</div><div class="line">try:</div><div class="line">    driver.find_element_by_id(&apos;hrefFiQ&apos;).click()</div><div class="line">except NoSuchElementException:</div><div class="line">    print u&apos;出现验证码，程序退出&apos;</div><div class="line">    sys.exit(0)</div><div class="line"></div><div class="line">select = Select(driver.find_element_by_xpath(&apos;//select[@id=&quot;ddlActivity&quot;]&apos;))</div><div class="line">print u&apos;新建的问卷名为: &apos;, select.first_selected_option.text</div><div class="line">driver.find_element_by_xpath(&apos;//ul[@class=&quot;BS-menu&quot;]/li&apos;).click()</div><div class="line">driver.find_elements_by_xpath(&apos;//tr&apos;)[0].find_element_by_class_name(&apos;delete&apos;).click()</div><div class="line">Alert(driver).accept()</div><div class="line">driver.find_elements_by_xpath(&apos;//ul[@class=&quot;BS-menu&quot;]/li&apos;)[-1].click()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 软件测试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Selenium自动化测试]]></title>
      <url>http://lizonghang.github.io/2016/07/31/Selenium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>参考Selenium官方文档 <a href="http://selenium-python.readthedocs.io/getting-started.html" target="_blank" rel="external">http://selenium-python.readthedocs.io/getting-started.html</a></p>
<h1 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h1><h2 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install selenium</div></pre></td></tr></table></figure>
<p>如果下载时抛出了如下错误，可不予理会：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OSError: [Errno 1] Operation not permitted: &apos;/System/Library/Frameworks/Python.framework/Versions/2.7/selenium&apos;</div></pre></td></tr></table></figure>
<p>进入 python 交互环境，尝试导入 selenium 模块即可</p>
<h2 id="chromedriver"><a href="#chromedriver" class="headerlink" title="chromedriver"></a>chromedriver</h2><p>如果要选择 Chrome 作为测试浏览器，需要先安装 chromedriver，否则在实例化时会抛出以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; brower = webdriver.chrome()</div><div class="line">...</div><div class="line">selenium.common.exceptions.WebDriverException: Message: &apos;chromedriver&apos; executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home</div></pre></td></tr></table></figure>
<p>Mac 用户可使用 Homebrew 直接下载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install chromedriver</div></pre></td></tr></table></figure>
<p>下载完成后可能会出现以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Error: parent directory is world writable but not sticky</div><div class="line">Please report this bug:</div><div class="line">    https://git.io/brew-troubleshooting</div><div class="line">/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/tmpdir.rb:92:in `mktmpdir&apos;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>解决方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo chmod +t /private/tmp/</div></pre></td></tr></table></figure>
<p>随后再尝试下载 chromedriver，进入 python 交互环境尝试实例化即可。</p>
<h1 id="简单用例"><a href="#简单用例" class="headerlink" title="简单用例"></a>简单用例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">import time</div><div class="line"># The instance of Chrome WebDriver is created.</div><div class="line">driver = webdriver.Chrome()</div><div class="line"># The driver.get() method will navigate to a page given by the URL. WebDriver will wait until the page has fully loaded (that is, the “onload” event has fired) before returning control to your test or script. It’s worth noting that if your page uses a lot of AJAX on load then WebDriver may not know when it has completely loaded.</div><div class="line">driver.get(&apos;http://www.python.org&apos;)</div><div class="line">print driver.title</div><div class="line"># WebDriver offers a number of ways to find elements using one of the find_element_by_* methods. For example, the input text element can be located by its name attribute using find_element_by_name method. Detailed explanation of finding elements is available in the Locating Elements chapter</div><div class="line">elem = driver.find_element_by_name(&apos;q&apos;)</div><div class="line"># Next we are sending keys, this is similar to entering keys using your keyboard. Special keys can be send using Keys class imported from selenium.webdriver.common.keys. To be safe, we’ll first clear any prepopulated text in the input field (e.g. “Search”) so it doesn’t affect our search results</div><div class="line">elem.clear()</div><div class="line">elem.send_keys(&apos;pycon&apos;)</div><div class="line">elem.send_keys(Keys.RETURN)</div><div class="line">print driver.page_source</div><div class="line">time.sleep(5)</div><div class="line"># Finally, the browser window is closed. You can also call quit method instead of close. The quit will exit entire browser whereas close` will close one tab, but if just one tab was open, by default most browser will exit entirely.</div><div class="line">driver.close()</div></pre></td></tr></table></figure>
<p>这段程序会打开浏览器，访问 <a href="http://www.python.org" target="_blank" rel="external">http://www.python.org</a> 并搜索 pycon，等待 5s 后关闭浏览器。</p>
<h1 id="用Selenium写测试单元"><a href="#用Selenium写测试单元" class="headerlink" title="用Selenium写测试单元"></a>用Selenium写测试单元</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">import unittest</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">import time</div><div class="line"></div><div class="line">class PythonOrgSearch(unittest.TestCase):</div><div class="line">    def setUp(self):</div><div class="line">        self.driver = webdriver.Chrome()</div><div class="line"></div><div class="line">    def test_search_in_python_org(self):</div><div class="line">        driver = self.driver</div><div class="line">        driver.get(&apos;http://www.python.org&apos;)</div><div class="line">        self.assertIn(&apos;Python&apos;, driver.title)</div><div class="line">        elem = driver.find_element_by_name(&apos;q&apos;)</div><div class="line">        elem.send_keys(&apos;pycon&apos;)</div><div class="line">        elem.send_keys(Keys.RETURN)</div><div class="line">        assert &apos;No results found.&apos; not in driver.page_source</div><div class="line">        time.sleep(5)</div><div class="line"></div><div class="line">    def tearDown(self):</div><div class="line">        self.driver.quit()</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    unittest.main()</div></pre></td></tr></table></figure>
<p>以上仅为关于 selenium 的一些简要功能介绍，详细用法参考后续文档</p>
]]></content>
      
        <categories>
            
            <category> 软件测试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[软件测试分类]]></title>
      <url>http://lizonghang.github.io/2016/07/31/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;关于软件测试领域名词很多，从不同的角度可以将软件测试分为不同的类，这里汇总常见软件测试的相关名词，对软件测试领域有个概况的了解。</p>
<h1 id="项目流程划分"><a href="#项目流程划分" class="headerlink" title="项目流程划分"></a>项目流程划分</h1><p><img src="/images/v-mode.png" alt=""></p>
<p>&emsp;&emsp;<strong>单元测试</strong>：单元测试(或模块测试)是对程序中的单个子程序或具有独立功能的代码段进行测试的过程。</p>
<p>&emsp;&emsp;<strong>集成测试</strong>：集成测试是单元测试的基础上，将通过单元模块组装成系统或子系统，再进行测试，重点是检查模块之间的接口是否正确。</p>
<p>&emsp;&emsp;<strong>系统测试</strong>：系统测试是针对整个产品系统进行的测试，验证系统是否满足了需求规格的定义，以及软件系统的正确性和性能等是否满足其规约所指定的要求。</p>
<p>&emsp;&emsp;<strong>验收测试</strong>：验收测试是部署软件之前的最后一个测试操作。验收测试的目的是确保软件准备就绪，向软件购买者展示该软件系统满足其用户的需求。</p>
<h1 id="黑盒、白盒、灰盒测试"><a href="#黑盒、白盒、灰盒测试" class="headerlink" title="黑盒、白盒、灰盒测试"></a>黑盒、白盒、灰盒测试</h1><p>&emsp;&emsp;<strong>黑盒测试</strong>：黑盒测试指的是把被测的软件看作黑盒子，不需要关心盒子里面的结构，只关心软件的输入和输出。它只检查程序呈现给用户的功能是否按照需求规格说明书的规定正常使用，程序是否能适当的接收输入数据并产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。</p>
<p>&emsp;&emsp;<strong>白盒测试</strong>：白盒测试指将盒子打开，研究内部源代码和程序执行结果。它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作。</p>
<p>&emsp;&emsp;<strong>灰盒测试</strong>：灰盒测试介于黑盒测试和灰盒测试之间，灰盒测试关注输出对输入的正确性，同时也关注内部表现，但这种关注不如白盒测试详细完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态。有时输出正确但内部出现错误，如果每次都用白盒测试来操作，效率会很低，因此需要采取灰盒测试的方法。</p>
<h1 id="功能测试与性能测试"><a href="#功能测试与性能测试" class="headerlink" title="功能测试与性能测试"></a>功能测试与性能测试</h1><p>&emsp;&emsp;<strong>功能测试</strong>：功能测试检查实际的功能是否符合用户的需求。测试的大部分工作也是围绕软件的功能进行，设计软件的目的也就是满足客户对功能的需求。如果偏离这个目的，任何测试工作都失去意义。功能测试又可以分为逻辑功能测试、界面测试、易用性测试、安装测试、兼容性测试等。</p>
<p>&emsp;&emsp;<strong>性能测试</strong>：性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。软件的性能包括很多方面，主要有时间性能和空间性能两种。<br>&emsp;&emsp;&emsp;&emsp;<strong>时间性能</strong>：主要是指软件的一个具体的响应时间。比如一次登录需要的时间，一次交易需要的时间等。抛开具体的测试环境来分析一次事务的响应时间没有意义。需要搭建一个具体且独立的测试环境。<br>&emsp;&emsp;&emsp;&emsp;<strong>空间性能</strong>：主要指软件运行时所消耗的系统资源，比如硬件资源、CPU、内存、网络带宽等。</p>
<h1 id="手工测试与自动化测试"><a href="#手工测试与自动化测试" class="headerlink" title="手工测试与自动化测试"></a>手工测试与自动化测试</h1><p>&emsp;&emsp;<strong>手工测试</strong>：手工测试是由人去执行测试用例，通过键盘鼠标等输入一些参数，查看返回结果是否符合预期结果。手工测试并非专业术语，手工测试通常是指在系统测试阶段所进行的功能测试，为了更明显的与自动化测试进行区分，这里使用了手工测试。</p>
<p>&emsp;&emsp;<strong>自动化测试</strong>：自动化测试时把以人为驱动的测试行为转化为机器执行的过程。通常在设计了测试用例并通过评审之后，由测试人员根据测试用例中描述的规程一步步执行测试，得到实际结果与期望结果比较。在此过程中，为了节省人力、时间或硬件资源，提高测试效率，便引入了自动化测试的概念。<br>&emsp;&emsp;自动化测试又可分为功能自动化测试与性能自动化测试。<br>&emsp;&emsp;&emsp;&emsp;<strong>功能自动化测试</strong>：一般所说的自动化测试指功能自动化测试，通过相关的测试技术，通过编码的方式用一段程序来测试一个软件的功能，这样就可以重复执行程序来进行重复的测试。如果一个软件一小部分发生改变，只需要修改一部分自动化测试代码就可以重复对整个软件进行功能测试，从而大大提高测试效率。<br>&emsp;&emsp;&emsp;&emsp;<strong>性能自动化测试</strong>：目前性能测试工作都是通过性能测试工具辅助完成的。通过工具可以模拟大量的用户向系统发送请求，用来验证系统的处理能力。</p>
<h1 id="冒烟、回归、随机测试"><a href="#冒烟、回归、随机测试" class="headerlink" title="冒烟、回归、随机测试"></a>冒烟、回归、随机测试</h1><p>&emsp;&emsp;<strong>冒烟测试</strong>：冒烟测试是指在对一个新版本进行系统大规模测试之前，先验证软件的基本功能是否实现，是否具备可测性。引入到软件测试中，就是指测试小组在正规测试一个新版本之前，先投入较少的人力和时间验证一个软件的主要功能，如果主要功能都没有实现，则打回开发组重新开发。这样做可以节省大量的时间成本和人力成本。</p>
<p>&emsp;&emsp;<strong>回归测试</strong>：回归测试是指修改了旧代码后，重新进行测试以确认修改后没有引入新的错误或导致其他代码产生错误。回归测试一般是在进行软件的第二轮测试开始的，验证第一轮中发现的问题是否得到修复。回归也是一个循环的过程，如果回归的问题通不过则需要开发人员修改后再次进行回归，直到通过为止。</p>
<p>&emsp;&emsp;<strong>随机测试</strong>：随机测试是指测试中所有输入数据都是随机生成的，其目的是模拟用户的真实操作，并发现一些边缘性的错误。随机测试可以发现一些隐蔽的错误，但是也有很多缺点，比如测试不系统，无法统计代码覆盖率和需求覆盖率，发现的问题难以重现。一般是放在测试的最后执行。随机测试更专业的升级版称为探索性测试。</p>
<h1 id="其他测试"><a href="#其他测试" class="headerlink" title="其他测试"></a>其他测试</h1><p>&emsp;&emsp;<strong>探索性测试</strong>：探索性测试可以说是一种测试思维技术。它没有很多实际的测试方法、技术和工具，但却是所有测试人员都应该掌握的测试思维方式。探索性强调测试人员的主观能动性，抛弃繁杂的测试计划和测试用例设计过程，强调在碰到问题时及时改变测试策略。</p>
<p>&emsp;&emsp;<strong>安全测试</strong>：安全测试是在 IT 软件产品生命周期中，特别是产品开发基本完成到发布阶段，对产品进行校验以验证产品符合安全需求定义和产品质量标准的过程。安全测试越来越受到企业的关注和重视，因为由于安全性问题造成的后果是不可估量的。尤其互联网产品最容易受到各种安全攻击。</p>
<h1 id="适合自动化测试的项目"><a href="#适合自动化测试的项目" class="headerlink" title="适合自动化测试的项目"></a>适合自动化测试的项目</h1><p>&emsp;&emsp;不是所有项目都适合实施自动化测试，否则可能会浪费大量的人力和时间却没有得到应有的收益。是否可以对项目开展自动化测试可以参考以下 10 个条件：</p>
<ol>
<li>测试任务明确，不会频繁变动</li>
<li>每日构建后的测试验证</li>
<li>比较频繁的回归测试</li>
<li>软件系统界面稳定，变动少</li>
<li>需要在多平台上运行相同的测试案例、组合遍历型的测试、大量的重复任务</li>
<li>软件维护周期长</li>
<li>项目进度压力不大</li>
<li>被测软件系统开发比较规范，能够保证系统的可测试性</li>
<li>具备大量的自动化测试平台</li>
<li>测试人员具备较强的编程能力</li>
</ol>
<p>&emsp;&emsp;并非以上条件都具备才能开展测试工作。在普遍经验中，只要满足下面三个条件就可以对项目开展自动化测试：</p>
<p>&emsp;&emsp;<strong>软件需求编程不频繁</strong><br>&emsp;&emsp;测试脚本的稳定性决定了自动化测试的维护成本。如果软件需求变动过于频繁，测试人员需要根据变动的需求来更新测试用例以及相关的测试脚本，而脚本的维护本身就是代码开发的过程，需要修改、调试，必要的时候还要修改自动化测试的框架，如果花费的成本不低于利用其节省的测试成本，那么自动化测试便是失败的。<br>&emsp;&emsp;项目中的某些模块相对稳定，而某些模块需求变动性很大。可以对相对稳定的模块进行自动化测试，而变动大的使用手工测试。</p>
<p>&emsp;&emsp;<strong>项目周期较长</strong><br>&emsp;&emsp;由于自动化测试需求的确定、自动化测试框架的设计、测试脚本的编写与调试均需要相当长的时间来完成，这样的过程本身就是一个测试软件的开发过程，需要较长的时间来完成。如果项目的周期比较短，没有足够的时间去支持这个过程，那么最好不适用自动化测试。</p>
<p>&emsp;&emsp;<strong>自动化测试脚本可重复使用</strong><br>&emsp;&emsp;自动化测试脚本的重复使用要从三个方面考虑。测试的项目之间是否有很大的差异性（如 C/S 系统和 B/S 系统的差异）；选择的测试工具是否适应这种差异；测试人员是否有能力开发适应这种差异的自动化测试框架。</p>
]]></content>
      
        <categories>
            
            <category> 软件测试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Python实现录音功能]]></title>
      <url>http://lizonghang.github.io/2016/07/30/Python%E5%AE%9E%E7%8E%B0%E5%BD%95%E9%9F%B3%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<h1 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h1><h2 id="portaudio"><a href="#portaudio" class="headerlink" title="portaudio"></a>portaudio</h2><p>安装 pyaudio 时若没有安装该模块将会报错，因此须提前安装好该模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install portaudio</div></pre></td></tr></table></figure>
<h2 id="pyaudio"><a href="#pyaudio" class="headerlink" title="pyaudio"></a>pyaudio</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install pyaudio</div></pre></td></tr></table></figure>
<h2 id="修改pip源"><a href="#修改pip源" class="headerlink" title="修改pip源"></a>修改pip源</h2><p>默认的源为 pypi.python.org，修改 pip 源可以加速模块的下载，可以大幅提高安装效率。</p>
<p>修改源之前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Collecting pyaudio</div><div class="line">  Downloading PyAudio-0.2.9.tar.gz (289kB)</div><div class="line">    14% |████▌                           | 40kB 9.8kB/s eta 0:00:26Exception:</div><div class="line">Traceback (most recent call last):</div><div class="line">...</div><div class="line">ReadTimeoutError: HTTPSConnectionPool(host=&apos;pypi.python.org&apos;, port=443): Read timed out.</div></pre></td></tr></table></figure>
<p>修改源之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Collecting pyaudio</div><div class="line">  Downloading http://mirrors.aliyun.com/pypi/packages/d0/dc/ffb9ce5e3f19bd289902915a9f68b7d199216065f8ea17d5b5e8e4ad86ee/PyAudio-0.2.9.tar.gz (289kB)</div><div class="line">    100% |████████████████████████████████| 296kB 940kB/s</div><div class="line">Installing collected packages: pyaudio</div><div class="line">  Running setup.py install for pyaudio ... done</div><div class="line">Successfully installed pyaudio-0.2.9</div></pre></td></tr></table></figure>
<p>修改步骤（Mac/Linux）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cd</div><div class="line">$ mkdir .pip</div><div class="line">$ cd .pip</div><div class="line">$ vim pip.conf</div></pre></td></tr></table></figure>
<p>输入如下内容保存后退出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[global]</div><div class="line">index-url = http://mirrors.aliyun.com/pypi/simple/</div><div class="line"></div><div class="line">[install]</div><div class="line">trusted-host=mirrors.aliyun.com</div></pre></td></tr></table></figure>
<p>重新执行 pip 下载命令即可。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">import wave, pyaudio</div><div class="line"></div><div class="line"># Settings</div><div class="line">CHUNK = 1024</div><div class="line">FORMAT = pyaudio.paInt16</div><div class="line">RATE = 8000</div><div class="line">CHANNELS = 1</div><div class="line">RECORD_SECONDS = 5</div><div class="line"></div><div class="line"># Record Function</div><div class="line">def recordWave():</div><div class="line">    pa = pyaudio.PyAudio()</div><div class="line">    stream = pa.open(format=FORMAT,</div><div class="line">                     channels=CHANNELS,</div><div class="line">                     rate=RATE,</div><div class="line">                     input=True,</div><div class="line">                     frames_per_buffer=CHUNK)</div><div class="line"></div><div class="line">    print &apos;Recording...&apos;</div><div class="line"></div><div class="line">    buffer = []</div><div class="line">    for i in range(0, int(RATE/CHUNK*RECORD_SECONDS)):</div><div class="line">        audio_data = stream.read(CHUNK)</div><div class="line">        buffer.append(audio_data)</div><div class="line"></div><div class="line">    print &apos;Record Done&apos;</div><div class="line"></div><div class="line">    stream.stop_stream()</div><div class="line">    stream.close()</div><div class="line">    pa.terminate()</div><div class="line"></div><div class="line">    wf = wave.open(&apos;record.wav&apos;, &apos;wb&apos;)</div><div class="line">    wf.setnchannels(CHANNELS)</div><div class="line">    wf.setsampwidth(pa.get_sample_size(FORMAT))</div><div class="line">    wf.setframerate(RATE)</div><div class="line">    wf.writeframes(b&apos;&apos;.join(buffer))</div><div class="line">    wf.close()</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    recordWave()</div></pre></td></tr></table></figure>
<h1 id="关于语音识别"><a href="#关于语音识别" class="headerlink" title="关于语音识别"></a>关于语音识别</h1><p>&emsp;&emsp;本来想实现语音控制电脑的，结果搜索了 Google、讯飞、百度、聚合数据（不要用，存在泄露信息嫌疑）等的语音识别接口，要么价格昂贵（3000~30000大洋，学生玩不起），要么得花上数日时间审核，微信只提供了个语义识别接口而不是语音识别接口。本来 Google 提供了免费且方便的接口 <code><a href="http://www.google.com/speech-api/v1/recognize?xjerr=1&amp;client=chromium" target="_blank" rel="external">http://www.google.com/speech-api/v1/recognize?xjerr=1&amp;client=chromium</a></code> ，这是第一代 API，没有要求 Key，结果后来就被玩坏了，这个接口就被废弃了。有趣的是后来又出现了一个很相似的 API，<code><a href="https://www.google.com/speech-api/v2/recognize?lang=en-us&amp;key=APIKEY" target="_blank" rel="external">https://www.google.com/speech-api/v2/recognize?lang=en-us&amp;key=APIKEY</a></code>，它需要申请 APIKEY，仅限 Chrome 内部私自使用了。<br>&emsp;&emsp;然而经过不断尝试，这个接口始终不能正常访问，原因本人还没有找到，超时报错：<code>requests.exceptions.ConnectionError: (‘Connection aborted.’, error(60, ‘Operation timed out’))</code> 。这也导致了本文从语音控制变成了简单的使用 pyaudio 录制语言。等有结果了再来完善本篇，若有读者找到了免费可行的 API 成功实现 Speech-To-Text 还请不吝赐教，QQ：870644199 或邮箱 870644199@qq.com。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Python生成验证码]]></title>
      <url>http://lizonghang.github.io/2016/07/30/Python%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;对于识别验证码的程序来说最难的部分是验证码字符的切割和特征码的建立。很多验证码加了很多干扰素和干扰线，不仅影响用户体验还达不到防止破解的很好的效果。若要使验证码难于被程序识别，需要注意：</p>
<ul>
<li>字符粘连，最后所有字符都有粘连的部分</li>
<li>不使用规则字符，验证码的各个部分使用不同比例的缩放或者旋转</li>
</ul>
<p>&emsp;&emsp;一般实现以上两点或这两点的变性，破解程序就很难识别。为了不影响用户体验，还需要注意形状相似字符的区分。本文以较简易的椒盐、干扰线和旋转来实现常用的一类验证码。</p>
<h1 id="字体素材"><a href="#字体素材" class="headerlink" title="字体素材"></a>字体素材</h1><p><img src="/images/font.png" alt=""></p>
<h1 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># Settings</div><div class="line">parser = argparse.ArgumentParser()</div><div class="line">parser.add_argument(&apos;input&apos;, help=&apos;font image source&apos;)</div><div class="line">parser.add_argument(&apos;fontwidth&apos;, help=&apos;width of the font&apos;)</div><div class="line">parser.add_argument(&apos;fontheight&apos;, help=&apos;height of the font&apos;)</div><div class="line">parser.add_argument(&apos;-o&apos;, help=&apos;target image path&apos;, default=&apos;./authcode.png&apos;)</div><div class="line">parser.add_argument(&apos;-l&apos;, help=&apos;authcode length&apos;, default=4)</div><div class="line">parser.add_argument(&apos;-s&apos;, help=&apos;salt counts&apos;, default=200)</div><div class="line">args = parser.parse_args()</div><div class="line">fontImgPath = args.input</div><div class="line">fontWidth = int(args.fontwidth)</div><div class="line">fontHeight = int(args.fontheight)</div><div class="line">targetImgPath = args.o</div><div class="line">codeLength = int(args.l)</div><div class="line">saltNum = int(args.s)</div><div class="line">base = (&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,</div><div class="line">      &apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;,</div><div class="line">      &apos;K&apos;,&apos;L&apos;,&apos;M&apos;,&apos;N&apos;,&apos;O&apos;,&apos;P&apos;,&apos;Q&apos;,&apos;R&apos;,&apos;S&apos;,&apos;T&apos;,</div><div class="line">      &apos;U&apos;,&apos;V&apos;,&apos;W&apos;,&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;)</div></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>fontImgPath - 必选，字体图片路径</li>
<li>fontWidth - 必选，字体图片中字体宽度</li>
<li>fontHeight - 必选，字体图片中字体高度</li>
<li>targetImgPath - 可选，生成验证码存放路径，默认为当前路径，图片名 authcode.png</li>
<li>codeLength - 可选，生成验证码中字符数目，默认为 4 个字符</li>
<li>saltNum - 可选，生成验证码中椒盐现象数目，默认为 200</li>
<li>base - 字符集合，必须与字体图片素材中的顺序匹配</li>
</ul>
<h1 id="生成基本验证码图片"><a href="#生成基本验证码图片" class="headerlink" title="生成基本验证码图片"></a>生成基本验证码图片</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Generate Authcode Image</div><div class="line">def getAuthcode(base, fontImgPath, codeLength, fontWidth, fontHeight):</div><div class="line">    code = &apos;&apos;</div><div class="line">    fontImg = Image.open(fontImgPath)</div><div class="line">    codeImg = Image.new(&apos;RGBA&apos;, (fontWidth*codeLength, fontHeight+6), (255,255,255,0))</div><div class="line">    for k in range(codeLength):</div><div class="line">        randInt = random.randint(0,len(base)-1)</div><div class="line">        code = &apos;&apos;.join((code, base[randInt]))</div><div class="line">        img_s = fontImg.crop((randInt*fontWidth,0,(randInt+1)*fontWidth,fontHeight))</div><div class="line">        img_s = img_s.rotate(random.randint(-30,30))</div><div class="line">        codeImg.paste(img_s, (k*fontWidth,3))</div><div class="line">    return codeImg, code</div></pre></td></tr></table></figure>
<p>首先创建新的 RGBA 格式空白图片，其宽为字体宽度与验证码字符个数之积，高为字体高度+6px。依次随机选取字体集合中的一个字符，从字体素材图片中截取相应字符并旋转 -30° ~ 30°，粘贴到新建的图片中。最后将新建的图片与验证码字符串返回。</p>
<h1 id="干扰素"><a href="#干扰素" class="headerlink" title="干扰素"></a>干扰素</h1><h2 id="椒盐现象"><a href="#椒盐现象" class="headerlink" title="椒盐现象"></a>椒盐现象</h2><p>在指定图片中添加指定个数的干扰点，干扰点颜色随机，位置随机（但不能影响验证码字符）。图像操作直接改变原图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Add Salt</div><div class="line">def addSalt(image, saltNum):</div><div class="line">    width, height = image.size</div><div class="line">    count = 0</div><div class="line">    while count &lt; saltNum:</div><div class="line">        randX = random.randint(0, width-1)</div><div class="line">        randY = random.randint(0, height-1)</div><div class="line">        if image.getpixel((randX, randY))[-1] == 0:</div><div class="line">            image.putpixel((randX, randY), (random.randint(100,255), random.randint(100,255), random.randint(100,255), 255))</div><div class="line">            count += 1</div><div class="line">        else:</div><div class="line">            continue</div></pre></td></tr></table></figure>
<h2 id="干扰线"><a href="#干扰线" class="headerlink" title="干扰线"></a>干扰线</h2><p>在指定图片中添加 2 条位置随机的干扰线（数目可改变，但会影响用户体验）。此处在图片上半部分与下半部分各添加一条黑色干扰线，并带有一定倾斜度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">## Add Lines</div><div class="line">def addLines(image):</div><div class="line">    width, height = image.size</div><div class="line">    draw = ImageDraw.Draw(image)</div><div class="line">    for k in range(2):</div><div class="line">        randHeight = (height/2)*(k%2)+random.randint(5, (height-1)/2-5)</div><div class="line">        startPoint = (0, randHeight)</div><div class="line">        if random.random() &lt; 0.5:</div><div class="line">            endPoint = (width-1, randHeight+random.randint(0,5))</div><div class="line">        else:</div><div class="line">            endPoint = (width-1, randHeight-random.randint(0,5))</div><div class="line">        draw.line((startPoint, endPoint), fill=(0,0,0,255))</div><div class="line">    del draw</div></pre></td></tr></table></figure>
<h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">from PIL import Image, ImageDraw</div><div class="line">import random, argparse</div><div class="line"></div><div class="line"># Settings</div><div class="line">parser = argparse.ArgumentParser()</div><div class="line">parser.add_argument(&apos;input&apos;, help=&apos;font image source&apos;)</div><div class="line">parser.add_argument(&apos;fontwidth&apos;, help=&apos;width of the font&apos;)</div><div class="line">parser.add_argument(&apos;fontheight&apos;, help=&apos;height of the font&apos;)</div><div class="line">parser.add_argument(&apos;-o&apos;, help=&apos;target image path&apos;, default=&apos;./authcode.png&apos;)</div><div class="line">parser.add_argument(&apos;-l&apos;, help=&apos;authcode length&apos;, default=4)</div><div class="line">parser.add_argument(&apos;-s&apos;, help=&apos;salt counts&apos;, default=200)</div><div class="line">args = parser.parse_args()</div><div class="line">fontImgPath = args.input</div><div class="line">fontWidth = int(args.fontwidth)</div><div class="line">fontHeight = int(args.fontheight)</div><div class="line">targetImgPath = args.o</div><div class="line">codeLength = int(args.l)</div><div class="line">saltNum = int(args.s)</div><div class="line">base = (&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,</div><div class="line">      &apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;,</div><div class="line">      &apos;K&apos;,&apos;L&apos;,&apos;M&apos;,&apos;N&apos;,&apos;O&apos;,&apos;P&apos;,&apos;Q&apos;,&apos;R&apos;,&apos;S&apos;,&apos;T&apos;,</div><div class="line">      &apos;U&apos;,&apos;V&apos;,&apos;W&apos;,&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;)</div><div class="line"></div><div class="line"># Generate Authcode Image</div><div class="line">def getAuthcode(base, fontImgPath, codeLength, fontWidth, fontHeight):</div><div class="line">    code = &apos;&apos;</div><div class="line">    fontImg = Image.open(fontImgPath)</div><div class="line">    codeImg = Image.new(&apos;RGBA&apos;, (fontWidth*codeLength, fontHeight+6), (255,255,255,0))</div><div class="line">    for k in range(codeLength):</div><div class="line">        randInt = random.randint(0,len(base)-1)</div><div class="line">        code = &apos;&apos;.join((code, base[randInt]))</div><div class="line">        img_s = fontImg.crop((randInt*fontWidth,0,(randInt+1)*fontWidth,fontHeight))</div><div class="line">        img_s = img_s.rotate(random.randint(-30,30))</div><div class="line">        codeImg.paste(img_s, (k*fontWidth,3))</div><div class="line">    return codeImg, code</div><div class="line"></div><div class="line"># Add Salt</div><div class="line">def addSalt(image, saltNum):</div><div class="line">    width, height = image.size</div><div class="line">    count = 0</div><div class="line">    while count &lt; saltNum:</div><div class="line">        randX = random.randint(0, width-1)</div><div class="line">        randY = random.randint(0, height-1)</div><div class="line">        if image.getpixel((randX, randY))[-1] == 0:</div><div class="line">            image.putpixel((randX, randY), (random.randint(100,255), random.randint(100,255), random.randint(100,255), 255))</div><div class="line">            count += 1</div><div class="line">        else:</div><div class="line">            continue</div><div class="line"></div><div class="line">## Add Lines</div><div class="line">def addLines(image):</div><div class="line">    width, height = image.size</div><div class="line">    draw = ImageDraw.Draw(image)</div><div class="line">    for k in range(2):</div><div class="line">        randHeight = (height/2)*(k%2)+random.randint(5, (height-1)/2-5)</div><div class="line">        startPoint = (0, randHeight)</div><div class="line">        if random.random() &lt; 0.5:</div><div class="line">            endPoint = (width-1, randHeight+random.randint(0,5))</div><div class="line">        else:</div><div class="line">            endPoint = (width-1, randHeight-random.randint(0,5))</div><div class="line">        draw.line((startPoint, endPoint), fill=(0,0,0,255))</div><div class="line">    del draw</div><div class="line"></div><div class="line"># Main</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    authcode, code = getAuthcode(base, fontImgPath, codeLength, fontWidth, fontHeight)</div><div class="line">    addSalt(authcode, saltNum)</div><div class="line">    addLines(authcode)</div><div class="line">    authcode.save(targetImgPath, &apos;PNG&apos;)</div><div class="line">    print &apos;Generate Authcode: &apos;,code</div></pre></td></tr></table></figure>
<h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python generate_authcode.py font.png 19 20 -o authcode.png -l 4 -s 200</div></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Generate Authcode:  3PHU</div></pre></td></tr></table></figure>
<p>生成验证码图片：</p>
<p><img src="/images/authcode.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[socket网络通信——UNIX域套接字]]></title>
      <url>http://lizonghang.github.io/2016/07/26/socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94UNIX%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
      <content type="html"><![CDATA[<p>从程序员的角度来看，使用 UNIX 域套接字和 TCP/IP 套接字存在两个根本区别。首先，套接字的地址是文件系统上的一个路径，而不是一个包含服务器名和端口的元组。其次，文件系统中创建的表示套接字的节点会持久保存，即时套接字关闭也仍然存在，所以每次服务器启动时都需要将其删除。只需在设置部分做一些修改就可以把前面的回应服务器例子更新为使用 UDS。</p>
<h1 id="UNIX域套接字"><a href="#UNIX域套接字" class="headerlink" title="UNIX域套接字"></a>UNIX域套接字</h1><p>注意：sock 的创建已经从 <code>socket.AF_INET</code> 改变为 <code>socket.AF_UNIX</code>，并且服务器地址是文件系统中的一个节点。运行以下代码后，将会在指定位置创建一个 readonly 文件，文件类型为 socket 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">import os</div><div class="line"></div><div class="line">server_address = &apos;/Users/mac/Desktop/uds_socket&apos;</div><div class="line">try:</div><div class="line">    os.unlink(server_address)</div><div class="line">except OSError:</div><div class="line">    if os.path.exists(server_address)</div><div class="line">        raise</div><div class="line"></div><div class="line"># Create a UDS socket</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">print &apos;Starting up on %s&apos; % server_address</div><div class="line">sock.bind(server_address)</div><div class="line">sock.listen(1)</div><div class="line"></div><div class="line">while True:</div><div class="line">    print &apos;Waiting for a connection ...&apos;</div><div class="line">    connection, client_address = sock.accept()</div><div class="line">    try:</div><div class="line">        print &apos;Connection from &apos;, client_address</div><div class="line">        while True:</div><div class="line">            data = connection.recv(16)</div><div class="line">            print &apos;Received &quot;%s&quot;&apos; % data</div><div class="line">            if data:</div><div class="line">                print &apos;Sending data back to the client&apos;</div><div class="line">                connection.sendall(data)</div><div class="line">            else:</div><div class="line">                print &apos;No data from %s&apos; % server_address</div><div class="line">                break</div><div class="line">    finally:</div><div class="line">        connection.close()</div></pre></td></tr></table></figure>
<p>还需要修改客户设置来使用 UDS，要假设套接字的相应文件系统节点存在，因为服务器要通过绑定这个地址来创建套接字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">import sys</div><div class="line"></div><div class="line">sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</div><div class="line">server_address = &apos;/Users/mac/Desktop/uds_socket&apos;</div><div class="line"></div><div class="line">print &apos;Connecting to %s ...&apos; % server_address</div><div class="line">try:</div><div class="line">    sock.connect(server_address)</div><div class="line">except socket.error, msg:</div><div class="line">    print msg</div><div class="line">    sys.exit(1)</div><div class="line"></div><div class="line"># Send data</div><div class="line">try:</div><div class="line">    message = &apos;This is the message, it will be repeated.&apos;</div><div class="line">    print &apos;Sending &quot;%s&quot;&apos; % message</div><div class="line">    sock.sendall(message)</div><div class="line">    amount_received = 0</div><div class="line">    amount_expected = len(message)</div><div class="line">    while amount_received &lt; amount_expected:</div><div class="line">        data = sock.recv(16)</div><div class="line">        amount_received += len(data)</div><div class="line">        print &apos;Received &quot;%s&quot;&apos; % data</div><div class="line">finally:</div><div class="line">    sock.close()</div></pre></td></tr></table></figure>
<p>程序输出基本上相同，但对地址信息有适当的更新。服务器显示接收的消息并发回给客户端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Starting up on /Users/mac/Desktop/uds_socket</div><div class="line">Waiting for a connection ...</div><div class="line">Connection from</div><div class="line">Received &quot;This is the mess&quot;</div><div class="line">Sending data back to the client</div><div class="line">Received &quot;age, it will be &quot;</div><div class="line">Sending data back to the client</div><div class="line">Received &quot;repeated.&quot;</div><div class="line">Sending data back to the client</div><div class="line">Received &quot;&quot;</div><div class="line">No data from /Users/mac/Desktop/uds_socket</div><div class="line">Waiting for a connection ...</div></pre></td></tr></table></figure>
<p>客户端采用增量方式逐部分接收消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Connecting to /Users/mac/Desktop/uds_socket ...</div><div class="line">Sending &quot;This is the message, it will be repeated.&quot;</div><div class="line">Received &quot;This is the mess&quot;</div><div class="line">Received &quot;age, it will be &quot;</div><div class="line">Received &quot;repeated.&quot;</div></pre></td></tr></table></figure>
<h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><p>由于 UDS 套接字由文件系统上的一个节点表示，所以可以使用标准文件系统权限来控制对服务器的访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls -l /Users/mac/Desktop/uds_socket</div><div class="line">srwxr-xr-x  1 Hang  staff  0  7 26 21:35 /Users/mac/Desktop/uds_socket</div></pre></td></tr></table></figure>
<p>如果客户作为一个用户运行而不是作为 root，则会导致一个错误，因为进程没有打开套接字的权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ python server.py</div><div class="line">Connecting to /Users/mac/Desktop/uds_socket</div><div class="line">[Errno 13] Permission denied</div></pre></td></tr></table></figure>
<h1 id="父进程与子进程通信"><a href="#父进程与子进程通信" class="headerlink" title="父进程与子进程通信"></a>父进程与子进程通信</h1><p>在 Unix 下，<code>socketpair()</code> 函数对于建立 UDS 套接字完成进程间通信很有用。它会创建一对连接的套接字，在创建子进程之后，可以用来在父进程和子进程之间通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">import os</div><div class="line"></div><div class="line">parent, child = socket.socketpair()</div><div class="line">pid = os.fork()</div><div class="line">if pid:</div><div class="line">    print &apos;In parent, sending message&apos;</div><div class="line">    child.close()</div><div class="line">    parent.sendall(&apos;message from parent&apos;)</div><div class="line">    response = parent.recv(1024)</div><div class="line">    print &apos;Response from child: &apos;, response</div><div class="line">    parent.close()</div><div class="line">else:</div><div class="line">    print &apos;In child, waiting for message&apos;</div><div class="line">    parent.close()</div><div class="line">    message = child.recv(1024)</div><div class="line">    print &apos;Message from parent: &apos;, message</div><div class="line">    child.sendall(&apos;message from child&apos;)</div><div class="line">    child.close()</div></pre></td></tr></table></figure>
<p>默认地会创建一个 UDS 套接字，不过调用者还可以传递地址簇、套接字类型，甚至协议选项来控制如何创建套接字。</p>
<p>运行输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">In parent, sending message</div><div class="line">In child, waiting for message</div><div class="line">Message from parent:  message from parent</div><div class="line">Response from child:  message from child</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 网络通信 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[socket网络通信——UDP客户和服务器]]></title>
      <url>http://lizonghang.github.io/2016/07/26/socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94UDP%E5%AE%A2%E6%88%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>用户数据报协议（user datagram protocol，UDP）的工作方式与 TCP/IP 不同。TCP 是一个面向流（stream-oriented）的协议，确保所有数据以正确的顺序传输。UDP 是一个面向消息（message-oriented）的协议。UDP 不需要一个长期活动的连接，所以建立 UDP 套接字要简单些。另一方面，UDP 消息必须放在一个数据包中（对于IPv4，意味着它们可以包含 65507 字节，因为 65535 字节大小的数据包还包括首部信息），而且无法得到 TCP 提供的传输保障。</p>
<h1 id="回应服务器"><a href="#回应服务器" class="headerlink" title="回应服务器"></a>回应服务器</h1><p>由于实际上并没有连接，服务器不需要监听和接受连接。它只需要使用 <code>bind()</code> 将其套接字与一个端口关联，然后等待各个消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"># Create a UDP socket</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</div><div class="line"># Bind the socket to the port</div><div class="line">sock.bind((&apos;localhost&apos;, 10000))</div></pre></td></tr></table></figure>
<p>使用 <code>recvfrom()</code> 从套接字读取消息，这个函数会返回数据，还会返回发出这个数据的客户地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">while True:</div><div class="line">    print &apos;Waiting to receive message ...&apos;</div><div class="line">    data, address = sock.recvfrom(4096)</div><div class="line">    print &apos;Received %s bytes from %s&apos; % (len(data), address)</div><div class="line">    print &apos;Data: &apos;, data</div><div class="line">    if data:</div><div class="line">        sent = sock.sendto(data, address)</div><div class="line">        print &apos;sent data &quot;%s&quot; back to %s&apos; % (data, address)</div></pre></td></tr></table></figure>
<h1 id="回应客户"><a href="#回应客户" class="headerlink" title="回应客户"></a>回应客户</h1><p>UDP 回应客户与服务器类似，但是不使用 <code>bind()</code> 将套接字关联到一个地址。它使用 <code>sendto()</code> 将消息直接传送到服务器，并使用 <code>recvfrom()</code> 接收响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"># Create a UDP socket</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</div><div class="line">message = &apos;This is the message, it will be repeat later.&apos;</div><div class="line">try:</div><div class="line">    print &apos;Send message: &apos;, message</div><div class="line">    sent = sock.sendto(message, (&apos;localhost&apos;, 10000))</div><div class="line">    print &apos;Waiting to receive callback message ...&apos;</div><div class="line">    data, server = sock.recvfrom(4096)</div><div class="line">    print &apos;Received callback message: &apos;, data</div><div class="line">finally:</div><div class="line">    sock.close()</div><div class="line">    print &apos;Socket closed&apos;</div></pre></td></tr></table></figure>
<h1 id="客户与服务器"><a href="#客户与服务器" class="headerlink" title="客户与服务器"></a>客户与服务器</h1><p>运行这个服务器将会生成以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Waiting to receive message ...</div><div class="line">Received 45 bytes from (&apos;127.0.0.1&apos;, 60844)</div><div class="line">Data:  This is the message, it will be repeat later.</div><div class="line">sent data &quot;This is the message, it will be repeat later.&quot; back to (&apos;127.0.0.1&apos;, 60844)</div><div class="line">Waiting to receive message ...</div></pre></td></tr></table></figure>
<p>客户端输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Send message:  This is the message, it will be repeat later.</div><div class="line">Waiting to receive callback message ...</div><div class="line">Received callback message:  This is the message, it will be repeat later.</div><div class="line">Socket closed</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 网络通信 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[轮廓检测]]></title>
      <url>http://lizonghang.github.io/2016/07/25/%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B/</url>
      <content type="html"><![CDATA[<h1 id="轮廓检测"><a href="#轮廓检测" class="headerlink" title="轮廓检测"></a>轮廓检测</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">im = cv2.imread(&apos;star.png&apos;)</div><div class="line">im = im.copy()</div><div class="line">gray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</div><div class="line">ret, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)</div><div class="line">contours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</div><div class="line">cv2.drawContours(im, contours, -1, (0,0,255), 3)</div><div class="line">cv2.imshow(&apos;img&apos;, im)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>需要注意的是 <code>cv2.findContours()</code> 函数接受的参数为二值图，所以读取的图像要先转成灰度图，再转成二值图。</p>
<p>原图：</p>
<p><img src="/images/star.png" alt=""></p>
<p>检测结果：</p>
<p><img src="/images/star-edge.jpg" alt=""></p>
<p>注意，<code>cv2.findContours()</code> 函数会修改输入的图像。</p>
<h1 id="cv2-findContours"><a href="#cv2-findContours" class="headerlink" title="cv2.findContours()"></a>cv2.findContours()</h1><p>函数原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">contours, hierarchy = cv2.findContours(image, mode, method[, contours[, hierarchy[, offset]]])</div></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>image - 输入图像</li>
<li>mode - 轮廓的检索模式。<code>cv2.RETR_EXTERNAL</code> 只检测外轮廓；<code>RETR_LIST</code> 检测的轮廓不建立等级关系；<code>RETR_CCOMP</code> 建立两个等级的轮廓，上一层为外边界，内层为内孔的边界。如果内孔内还有连通物体，则这个物体的边界也在顶层；<code>RETR_TREE</code> 建立一个等级树结构的轮廓。</li>
<li>method - 轮廓的近似办法。<code>cv2.CHAIN_APPROX_NONE</code> 存储所有的轮廓点，相邻的两个点的像素位置差不超过 1 ，即 max(abs(x1-x2), abs(y1-y2)) == 1；<code>cv2.CHAIN_APPROX_SIMP</code> 压缩水平方向、垂直方向、对角线方向的元素，只保留该方向的终点坐标。例如一个矩形轮廓只需要 4 个点来保存轮廓信息；<code> cv2.CHAIN_APPROX_TC89_L1</code>，CV_CHAIN_APPROX_TC89_KCOS 使用 teh-Chinl chain 近似算法。</li>
<li>contours - 返回的轮廓</li>
<li>hierarchy - 每条轮廓对应的属性</li>
</ul>
<h2 id="返回值contour"><a href="#返回值contour" class="headerlink" title="返回值contour"></a>返回值contour</h2><p><code>cv2.findContours()</code> 函数首先返回一个 list，list 中每个元素都是图像中的一个轮廓，用 numpy 中的 ndarray 表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print type(contours)</div><div class="line">print type(contours[0])</div><div class="line">print len(contours)</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;type &apos;list&apos;&gt;</div><div class="line">&lt;type &apos;numpy.ndarray&apos;&gt;</div><div class="line">2</div></pre></td></tr></table></figure>
<p>可以验证上述信息。可以看到本例中有两条轮廓，一个是五角星的，一个是矩形的。每个轮廓是一个 ndarray，每个 ndarray 是轮廓上的点的集合。</p>
<p>由于知道返回的轮廓有两个，因此可以通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cv2.drawContours(im, contours, 0, (0,0,255), 3)</div><div class="line">cv2.drawContours(im, contours, 1, (0,255,0), 3)</div></pre></td></tr></table></figure>
<p>分别绘制两个轮廓。同时使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print len(contours[0])</div><div class="line">print len(contours[1])</div></pre></td></tr></table></figure>
<p>输出两个轮廓中存储的点的个数。可见五角星只有 5 个元素，这是因为轮廓中并不是存储轮廓上所有点，而是只存储可以用直线描述轮廓的点的个数，比如一个矩形只需要 4 个顶点就可以描述轮廓。</p>
<h2 id="返回值hierarchy"><a href="#返回值hierarchy" class="headerlink" title="返回值hierarchy"></a>返回值hierarchy</h2><p>该函数还返回一个可选的 hierarchy 结果，这是一个 ndarray，其中元素个数和轮廓个数相同，每个轮廓 <code>contours[i]</code> 对应 4 个 hierarchy 元素 <code>hierarchy[i][0] ~ hierarchy[i][3]</code>，分别表示后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号，如果没有对应项，则该值为负数。通过如下查看各属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print type(hierarchy)</div><div class="line">print hierarchy.ndim</div><div class="line">print hierarchy[0].ndim</div><div class="line">print hierarchy.shape</div></pre></td></tr></table></figure>
<h1 id="轮廓的绘制"><a href="#轮廓的绘制" class="headerlink" title="轮廓的绘制"></a>轮廓的绘制</h1><p>OpenCV 通过 <code>cv2.drawContours()</code> 在图像上绘制轮廓。函数原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset ]]]]])</div></pre></td></tr></table></figure>
<ul>
<li>image - 在选定的图像上绘制轮廓</li>
<li>contours - 轮廓本身，是一个 list</li>
<li>contourIdx - 指定绘制哪条轮廓，如果为 -1 则绘制所有轮廓</li>
<li>后续参数比较显而易见，其中 thickness 表明轮廓线宽度，如果为 -1 （<code>cv2.FILLED</code>），则为填充模式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cv2.drawContours(im, contours, -1, (0,0,255), 2)</div><div class="line">cv2.imshow(&apos;image&apos;, im)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[霍夫变换检测直线]]></title>
      <url>http://lizonghang.github.io/2016/07/25/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E6%A3%80%E6%B5%8B%E7%9B%B4%E7%BA%BF/</url>
      <content type="html"><![CDATA[<h1 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h1><p>Hough 变换是经典的检测直线的算法，最初用来检测图像中的直线，也可以将其扩展，以检测图像中简单的结构。</p>
<p>OpenCV 提供了两种用于直线检测的 Hough 变换形式，其中基本的版本是 <code>cv2.HoughLines()</code>。输入一幅含有点集的二值图，其中一些点相互联系组成直线。通常这是通过如 Canny 算子获得的一幅边缘图像。<code>cv2.HoughLines()</code> 函数输出 <code>[float, float]</code> 形式的 ndarray，其中每个值表示检测到的线(ρ , θ)中浮点点值的参数。下面的例子先用 Canny 算子获得图像边缘，然后使用 Hough 变换检测直线。其中 <code>cv2.HoughLines()</code> 函数的参数3和4对应直线搜索的步长。在本例中，函数将通过步长为 1 的半径和步长为 π/180 的角来搜索所有可能的直线。最后一个参数是经过某一点曲线的数量的阈值，超过这个阈值就表示这个交点所代表的参数对 (ρ , θ) 在原图像为一条直线。</p>
<p>示例图像如下：</p>
<p><img src="/images/street.jpg" alt=""></p>
<p>直线检测代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;street.jpg&apos;)</div><div class="line">im = cv2.GaussianBlur(im, (3,3), 0)</div><div class="line">edges = cv2.Canny(im, 50, 150, apertureSize=3)</div><div class="line">lines = cv2.HoughLines(edges, 1, np.pi/180, 260)</div><div class="line">result = im.copy()</div><div class="line">for line in lines[0]:</div><div class="line">    rho = line[0]</div><div class="line">    theta= line[1]</div><div class="line">    if  (theta &lt; (np.pi/4. )) or (theta &gt; (3.*np.pi/4.0)):</div><div class="line">        pt1 = (int(rho/np.cos(theta)),0)</div><div class="line">        pt2 = (int((rho-result.shape[0]*np.sin(theta))/np.cos(theta)),result.shape[0])</div><div class="line">        cv2.line( result, pt1, pt2, (0,0,255))</div><div class="line">    else:</div><div class="line">        pt1 = (0,int(rho/np.sin(theta)))</div><div class="line">        pt2 = (result.shape[1], int((rho-result.shape[1]*np.cos(theta))/np.sin(theta)))</div><div class="line">        cv2.line(result, pt1, pt2, (0,0,255), 1)</div><div class="line"></div><div class="line">cv2.imshow(&apos;Hough&apos;, result)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/images/hough.jpg" alt=""></p>
<h1 id="概率霍夫变换"><a href="#概率霍夫变换" class="headerlink" title="概率霍夫变换"></a>概率霍夫变换</h1><p>前面例子得到的结果图片，其中 Hough 变换看起来就像在图像中查找对齐的边界像素点集合，但这样会在一些情况下导致虚假检测，如像素偶然对齐或多条直线穿过同样的对齐像素造成的多重检测。</p>
<p>要避免这样的问题，并检测图像中分段的直线（而不是贯穿整个图像的直线），就出现了概率 Hough 变换。在 OpenCV 中用函数 <code>cv2.HoughLinesP()</code> 实现。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;street.jpg&apos;)</div><div class="line">im = cv2.GaussianBlur(im, (3,3), 0)</div><div class="line">edges = cv2.Canny(im, 50, 150, apertureSize=3)</div><div class="line">result = im.copy()</div><div class="line">minLineLength = 100</div><div class="line">maxLineGap = 50</div><div class="line">lines = cv2.HoughLinesP(edges, 1, np.pi/180, 200, minLineLength, maxLineGap)</div><div class="line">for x1,y1,x2,y2 in lines[0]:</div><div class="line">    cv2.line(result, (x1,y1), (x2,y2), (0,0,255), 2)</div><div class="line"></div><div class="line">cv2.imshow(&apos;HoughP&apos;, result)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/images/houghP.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Laplacian算子]]></title>
      <url>http://lizonghang.github.io/2016/07/25/Laplacian%E7%AE%97%E5%AD%90/</url>
      <content type="html"><![CDATA[<p>图像中的边缘区域像素值会发生“跳跃”，对这些像素求导，其一阶导数在边缘位置为极值，这是 Sobel 算子的原理。如果对像素值求二阶导数，会发现边缘处的二阶导数值为 0 。Laplace 函数实现的方法是先用 Sobel 算子计算二阶 x 和 y 导数，再求和：</p>
<p><img src="/images/laplace_arg.jpg" alt=""></p>
<p>在 OpenCV-Python 中，Laplace 算子的函数原型如下，和 Sobel 算子中的参数基本一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.Laplacian(src, ddepth[, dst[, ksize[, scale[, delta[, borderType]]]]])</div></pre></td></tr></table></figure>
<p>测试图像：</p>
<p><img src="/images/tower.jpg" alt=""></p>
<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;tower.jpg&apos;)</div><div class="line">gray_lap = cv2.Laplacian(im, cv2.CV_16S, ksize=3)</div><div class="line">dst = cv2.convertScaleAbs(gray_lap)</div><div class="line"></div><div class="line">cv2.imshow(&apos;laplacian&apos;, dst)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/tower-lap.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Sobel算子]]></title>
      <url>http://lizonghang.github.io/2016/07/24/Sobel%E7%AE%97%E5%AD%90/</url>
      <content type="html"><![CDATA[<p>Sobel 算子是一种过滤器，但它带有方向。在 OpenCV-Python 中，使用 Sobel 算子的函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.Sobel(src, ddepth, dx, dy[, dst[, ksize[, scale[, delta[, borderType]]]]])</div></pre></td></tr></table></figure>
<p>必选参数：</p>
<ul>
<li>src - 需要处理的图像。</li>
<li>ddepth - 图像深度。-1 表示采用与原图像相同的深度。目标图像深度≥原图像深度。</li>
<li>dx, dy - 求导阶数，0 表示不求导。</li>
</ul>
<p>可选参数：</p>
<ul>
<li>ksize - Sobel 算子大小，必须为 1、3、5、7。</li>
<li>scale - 缩放导数的比例常数，默认情况下不伸缩。</li>
<li>delta - 可选增量，会加到最终 dst 中，默认情况下不额外增加。</li>
<li>borderType - 判断图像边界的模式。默认值为 <code>cv2.BORDER_DEFAULT。</code></li>
</ul>
<p>Sobel 函数使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lion.jpg&apos;)</div><div class="line">im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</div><div class="line"></div><div class="line">x = cv2.Sobel(im, cv2.CV_16S, 1, 0)</div><div class="line">y = cv2.Sobel(im, cv2.CV_16S, 0, 1)</div><div class="line"></div><div class="line">absX = cv2.convertScaleAbs(x)</div><div class="line">absY = cv2.convertScaleAbs(y)</div><div class="line"></div><div class="line">dst = cv2.addWeighted(absX, 0.5, absY, 0.5, 0)</div><div class="line"></div><div class="line">cv2.imshow(&apos;origin&apos;, im)</div><div class="line">cv2.imshow(&quot;absX&quot;, absX)</div><div class="line">cv2.imshow(&quot;absY&quot;, absY)</div><div class="line">cv2.imshow(&quot;Result&quot;, dst)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>由于 Sobel 函数求导数后会有负值，还会有大于 255 的值，而原图像是 uint8 ，所以 Sobel 建立的图像位数不够，会有截断。因此要使用 16 位有符号的数据类型，即 <code>cv2.CV_16S</code>。</p>
<p>处理后要用 <code>cv2.convertScaleAbs()</code> 将其转回原来的 uint8 形式，否则无法显示图像。 <code>cv2.convertScaleAbs()</code> 的原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.convertScaleAbs(src[, dst[, alpha[, beta]]])</div></pre></td></tr></table></figure>
<p>其中可选参数 <code>alpha</code> 是伸缩系数， <code>beta</code> 是加到结果上的一个值。结果返回 uint8 类型的图片。</p>
<p>由于 Sobel 算子是在两个方向计算的，最后要使用 <code>cv2.addWeighted()</code> 函数将其组合起来。函数原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.addWeighted(src1, alpha, src2, beta, gamma[, dst[, dtype]])</div></pre></td></tr></table></figure>
<p>其中 <code>alpha</code> 是第一幅图片中元素的权重， <code>beta</code> 是第二个图片中元素的权重， <code>gamma</code> 是加到最后结果上的一个值。</p>
<p>原图：</p>
<p><img src="/images/lion.jpg" alt=""></p>
<p>absX：</p>
<p><img src="/images/absX.jpg" alt=""></p>
<p>absY：</p>
<p><img src="/images/absY.jpg" alt=""></p>
<p>Result：</p>
<p><img src="/images/sobel.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[滤波]]></title>
      <url>http://lizonghang.github.io/2016/07/24/%E6%BB%A4%E6%B3%A2/</url>
      <content type="html"><![CDATA[<h1 id="滤波简介"><a href="#滤波简介" class="headerlink" title="滤波简介"></a>滤波简介</h1><p>过滤是信号和图像处理中基本的任务，目的是根据应用环境的不同，选择性的提取图像中某些认为重要的信号。过滤可以移除图像中的噪音、提取感兴趣的可视特征、允许图像重采样等等。</p>
<p>当观察一张图片时，我们观察的是图像中有多少灰度级（或颜色）及其分布。根据灰度分布的不同来区分不同的图像。也有其他方面可以对图像进行分析，例如观察图像中灰度的变化。某些图像中包含大量强度不变的区域（如蓝天），而在其他图像中的灰度变化可能会非常快（如包含许多小物体的拥挤的图像）。因此，观察图像中这些变化的频率就构成了另一条分类图像的方法，这个观点称为频域。而通过观察图像灰度分布来分类图像称为空间域。</p>
<p>频域分析将图像分成从低频到高频的不同部分。低频对应图像强度变化小的区域，而高频是图像强度变化非常大的区域。目前存在若干种转换方法，如傅里叶变换或余弦变换，可以用来清晰地显示图像的频率。由于图像是一个二维实体，所以其频率由水平频率和竖直频率共同组成。</p>
<p>在频率分析领域的框架中，滤波器是一个用来增强图像中某个波段或频率并阻塞（或降低）其他频率波段的操作。低通滤波器是消除图像中的高频部分，保留低频部分。高通滤波器消除低频部分，保留高频部分。</p>
<p>这里只介绍在 OpenCV-Python 中实现的初级滤波操作，之后介绍更复杂的滤波原理及实现。</p>
<p>以下图为例：</p>
<p><img src="/images/lena.jpg" alt=""></p>
<h1 id="低通滤波平滑图像"><a href="#低通滤波平滑图像" class="headerlink" title="低通滤波平滑图像"></a>低通滤波平滑图像</h1><h2 id="初级低通滤波"><a href="#初级低通滤波" class="headerlink" title="初级低通滤波"></a>初级低通滤波</h2><p>低通滤波器的目标是降低图像的变化率。如将每个像素替换为该像素周围像素的均值，这样就可以平滑并替代那些强度变化明显的区域。在 OpenCV 中可以通过 <code>cv2.blur()</code> 来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.blur(im, (5,5))</div></pre></td></tr></table></figure>
<p>其中 <code>dst</code> 是函数处理后返回的图像，第一个参数是待处理图像，第二个参数是低通滤波器的大小。其后含有几个可选参数用来设置滤波器的细节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">blured = cv2.blur(im, (5,5))</div><div class="line"></div><div class="line">cv2.namedWindow(&apos;Origin&apos;, cv2.WINDOW_NORMAL)</div><div class="line">cv2.namedWindow(&apos;Blur&apos;, cv2.WINDOW_NORMAL)</div><div class="line">cv2.imshow(&apos;Origin&apos;, im)</div><div class="line">cv2.imshow(&apos;Blur&apos;, blured)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/blur.png" alt=""></p>
<p>这种滤波器又称为 boxfilter，所以也可使用 <code>cv2.boxFilter()</code> 完成相同的工作。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.boxFilter(im, -1, (5,5))</div></pre></td></tr></table></figure>
<p>该函数与 <code>cv2.blur()</code> 效果完全相同，第二个参数 -1 表示输出图像使用的深度与输入图像相同。</p>
<h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><p>在某些情况下需要对一个像素的周围像素给予更多的重视。因此可用分配权重来重新计算这些周围点的值，可以通过高斯函数的权重方案来解决。<code>cv2.GaussianBlur()</code> 可作为滤波器，用以下方式调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.GaussianBlur(im, (5,5), 1.5)</div></pre></td></tr></table></figure>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>低通滤波与高斯滤波不同之处在于：低通滤波中，滤波器中每个像素的权重是相同的，即滤波器是线性的。而高斯滤波器中像素的权重与其距中心像素的距离成比例。</p>
<h1 id="中值滤波消除噪点"><a href="#中值滤波消除噪点" class="headerlink" title="中值滤波消除噪点"></a>中值滤波消除噪点</h1><p>中值滤波器对于消除椒盐现象很有用。调用方法与调用其他滤波器类似，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.medianBlur(im, 5)</div></pre></td></tr></table></figure>
<p>函数返回处理结果，第一个参数是待处理图像，第二个参数是孔径尺寸，是一个大于 1 的奇数。比如上面就会使用 5x5 领域组成一个数值集，对其进行处理，当前像素被均值替换。</p>
<p>若在某个像素周围有白色或黑色的像素，这些白色或黑色的像素不会选择作为中值（最大或最小值排除），而是被替换为领域值。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;saltImg.jpg&apos;)</div><div class="line">median = cv2.medianBlur(im, 5)</div><div class="line"></div><div class="line">cv2.namedWindow(&apos;Salt&apos;, cv2.WINDOW_NORMAL)</div><div class="line">cv2.namedWindow(&apos;Median&apos;, cv2.WINDOW_NORMAL)</div><div class="line">cv2.imshow(&apos;Salt&apos;, im)</div><div class="line">cv2.imshow(&apos;Median&apos;, median)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindow()</div></pre></td></tr></table></figure>
<p>处理结果如下：</p>
<p><img src="/images/median.png" alt=""></p>
<p>由于中值滤波不会处理最大和最小值，所以不会受噪声影响。相反，如果直接采用 <code>cv2.blur()</code> 进行均值滤波，则不会区分这些噪声点，滤波后的图像会受到噪声的影响。</p>
<p>中值滤波器在处理边缘也有优势，但中值滤波器会清除掉某些区域的纹理，如头发纹理。</p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[形态学处理]]></title>
      <url>http://lizonghang.github.io/2016/07/23/%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="定义结构元素"><a href="#定义结构元素" class="headerlink" title="定义结构元素"></a>定义结构元素</h1><p>形态学处理核心是定义结构元素，在 OpenCV-Python 中，可以使用其自带的 <code>getStructuringElement</code> 函数，也可以直接使用 NumPy 的 <code>ndarray</code> 来定义一个结构元素。首先看用 <code>getStructuringElement</code> 函数定义的结构元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element = cv2.getStructuringElement(cv2.MORPH_CROSS, (5,5))</div></pre></td></tr></table></figure>
<p>这就定义了一个 5x5 的十字形结构元素，如下：</p>
<p><img src="/images/cross.jpg" alt=""></p>
<p>也可以用 NumPy 定义结构元素，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NpKernel = numpy.uint8(numpy.zeros((5,5)))</div><div class="line">for i in range(5):</div><div class="line">    NpKernel[2, i] = 1</div><div class="line">    NpKernel[i, 2] = 1</div></pre></td></tr></table></figure>
<p>两者定义的结构元素完全一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print element</div><div class="line">[[0 0 1 0 0]</div><div class="line"> [0 0 1 0 0]</div><div class="line"> [1 1 1 1 1]</div><div class="line"> [0 0 1 0 0]</div><div class="line"> [0 0 1 0 0]]</div><div class="line">&gt;&gt;&gt; print NpKernel</div><div class="line">[[0 0 1 0 0]</div><div class="line"> [0 0 1 0 0]</div><div class="line"> [1 1 1 1 1]</div><div class="line"> [0 0 1 0 0]</div><div class="line"> [0 0 1 0 0]]</div></pre></td></tr></table></figure>
<p>用 OpenCV-Python 内置的常量定义椭圆（MORPH_ELLIPSE）和十字形结构（MORPH_CROSS）元素要简单一些，如果定义矩形（MORPH_RECT）和自定义结构元素，则用两者差不多。</p>
<p>测试图片：</p>
<p><img src="/images/origin.jpg" alt=""></p>
<h1 id="腐蚀和膨胀"><a href="#腐蚀和膨胀" class="headerlink" title="腐蚀和膨胀"></a>腐蚀和膨胀</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># encoding: utf-8</div><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;origin.jpg&apos;)</div><div class="line"># OpenCV定义结构元素</div><div class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))</div><div class="line"></div><div class="line"># 腐蚀图像</div><div class="line">eroded = cv2.erode(im, kernel)</div><div class="line">cv2.imshow(&apos;Eroded Image&apos;, eroded)</div><div class="line"></div><div class="line"># 膨胀图像</div><div class="line">dilated = cv2.dilate(im, kernel)</div><div class="line">cv2.imshow(&apos;Dilated Image&apos;, dilated)</div><div class="line"></div><div class="line"># 原图像</div><div class="line">cv2.imshow(&apos;Origin Image&apos;, im)</div><div class="line"></div><div class="line"># NumPy定义结构元素</div><div class="line">NpKernel = np.uint8(np.ones((3,3)))</div><div class="line"></div><div class="line"># 腐蚀图像</div><div class="line">Nperoded = cv2.erode(im, NpKernel)</div><div class="line">cv2.imshow(&apos;Eroded by NumPy kernel&apos;, Nperoded)</div><div class="line"></div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>腐蚀和膨胀的处理很简单，只需要设置好结构元素，然后分别调用 <code>cv2.erode()</code> 和 <code>cv2.dilate()</code> 函数即可。其中第一个参数是需要处理的图像，第二个参数是结构元素。函数返回处理后的图像。</p>
<p>结果如下：</p>
<p><img src="/images/erode-dilate.jpg" alt=""></p>
<h1 id="开运算和闭运算"><a href="#开运算和闭运算" class="headerlink" title="开运算和闭运算"></a>开运算和闭运算</h1><p>开运算和闭运算时将腐蚀和膨胀按照一定的次序进行处理，但这两者不可逆，即进行开运算后进行闭运算不能得到原来的图像。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># encoding: utf-8</div><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;origin.jpg&apos;)</div><div class="line"># OpenCV定义结构元素</div><div class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5))</div><div class="line"></div><div class="line"># 闭运算</div><div class="line">closed = cv2.morphologyEx(im, cv2.MORPH_CLOSE, kernel)</div><div class="line">cv2.imshow(&apos;Close&apos;, closed)</div><div class="line"></div><div class="line"># 开运算</div><div class="line">opened = cv2.morphologyEx(im, cv2.MORPH_OPEN, kernel)</div><div class="line">cv2.imshow(&apos;Open&apos;, opened)</div><div class="line"></div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>闭运算用来连接被误分为许多小块的对象，而开运算用于移除由图像噪音形成的斑点。因此，某些情况下可以连续运用这两种运算。如对一幅二值图连续使用闭运算和开运算，将获得图像中的主要对象。同样，如果想要消除图像中的噪声，也可以对图像先用开运算后用闭运算，不过这样也会消除一些破碎的对象。</p>
<p>对原始图像分别进行开运算和闭运算的结果如下：</p>
<p><img src="/images/open.jpg" alt=""><br><img src="/images/close.jpg" alt=""></p>
<h1 id="用形态学运算检测边和角点"><a href="#用形态学运算检测边和角点" class="headerlink" title="用形态学运算检测边和角点"></a>用形态学运算检测边和角点</h1><p>仅作为介绍形态学处理的例子，实际使用时建议使用 Canny 或 Harris 等算法</p>
<h2 id="检测边缘"><a href="#检测边缘" class="headerlink" title="检测边缘"></a>检测边缘</h2><p>形态学检测边缘的原理为：在膨胀时图像中的物体会想向周围扩张；腐蚀时图像中的物体会收缩。比较这两幅图像，由于其变化的区域只发生在边缘，所以将两幅图像相减，得到的就是图像中物体的边缘。</p>
<p>以下图为例：</p>
<p><img src="/images/lampo.jpg" alt=""></p>
<p>边缘检测代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#encoding: utf-8</div><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lampo.jpg&apos;)</div><div class="line"># 转换颜色模式为灰度图</div><div class="line">im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</div><div class="line"># OpenCV 3x3结构元素</div><div class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))</div><div class="line"># 膨胀图像</div><div class="line">dilated = cv2.dilate(im, kernel)</div><div class="line"># 腐蚀图像</div><div class="line">eroded = cv2.erode(im, kernel)</div><div class="line"># 两幅图像相减得到边缘，第一个参数是膨胀图像，第二个参数是腐蚀图像</div><div class="line">edges = cv2.absdiff(dilated, eroded)</div><div class="line"># edges是灰度图，二值化处理以更清楚观察结果</div><div class="line">retval, edges = cv2.threshold(edges, 50, 100, cv2.THRESH_BINARY)</div><div class="line"># 反转颜色</div><div class="line">edges = cv2.bitwise_not(edges)</div><div class="line"></div><div class="line">cv2.imshow(&apos;origin&apos;, im)</div><div class="line">cv2.imshow(&apos;edges&apos;, edges)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/lampo-edge.jpg" alt=""></p>
<h2 id="检测拐角"><a href="#检测拐角" class="headerlink" title="检测拐角"></a>检测拐角</h2><p>拐角检测与边缘检测的原理相同，不同的是先用十字形的结构元素膨胀像素，这种情况下图像中只会在边缘处扩张，而角点不发生变化。接着用菱形的结构元素腐蚀原图像，导致只有在拐角处才会收缩，而直线边缘都未发生变化。第二步是用 X 形膨胀原图像，角点膨胀比边要多。这样第二次用方块腐蚀时，角点恢复原状，而边要腐蚀得更多。所以当两幅图像相减时，只保留了拐角处。</p>
<p>以下图为例：</p>
<p><img src="/images/building.jpg" alt=""></p>
<p>拐角检测代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#encoding: utf-8</div><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;building.jpg&apos;)</div><div class="line"># 转换颜色模式为灰度图</div><div class="line">im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</div><div class="line"># 构造 5x5 的结构元素，分别为十字形、菱形、方形和X形</div><div class="line">cross = cv2.getStructuringElement(cv2.MORPH_CROSS, (5,5))</div><div class="line">diamond = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5))</div><div class="line">diamond[0,0], diamond[0,1], diamond[1,0], diamond[4,4], diamond[4,3], diamond[3,4], diamond[4,0], diamond[4,1], diamond[3,0], diamond[0,3], diamond[0,4], diamond[1,4] = 0,0,0,0,0,0,0,0,0,0,0,0</div><div class="line">square = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5))</div><div class="line">x = cv2.getStructuringElement(cv2.MORPH_CROSS, (5,5))</div><div class="line"># 使用十字形结构元素膨胀图像</div><div class="line">detect1 = cv2.dilate(im, cross)</div><div class="line"># 使用菱形结构元素腐蚀图像</div><div class="line">detect1 = cv2.erode(detect1, diamond)</div><div class="line"># 使用X结构元素膨胀图像</div><div class="line">detect2 = cv2.dilate(im, x)</div><div class="line"># 使用方形结构元素腐蚀图像</div><div class="line">detect2 = cv2.erode(detect2, square)</div><div class="line"># 将两幅图像相减获得角</div><div class="line">horn = cv2.absdiff(detect2, detect1)</div><div class="line"># 使用阈值获得二值图</div><div class="line">retval, horn = cv2.threshold(horn, 40, 255, cv2.THRESH_BINARY)</div><div class="line"># 在原图上用半径为5的圆将点标出</div><div class="line">for j in range(horn.size):</div><div class="line">    y = j / horn.shape[0]</div><div class="line">    x = j % horn.shape[0]</div><div class="line">    if horn[x,y] == 255:</div><div class="line">        cv2.circle(im, (y,x), 5, (255,0,0))</div><div class="line"># 显示修改后的原图</div><div class="line">cv2.imshow(&apos;Horn Detect&apos;, im)</div><div class="line">if cv2.waitKey(0) == 27:</div><div class="line">    cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>由于封装的缘故，OpenCV 中函数参数中使用的坐标系和 NumPy 和 ndarray 的坐标系是不同的，在标点时可以看出。通过上面的代码可以检测图像中的拐角并标出，效果图如下：</p>
<p><img src="/images/horn.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Canny边缘检测]]></title>
      <url>http://lizonghang.github.io/2016/07/22/Canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</url>
      <content type="html"><![CDATA[<h1 id="Canny函数原型"><a href="#Canny函数原型" class="headerlink" title="Canny函数原型"></a>Canny函数原型</h1><p>OpenCV-Python 中 Canny 函数的原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">edge = cv2.Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient]]])</div></pre></td></tr></table></figure>
<ul>
<li>第一个参数是需要处理的原图像，该图像必须为单通道的灰度图</li>
<li>第二个参数是阈值1</li>
<li>第三个参数是阈值2</li>
</ul>
<p>其中较大的阈值2用于检测图像中明显的边缘，但一般情况下检测的效果不大完美，边缘检测出来是断断续续的。所以用较小的阈值1将这些间断的边缘连接起来。</p>
<p>可选参数中 <code>apertureSize</code> 就是 Sobel 算子的大小。而 <code>L2gradient</code> 参数是一个布尔值，若为真则使用更精确的 L2 范数进行计算（即两个方向的导数的平方和再开方），否则使用 L1 范数（直接将两个方向导数的绝对值相加）。</p>
<p>函数返回一幅二值图，其中包含检测出的边缘。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>Canny 函数使用只需要指定最大和最小阈值即可。以下图为例：</p>
<p><img src="/images/tower.jpg" alt=""></p>
<p>使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line">import cv2</div><div class="line">im = cv2.imread(&apos;tower.jpg&apos;)</div><div class="line">im = cv2.GaussianBlur(im, (3,3), 0)</div><div class="line">canny = cv2.Canny(im, 30, 100)</div><div class="line">cv2.imwrite(&apos;canny.jpg&apos;, canny)</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/canny.jpg" alt=""></p>
<p>可以调整阈值以改变边缘效果。</p>
<p>由于 Canny 只能处理灰度图，所以需要先将读取的图像转成灰度图。然后使用高斯平滑处理原图像以降噪。最后调用 Canny 函数，指定最大和最小阈值，其中 <code>apertureSize</code> 默认为 3。</p>
<h1 id="动态调整阈值"><a href="#动态调整阈值" class="headerlink" title="动态调整阈值"></a>动态调整阈值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">def CannyThreshold(lowThreshold):</div><div class="line">    detected_edges = cv2.GaussianBlur(gray, (3,3), 0) # Denoise</div><div class="line">    detected_edges = cv2.Canny(detected_edges, lowThreshold, lowThreshold*ratio,apertureSize=kernel_size) # Canny Edge Detect</div><div class="line">    dst = cv2.bitwise_and(im, im, mask=detected_edges) # Get Edge Image With Color</div><div class="line">    cv2.imshow(&apos;canny&apos;, dst)</div><div class="line"></div><div class="line"># Settings</div><div class="line">lowThreshold = 0 # Track Bar Start from State-0</div><div class="line">max_lowThreshold = 100 # Track Bar End with State-100</div><div class="line">ratio = 3 # threshold2 = threshold1 * ratio</div><div class="line">kernel_size = 3 # Size of Sobel</div><div class="line"></div><div class="line"># Running</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    im = cv2.imread(&apos;tower.jpg&apos;) # Read From File</div><div class="line">    gray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY) # GBR Convert To Gray</div><div class="line">    cv2.namedWindow(&apos;canny&apos;) # Create New Window</div></pre></td></tr></table></figure>
<p>得到的局部效果图如下：</p>
<p><img src="/images/canny_dial.jpg" alt=""></p>
<p>上图中有一个滑动条，拖动可改变 Canny 边缘检测效果，可以自行尝试一下。</p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[直方图的计算与显示]]></title>
      <url>http://lizonghang.github.io/2016/07/22/%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E8%AE%A1%E7%AE%97%E4%B8%8E%E6%98%BE%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>与 C++ 中一样，在 Python 中调用的 OpenCV 直方图计算函数为 <code>cv2.calcHist()</code>。</p>
<p><code>cv2.calcHist()</code> 的原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.calcHist(images, channels, mask, histSize, ranges[, hist[, accumlate ]])</div></pre></td></tr></table></figure>
<p>下面为一个简单例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">hist = cv2.calcHist(</div><div class="line">    [im],</div><div class="line">    [0], #使用的通道</div><div class="line">    None, #没有使用mask</div><div class="line">    [256], #HistSize</div><div class="line">    [0.0, 255.0] #直方图柱的范围</div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li>其中第一个参数 <code>images</code> 必须用方括号括起</li>
<li>第二个参数 <code>channels</code> 是用于计算直方图的通道，这里使用灰度图计算直方图，所以就直接使用第一个通道</li>
<li>第三个参数 <code>mask</code> 没有使用，用 <code>None</code></li>
<li>第四个参数 <code>histSize</code> 表示这个直方图分成多少份（即多少个直方柱）</li>
<li>第五个参数 <code>ranges</code> 表示直方图中各个像素的值， <code>[0.0, 255.0]</code> 表示直方图能表示像素值从 0.0 到 255.0 的像素</li>
<li>由于直方图作为函数结果返回了，所以 <code>hist</code> 没有意义</li>
<li><code>accumulate</code> 是一个布尔值，用来表示直方图是否叠加</li>
</ul>
<h1 id="彩色图像不同通道的直方图"><a href="#彩色图像不同通道的直方图" class="headerlink" title="彩色图像不同通道的直方图"></a>彩色图像不同通道的直方图</h1><p>以下图为例：</p>
<p><img src="/images/lena.jpg" alt=""></p>
<p>首先读取并分离各通道：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r,g,b = cv2.split(im)</div></pre></td></tr></table></figure>
<p>接着计算每个通道的直方图，这里将其封装成一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def calcAndDrawHist(image, color):</div><div class="line">    hist = cv2.calcHist([image], [0], None, [256], [0.0, 255.0])</div><div class="line">    minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(hist)</div><div class="line">    histImg = numpy.zeros([256,256,3], numpy.uint8)</div><div class="line">    hpt = int(0.9*256)</div><div class="line">    for h in range(256):</div><div class="line">        intensity = int(hist[h] * hpt / maxVal)</div><div class="line">        cv2.line(histImg, (h,256), (h,256-intensity), color)</div><div class="line">    return histImg</div></pre></td></tr></table></figure>
<p>在主函数中调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">    r, g, b = cv2.split(im)</div><div class="line">    histImgR = calcAndDrawHist(r, [255, 0, 0])</div><div class="line">    histImgG = calcAndDrawHist(g, [0, 255, 0])</div><div class="line">    histImgB = calcAndDrawHist(b, [0, 0, 255])</div><div class="line">    cv2.imwrite(&apos;/Users/mac/Desktop/histImgR.jpg&apos;, histImgR)</div><div class="line">    cv2.imwrite(&apos;/Users/mac/Desktop/histImgG.jpg&apos;, histImgG)</div><div class="line">    cv2.imwrite(&apos;/Users/mac/Desktop/histImgB.jpg&apos;, histImgB)</div></pre></td></tr></table></figure>
<p>得到的三个通道的直方图如下：</p>
<p><img src="/images/histImgR.jpg" alt=""><br><img src="/images/histImgG.jpg" alt=""><br><img src="/images/histImgB.jpg" alt=""></p>
<p>也可不分离通道，用折线来描绘直方图的边界，可在一个图中同时绘出三个通道的直方图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">h = numpy.zeros((256,256,3))</div><div class="line">bins = numpy.arange(256).reshape(256,1)</div><div class="line">color = [(255,0,0),(0,255,0),(0,0,255)]</div><div class="line">for ch,color in enumerate(color):</div><div class="line">    originHist = cv2.calcHist([im], [ch], None, [256], [0,256])</div><div class="line">    cv2.normalize(originHist, originHist, 0, 255*0.9, cv2.NORM_MINMAX)</div><div class="line">    hist = numpy.int32(numpy.around(originHist))</div><div class="line">    pts = numpy.column_stack((bins, hist))</div><div class="line">    cv2.polylines(h, [pts], False, color)</div><div class="line">h = numpy.flipud(h)</div><div class="line">cv2.imwrite(&apos;colorhist.jpg&apos;, h)</div></pre></td></tr></table></figure>
<p>结果如下图所示：</p>
<p><img src="/images/colorhist.jpg" alt=""></p>
<ul>
<li>for 循环是对三个通道遍历一次，每次绘制相应通道的直方图的折线。for 循环的第一行是计算对应通道的直方图。</li>
<li>这里直接调用了 OpenCV 的归一化函数，该函数将直方图的范围限定在 0~255×0.9 之间。</li>
<li><code>hist = numpy.int32(numpy.around(originHist))</code> 先将生成的原始直方图中的每个元素四舍六入五凑偶取整（cv2.calcHist函数得到的是 float32 类型的数组），接着将整数部分转成 <code>numpy.int32</code> 类型。即61.123先转成61.0，再转成61。这里必须使用 <code>numpy.int32()</code> 进行转换，numpy 的转换函数可以对数组中的每个元素都进行转换，而Python的转换函数只能转换一个元素，如果使用 Python 的转换函数，将导致 <code>only length-1 arrays can be converted to Python scalars</code> 错误。</li>
<li><code>pts = numpy.column_stack((bins,hist))</code> 是将直方图中每个bin的值转成相应的坐标。比如hist[0] =3，…，hist[126] = 178，…，hist[255] = 5；而bins的值为[[0],[1],[2]…,[255]]。使用 <code>np.column_stack</code> 将其组合成[0, 3]、[126, 178]、[255, 5]这样的坐标作为元素组成的数组。</li>
<li><code>cv2.polylines()</code> 函数根据这些点绘制出折线，&lt;/code&gt;False&lt;/code&gt; 参数指出这个折线不需要闭合。第四个参数指定了折线的颜色。</li>
<li><code>h = numpy.flipud(h)</code> 反转绘制好的直方图。因为绘制时，[0,0]在图像的左上角。</li>
</ul>
<h1 id="NumPy的直方图计算"><a href="#NumPy的直方图计算" class="headerlink" title="NumPy的直方图计算"></a>NumPy的直方图计算</h1><p>使用 NumPy 的直方图计算函数 <code>numpy.histogram()</code> 也能实现相同的效果，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">➜  Desktop vim cv.py</div><div class="line">➜  Desktop ls</div><div class="line">import numpy</div><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">h = numpy.zeros((300,256,3))</div><div class="line">bins = numpy.arange(257)</div><div class="line">bin = bins[0:-1]</div><div class="line">color = [(255,0,0),(0,255,0),(0,0,255)]</div><div class="line"></div><div class="line">for ch,color in enumerate(color):</div><div class="line">    item = im[:,:,ch]</div><div class="line">    N,bins = numpy.histogram(item, bins)</div><div class="line">    v = N.max()</div><div class="line">    N = numpy.int32(numpy.around((N*255)/v))</div><div class="line">    N = N.reshape(256,1)</div><div class="line">    pts = numpy.column_stack((bin,N))</div><div class="line">    cv2.polylines(h, [pts], False, color)</div><div class="line">h = numpy.flipud(h)</div><div class="line">cv2.imwrite(&apos;colorhist_np.jpg&apos;, h)</div></pre></td></tr></table></figure>
<p>效果图和上图相同。</p>
<p>通过 NumPy 和 matplotlib 可以更方便的绘制出直方图，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import numpy</div><div class="line">import cv2</div><div class="line">import matplotlib.pyplot as plt</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">bins = numpy.arange(257)</div><div class="line">item = im[:,:,1] # G通道直方图</div><div class="line">hist, bins = numpy.histogram(item, bins)</div><div class="line">width = 0.7*(bins[1]-bins[0])</div><div class="line">center = (bins[:-1]+bins[1:])/2</div><div class="line">plt.bar(center, hist, align=&apos;center&apos;, width=width)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/images/plt.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenCV像素与通道]]></title>
      <url>http://lizonghang.github.io/2016/07/21/OpenCV%E5%83%8F%E7%B4%A0%E4%B8%8E%E9%80%9A%E9%81%93/</url>
      <content type="html"><![CDATA[<h1 id="访问像素"><a href="#访问像素" class="headerlink" title="访问像素"></a>访问像素</h1><p>像素的访问和访问 numpy 中 ndarray 的方法完全一样，灰度图为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">img[j,i] = 255</div></pre></td></tr></table></figure>
<p>其中 j，i 分别表示图像的行和列。对于RGB图像第三个数表示通道，为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img[j,i,0] = 255</div><div class="line">img[j,i,1] = 255</div><div class="line">img[j,i,2] = 255</div></pre></td></tr></table></figure>
<p>下面通过对图像添加人工的椒盐现象来说明 OpenCV 中需要注意的一些问题。</p>
<p>实验图如下：</p>
<p><img src="/images/lena.jpg" alt=""></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy</div><div class="line"></div><div class="line">def salt(img, n):</div><div class="line">    for k in range(n):</div><div class="line">        i = int(numpy.random.random() * img.shape[1])</div><div class="line">        j = int(numpy.random.random() * img.shape[0])</div><div class="line">        if img.ndim == 2:</div><div class="line">            img[j,i] = 255</div><div class="line">        elif img.ndim == 3:</div><div class="line">            img[j,i,0] = 255</div><div class="line">            img[j,i,1] = 255</div><div class="line">            img[j,i,2] = 255</div><div class="line">    return img</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    img = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">    saltImg = salt(img, 1000)</div><div class="line">    cv2.imshow(&apos;SaltImage&apos;, saltImg)</div><div class="line">    cv2.waitKey(0)</div><div class="line">    cv2.destroyAllWindows()</div><div class="line">    cv2.imwrite(&apos;/Users/mac/Desktop/saltImg.jpg&apos;, saltImg)</div></pre></td></tr></table></figure>
<p>处理后能得到类似下面这样带有模拟椒盐现象的图片：</p>
<p><img src="/images/saltImg.jpg" alt=""></p>
<p>需要注意的是：</p>
<ul>
<li>与 C++ 不同，在 Python 中灰度图的 <code>img.ndim = 2</code>，而 C++ 中灰度图图像的通道数 <code>img.channel() = 1</code></li>
<li>这里使用了 numpy 的随机数， Python自身也有一个随机数生成函数。<code>numpy.random</code> 模块中拥有更多的方法，而 Python 自带的 <code>random</code> 只是一个轻量级的模块。不过需要注意的是 <code>numpy.random.seed()</code> 不是线程安全的，而 Python 自带的 <code>random.seed()</code> 是线程安全的。如果使用随机数时需要用到多线程，建议使用 Python 自带的 <code>random()</code> 和 <code>random.seed()，或者构建一个本地的 <code>numpy.random.Random</code> 类的实例。</code></li>
</ul>
<h1 id="分离、合并通道"><a href="#分离、合并通道" class="headerlink" title="分离、合并通道"></a>分离、合并通道</h1><p>由于 OpenCV-Python 和 NumPy 结合的很紧，所以即可使用 OpenCV自带的 <code>split</code>函数，也可以直接操作 Numpy 数组来分离通道。</p>
<h2 id="OpenCV分离通道"><a href="#OpenCV分离通道" class="headerlink" title="OpenCV分离通道"></a>OpenCV分离通道</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r, g, b = cv2.split(im)</div><div class="line">cv2.imshow(&apos;Red&apos;, r)</div><div class="line">cv2.imshow(&apos;Green&apos;, g)</div><div class="line">cv2.imshow(&apos;Blue&apos;, b)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>其中 <code>cv2.split()</code> 返回 RGB 三个通道，如果只想返回其中一个通道，可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">r = cv2.split(im)[0]</div><div class="line">g = cv2.split(im)[1]</div><div class="line">b = cv2.split(im)[2]</div></pre></td></tr></table></figure>
<h2 id="NumPy分离通道"><a href="#NumPy分离通道" class="headerlink" title="NumPy分离通道"></a>NumPy分离通道</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r = numpy.zeros((im.shape[0], im.shape[1]), dtype=im.dtype)</div><div class="line">g = numpy.zeros((im.shape[0], im.shape[1]), dtype=im.dtype)</div><div class="line">b = numpy.zeros((im.shape[0], im.shape[1]), dtype=im.dtype)</div><div class="line">r[:,:] = im[:,:,0]</div><div class="line">g[:,:] = im[:,:,1]</div><div class="line">b[:,:] = im[:,:,2]</div><div class="line">cv2.imshow(&apos;Red&apos;, r)</div><div class="line">cv2.imshow(&apos;Green&apos;, g)</div><div class="line">cv2.imshow(&apos;Blue&apos;, b)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<p>注意先要开辟一个相同大小的图片出来。这是由于 numpy 中数组的复制有三种方式，详见<a href="/2016/07/20/numpy深入探讨/#复制和镜像">NumPy数组复制</a>。</p>
<h1 id="合并通道"><a href="#合并通道" class="headerlink" title="合并通道"></a>合并通道</h1><h2 id="OpenCV合并通道"><a href="#OpenCV合并通道" class="headerlink" title="OpenCV合并通道"></a>OpenCV合并通道</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r,g,b = cv2.split(im)</div><div class="line">mergeImg = cv2.merge([r,g,b])</div><div class="line">cv2.imshow(&apos;merge&apos;, mergeImg)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<h2 id="Numpy合并通道"><a href="#Numpy合并通道" class="headerlink" title="Numpy合并通道"></a>Numpy合并通道</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r,g,b = cv2.split(im)</div><div class="line">merged = numpy.dstack([r,g,b])</div><div class="line">cv2.imshow(&apos;merge&apos;, merged)</div><div class="line">cv2.waitKey(0)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<h2 id="合并效果"><a href="#合并效果" class="headerlink" title="合并效果"></a>合并效果</h2><p>实际使用时建议用 OpenCV 自带的合并函数，在效果上存在一点歧义，有人测试出二者的 <code>strides</code> 属性不同，而实际测出的却相同。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">import numpy</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;)</div><div class="line">r,g,b = cv2.split(im)</div><div class="line">mergedByCV2 = numpy.dstack([r,g,b])</div><div class="line">mergedByNumpy = cv2.merge([r,g,b])</div><div class="line">print &apos;merged by opencv2.0: &apos;, mergedByCV2.strides</div><div class="line">print &apos;merged by numpy: &apos;, mergedByNumpy.strides</div></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">merged by opencv2.0:  (1500, 3, 1)</div><div class="line">merged by numpy:  (1500, 3, 1)</div></pre></td></tr></table></figure>
<p>NumPy 数组的 <code>strides</code> 属性表示的是在每个维数上以字节计算的步长。如下例（int64）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(6)</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([0, 1, 2, 3, 4, 5])</div><div class="line">&gt;&gt;&gt; a.strides</div><div class="line">(8,)</div><div class="line">&gt;&gt;&gt; b = numpy.arange(12).reshape((3,4))</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [ 4,  5,  6,  7],</div><div class="line">       [ 8,  9, 10, 11]])</div><div class="line">&gt;&gt;&gt; b.strides</div><div class="line">(32, 8)</div><div class="line">&gt;&gt;&gt; c = numpy.arange(27).reshape(3,3,3)</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([[[ 0,  1,  2],</div><div class="line">        [ 3,  4,  5],</div><div class="line">        [ 6,  7,  8]],</div><div class="line"></div><div class="line">       [[ 9, 10, 11],</div><div class="line">        [12, 13, 14],</div><div class="line">        [15, 16, 17]],</div><div class="line"></div><div class="line">       [[18, 19, 20],</div><div class="line">        [21, 22, 23],</div><div class="line">        [24, 25, 26]]])</div><div class="line">&gt;&gt;&gt; c.strides</div><div class="line">(72, 24, 8)</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[numpy深入探讨]]></title>
      <url>http://lizonghang.github.io/2016/07/20/numpy%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/</url>
      <content type="html"><![CDATA[<p>前两篇文章对NumPy数组做了基本的介绍，本篇文章对NumPy数组进行较深入的探讨。首先介绍自定义类型的数组，接着数组的组合，最后介绍数组复制方面的问题。</p>
<h1 id="自定义结构数组"><a href="#自定义结构数组" class="headerlink" title="自定义结构数组"></a>自定义结构数组</h1><p>通过 NumPy 也可以定义像 C 语言那样的结构类型。在 NumPy中定义结构的方法如下：</p>
<p>定义结构类型名称；定义字段名称；标明字段数据类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">student = numpy.dtype(&#123;&apos;names&apos;: [&apos;name&apos;, &apos;age&apos;, &apos;weight&apos;], &apos;formats&apos;: [&apos;S32&apos;, &apos;i&apos;, &apos;f&apos;]&#125;, align=True)</div></pre></td></tr></table></figure>
<p>这里 <code>student</code> 是自定义结构类型的名称，使用 <code>dtype()</code> 函数创建，在第一个参数中， <code>‘names’</code> 和 <code>‘formats’</code> 不能改变， <code>names</code>中列出的是结构中的字段名称， <code>formats</code> 中列出的是对应字段的数据类型。<code>S32</code>表示 32 字节长度的字符串， <code>i</code> 表示 32 位的整数， <code>f</code> 表示 32 位长度的浮点数。最后一个参数为 <code>True</code> 时，表示要求进行内存对齐。</p>
<p>字段中使用 NumPy 的字符编码来表示数据类型。更详细的数据类型见下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>字符编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数</td>
<td>i</td>
</tr>
<tr>
<td>无符号整数</td>
<td>u</td>
</tr>
<tr>
<td>单精度浮点数</td>
<td>f</td>
</tr>
<tr>
<td>双精度浮点数</td>
<td>d</td>
</tr>
<tr>
<td>布尔值</td>
<td>b</td>
</tr>
<tr>
<td>复数</td>
<td>D</td>
</tr>
<tr>
<td>字符串</td>
<td>S</td>
</tr>
<tr>
<td>Unicode</td>
<td>U</td>
</tr>
<tr>
<td>Void</td>
<td>V</td>
</tr>
</tbody>
</table>
</div>
<p>在定义好结构类型之后，就可以定义以该类型为元素的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = numpy.array([(&apos;Zhang&apos;, 32, 65.5), (&apos;Wang&apos;, 24, 55.2)], dtype=student)</div></pre></td></tr></table></figure>
<p>除了在每个元素中依次列出对应字段的数据外，还需要在 <code>array</code> 函数中指定对应的数据类型。</p>
<h1 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h1><p>首先创建两个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(9).reshape(3,3)</div><div class="line">&gt;&gt;&gt; b = 2 * a</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[0, 1, 2],</div><div class="line">       [3, 4, 5],</div><div class="line">       [6, 7, 8]])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  2,  4],</div><div class="line">       [ 6,  8, 10],</div><div class="line">       [12, 14, 16]])</div></pre></td></tr></table></figure>
<h2 id="水平组合"><a href="#水平组合" class="headerlink" title="水平组合"></a>水平组合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.hstack((a,b))</div><div class="line">array([[ 0,  1,  2,  0,  2,  4],</div><div class="line">       [ 3,  4,  5,  6,  8, 10],</div><div class="line">       [ 6,  7,  8, 12, 14, 16]])</div></pre></td></tr></table></figure>
<p>也可通过 <code>concatenate</code> 函数并指定相应的轴来获得这一效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.concatenate((a,b), axis=1)</div><div class="line">array([[ 0,  1,  2,  0,  2,  4],</div><div class="line">       [ 3,  4,  5,  6,  8, 10],</div><div class="line">       [ 6,  7,  8, 12, 14, 16]])</div></pre></td></tr></table></figure>
<h2 id="垂直组合"><a href="#垂直组合" class="headerlink" title="垂直组合"></a>垂直组合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.vstack((a,b))</div><div class="line">array([[ 0,  1,  2],</div><div class="line">       [ 3,  4,  5],</div><div class="line">       [ 6,  7,  8],</div><div class="line">       [ 0,  2,  4],</div><div class="line">       [ 6,  8, 10],</div><div class="line">       [12, 14, 16]])</div></pre></td></tr></table></figure>
<p>同样可通过 <code>concatenate</code> 函数并指定相应的轴来获得这一效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.concatenate((a,b), axis=0)</div><div class="line">array([[ 0,  1,  2],</div><div class="line">       [ 3,  4,  5],</div><div class="line">       [ 6,  7,  8],</div><div class="line">       [ 0,  2,  4],</div><div class="line">       [ 6,  8, 10],</div><div class="line">       [12, 14, 16]])</div></pre></td></tr></table></figure>
<h2 id="深度组合"><a href="#深度组合" class="headerlink" title="深度组合"></a>深度组合</h2><p>另外还有深度方面的组合函数 <code>dstack</code>，顾名思义，就是在数组的第三个轴（即深度）上组合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.dstack((a,b))</div><div class="line">array([[[ 0,  0],</div><div class="line">        [ 1,  2],</div><div class="line">        [ 2,  4]],</div><div class="line"></div><div class="line">       [[ 3,  6],</div><div class="line">        [ 4,  8],</div><div class="line">        [ 5, 10]],</div><div class="line"></div><div class="line">       [[ 6, 12],</div><div class="line">        [ 7, 14],</div><div class="line">        [ 8, 16]]])</div></pre></td></tr></table></figure>
<p>仔细观察发现对应的元素都组合成一个新的列表，该列表作为新的数组的元素。</p>
<h2 id="行组合"><a href="#行组合" class="headerlink" title="行组合"></a>行组合</h2><p>行组合可将多个一维数组作为新数组的每一行进行组合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(2)</div><div class="line">&gt;&gt;&gt; b = a + 2</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([0, 1])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([2, 3])</div><div class="line">&gt;&gt;&gt; numpy.row_stack((a,b))</div><div class="line">array([[0, 1],</div><div class="line">       [2, 3]])</div></pre></td></tr></table></figure>
<h2 id="列组合"><a href="#列组合" class="headerlink" title="列组合"></a>列组合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a</div><div class="line">array([0, 1])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([2, 3])</div><div class="line">&gt;&gt;&gt; numpy.column_stack((a,b))</div><div class="line">array([[0, 2],</div><div class="line">       [1, 3]])</div></pre></td></tr></table></figure>
<h1 id="分割数组"><a href="#分割数组" class="headerlink" title="分割数组"></a>分割数组</h1><p>分割数组的函数有 <code>hsplit</code>、<code>vsplit</code>、<code>dsplit</code>、<code>split</code>。可将数组分割成相同大小的子数组，或指定原数组分割的位置。</p>
<h2 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.hsplit(a, 3)</div><div class="line">[array([[0],</div><div class="line">       [3],</div><div class="line">       [6]]), array([[1],</div><div class="line">       [4],</div><div class="line">       [7]]), array([[2],</div><div class="line">       [5],</div><div class="line">       [8]])]</div></pre></td></tr></table></figure>
<p>也可以调用 <code>split</code> 函数并指定 <code>axis=1</code> 来获得这样的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.split(a, 3, axis=1)</div></pre></td></tr></table></figure>
<h2 id="垂直分割"><a href="#垂直分割" class="headerlink" title="垂直分割"></a>垂直分割</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.vsplit(a, 3)</div><div class="line">[array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])]</div></pre></td></tr></table></figure>
<p>也可以调用 <code>split</code> 函数并指定 <code>axis=0</code> 来获得这样的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.split(a, 3, axis=0)</div></pre></td></tr></table></figure>
<h2 id="深度分割"><a href="#深度分割" class="headerlink" title="深度分割"></a>深度分割</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = numpy.arange(27).reshape(3,3,3)</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([[[ 0,  1,  2],</div><div class="line">        [ 3,  4,  5],</div><div class="line">        [ 6,  7,  8]],</div><div class="line"></div><div class="line">       [[ 9, 10, 11],</div><div class="line">        [12, 13, 14],</div><div class="line">        [15, 16, 17]],</div><div class="line"></div><div class="line">       [[18, 19, 20],</div><div class="line">        [21, 22, 23],</div><div class="line">        [24, 25, 26]]])</div><div class="line">&gt;&gt;&gt; numpy.dsplit(c, 3)</div><div class="line">[array([[[ 0],</div><div class="line">        [ 3],</div><div class="line">        [ 6]],</div><div class="line"></div><div class="line">       [[ 9],</div><div class="line">        [12],</div><div class="line">        [15]],</div><div class="line"></div><div class="line">       [[18],</div><div class="line">        [21],</div><div class="line">        [24]]]), array([[[ 1],</div><div class="line">        [ 4],</div><div class="line">        [ 7]],</div><div class="line"></div><div class="line">       [[10],</div><div class="line">        [13],</div><div class="line">        [16]],</div><div class="line"></div><div class="line">       [[19],</div><div class="line">        [22],</div><div class="line">        [25]]]), array([[[ 2],</div><div class="line">        [ 5],</div><div class="line">        [ 8]],</div><div class="line"></div><div class="line">       [[11],</div><div class="line">        [14],</div><div class="line">        [17]],</div><div class="line"></div><div class="line">       [[20],</div><div class="line">        [23],</div><div class="line">        [26]]])]</div></pre></td></tr></table></figure>
<h1 id="复制和镜像"><a href="#复制和镜像" class="headerlink" title="复制和镜像"></a>复制和镜像</h1><p>当运算和处理数组时，它们的数据有时被拷贝到新的数组，有时不是。有三种情况：</p>
<h2 id="完全不复制"><a href="#完全不复制" class="headerlink" title="完全不复制"></a>完全不复制</h2><p>简单的赋值，而不复制数组对象或它们的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(12)</div><div class="line">&gt;&gt;&gt; b = a # 不创建新对象</div><div class="line">&gt;&gt;&gt; b is a</div><div class="line">True</div><div class="line">&gt;&gt;&gt; b.shape = (3,4)</div><div class="line">&gt;&gt;&gt; a.shape</div><div class="line">(3, 4)</div></pre></td></tr></table></figure>
<p>Python 传递不定对象作为参考，所以函数调用不拷贝数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def f(x):</div><div class="line">...     print id(x)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; id(a)</div><div class="line">4560419696</div><div class="line">&gt;&gt;&gt; f(a)</div><div class="line">4560419696</div></pre></td></tr></table></figure>
<h2 id="视图（View）和浅复制"><a href="#视图（View）和浅复制" class="headerlink" title="视图（View）和浅复制"></a>视图（View）和浅复制</h2><p>不同的数组对象分享同一个数据。视图方法创造一个新的数组对象指向同一数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = a.view()</div><div class="line">&gt;&gt;&gt; c is a</div><div class="line">False</div><div class="line">&gt;&gt;&gt; c.base is a </div><div class="line">True</div><div class="line">&gt;&gt;&gt; c.flags.owndata</div><div class="line">False</div><div class="line">&gt;&gt;&gt; c.shape = (2,6) # a的形状不变</div><div class="line">&gt;&gt;&gt; a.shape</div><div class="line">(3, 4)</div><div class="line">&gt;&gt;&gt; c[0,4] = 12 # a的数据改变</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [12,  5,  6,  7],</div><div class="line">       [ 8,  9, 10, 11]])</div></pre></td></tr></table></figure>
<p>切片数组返回它的一个视图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = a[:, 1:3]</div><div class="line">&gt;&gt;&gt; s[:] = 10 # s[:]是s的镜像，共享数据</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 0, 10, 10,  3],</div><div class="line">       [12, 10, 10,  7],</div><div class="line">       [ 8, 10, 10, 11]])</div></pre></td></tr></table></figure>
<h2 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h2><p>完全复制数组和它的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = a.copy()</div><div class="line">&gt;&gt;&gt; d is a</div><div class="line">False</div><div class="line">&gt;&gt;&gt; d.base is a</div><div class="line">False</div><div class="line">&gt;&gt;&gt; d[0,0] = 99</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 0, 10, 10,  3],</div><div class="line">       [12, 10, 10,  7],</div><div class="line">       [ 8, 10, 10, 11]])</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[numpy数组操作]]></title>
      <url>http://lizonghang.github.io/2016/07/20/numpy%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h1 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.array([20,30,40,50])</div><div class="line">&gt;&gt;&gt; b = numpy.arange(4)</div><div class="line">&gt;&gt;&gt; c = a - b</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([20, 29, 38, 47])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([0, 1, 2, 3])</div><div class="line">&gt;&gt;&gt; b**2</div><div class="line">array([0, 1, 4, 9])</div><div class="line">&gt;&gt;&gt; 10*numpy.sin(a)</div><div class="line">array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])</div><div class="line">&gt;&gt;&gt; a &lt; 35</div><div class="line">array([ True,  True, False, False], dtype=bool)</div></pre></td></tr></table></figure>
<p>NumPy 中的乘法运算符按元素逐个计算，矩阵乘法可以使用 dot 函数或创建矩阵对象实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; A = numpy.array([[1,1],[0,1]])</div><div class="line">&gt;&gt;&gt; B = numpy.array([[2,0],[3,4]])</div><div class="line">&gt;&gt;&gt; A*B</div><div class="line">array([[2, 0],</div><div class="line">       [0, 4]])</div><div class="line">&gt;&gt;&gt; numpy.dot(A,B)</div><div class="line">array([[5, 4],</div><div class="line">       [3, 4]])</div></pre></td></tr></table></figure>
<p>当数组中存储的是不同类型的元素时，数组将使用占用更多位的数据类型作为其本身的数据类型，也就是偏向更精确的数据类型，这种行为叫做 upcast：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.ones(3, dtype=numpy.int32)</div><div class="line">&gt;&gt;&gt; b = numpy.linspace(0, numpy.pi, 3)</div><div class="line">&gt;&gt;&gt; b.dtype.name</div><div class="line">&apos;float64&apos;</div><div class="line">&gt;&gt;&gt; c = a + b</div><div class="line">&gt;&gt;&gt; c.dtype.name</div><div class="line">&apos;float64&apos;</div><div class="line">&gt;&gt;&gt; d = numpy.exp(c*1j)</div><div class="line">&gt;&gt;&gt; d.dtype.name</div><div class="line">&apos;complex128&apos;</div></pre></td></tr></table></figure>
<p>许多非数组运算，如计算数组所有元素之和，都作为 ndarray 类的方法来实现，使用时需要用 ndarray 类的实例来调用这些方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.random.random((2,3))</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 0.68091784,  0.41612706,  0.86948767],</div><div class="line">       [ 0.78411139,  0.25901918,  0.6092565 ]])</div><div class="line">&gt;&gt;&gt; a.sum()</div><div class="line">3.6189196384603322</div><div class="line">&gt;&gt;&gt; a.min()</div><div class="line">0.2590191823646294</div><div class="line">&gt;&gt;&gt; a.max()</div><div class="line">0.86948766685829515</div></pre></td></tr></table></figure>
<p>这些运算将数组看作是一维线性列表。但可通过指定 axis 参数（即数组的行）对指定的轴做相应的运算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = numpy.arange(12).reshape(3,4)</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [ 4,  5,  6,  7],</div><div class="line">       [ 8,  9, 10, 11]])</div><div class="line">&gt;&gt;&gt; b.sum(axis=0)</div><div class="line">array([12, 15, 18, 21])</div><div class="line">&gt;&gt;&gt; b.min(axis=1)</div><div class="line">array([0, 4, 8])</div><div class="line">&gt;&gt;&gt; b.cumsum(axis=1)</div><div class="line">array([[ 0,  1,  3,  6],</div><div class="line">       [ 4,  9, 15, 22],</div><div class="line">       [ 8, 17, 27, 38]])</div></pre></td></tr></table></figure>
<h1 id="索引，切片和迭代"><a href="#索引，切片和迭代" class="headerlink" title="索引，切片和迭代"></a>索引，切片和迭代</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(10)**3</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])</div><div class="line">&gt;&gt;&gt; a[2]</div><div class="line">8</div><div class="line">&gt;&gt;&gt; a[2:5]</div><div class="line">array([ 8, 27, 64])</div><div class="line">&gt;&gt;&gt; a[:6:2] = -1000</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([-1000,     1, -1000,    27, -1000,   125,   216,   343,   512,   729])</div><div class="line">&gt;&gt;&gt; a[::-1]</div><div class="line">array([  729,   512,   343,   216,   125, -1000,    27, -1000,     1, -1000])</div></pre></td></tr></table></figure>
<p>多维数组可以每个轴有一个索引，这些索引由一个逗号分割的元组给出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def f(x,y):</div><div class="line">...     return 10*x+y</div><div class="line">...</div><div class="line">&gt;&gt;&gt; b = numpy.fromfunction(f, (5,4), dtype=int)</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line">&gt;&gt;&gt; b[2,3]</div><div class="line">23</div><div class="line">&gt;&gt;&gt; b[0:5,1]</div><div class="line">array([ 1, 11, 21, 31, 41])</div><div class="line">&gt;&gt;&gt; b[:,1]</div><div class="line">array([ 1, 11, 21, 31, 41])</div><div class="line">&gt;&gt;&gt; b[1:3,:]</div><div class="line">array([[10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23]])</div></pre></td></tr></table></figure>
<p>b[i] 中括号中的表达式被当做 i 和一系列 : 来代表剩下的轴。NumPy 允许使用 b[i, …]。’…’代表许多产生一个完整的索引元组必要的分号。如果 x 是秩为 5 的数组，那么：</p>
<ul>
<li>x[1,2,…] 等同于 x[1,2,:,:,:]</li>
<li>x[…,3] 等同于 x[:,:,:,:,3]</li>
<li>x[4,…,5,:] 等同于 x[4,:,:,5,:]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = numpy.arange(12).reshape((3,4))</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [ 4,  5,  6,  7],</div><div class="line">       [ 8,  9, 10, 11]])</div><div class="line">&gt;&gt;&gt; c.shape</div><div class="line">(3, 4)</div><div class="line">&gt;&gt;&gt; c[1,...]</div><div class="line">array([4, 5, 6, 7])</div><div class="line">&gt;&gt;&gt; c[...,2]</div><div class="line">array([ 2,  6, 10])</div></pre></td></tr></table></figure>
<p>如果想对数组中每个元素都进行处理，可以使用 <code>flat</code> 属性，该属性是一个数组元素迭代器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line">&gt;&gt;&gt; for element in b.flat:</div><div class="line">...     print element,</div><div class="line">...</div><div class="line">0 1 2 3 10 11 12 13 20 21 22 23 30 31 32 33 40 41 42 43</div></pre></td></tr></table></figure>
<h1 id="形状操作"><a href="#形状操作" class="headerlink" title="形状操作"></a>形状操作</h1><p>可以用多种方式修改数组的形状：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line">&gt;&gt;&gt; b.shape</div><div class="line">(5, 4)</div><div class="line"></div><div class="line">&gt;&gt;&gt; b.ravel() # 平坦化数组</div><div class="line">array([ 0,  1,  2,  3, 10, 11, 12, 13, 20, 21, 22, 23, 30, 31, 32, 33, 40,</div><div class="line">       41, 42, 43])</div><div class="line"></div><div class="line">&gt;&gt;&gt; b.shape = (10,2)</div><div class="line">&gt;&gt;&gt; b.transpose()</div><div class="line">array([[ 0,  2, 10, 12, 20, 22, 30, 32, 40, 42],</div><div class="line">       [ 1,  3, 11, 13, 21, 23, 31, 33, 41, 43]])</div></pre></td></tr></table></figure>
<p><code>reshape()</code> 函数改变调用数组的形状并返回该数组，而 <code>resize()</code> 函数改变调用数组自身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line"></div><div class="line">&gt;&gt;&gt; b.reshape((2,10))</div><div class="line">array([[ 0,  1,  2,  3, 10, 11, 12, 13, 20, 21],</div><div class="line">       [22, 23, 30, 31, 32, 33, 40, 41, 42, 43]])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line"></div><div class="line">&gt;&gt;&gt; b.resize((2,10))</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3, 10, 11, 12, 13, 20, 21],</div><div class="line">       [22, 23, 30, 31, 32, 33, 40, 41, 42, 43]])</div></pre></td></tr></table></figure>
<p>如果在 <code>reshape()</code> 操作中指定一个维度为 -1，那么其准确维度将根据实际情况计算得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line">&gt;&gt;&gt; b.reshape((4,-1))</div><div class="line">array([[ 0,  1,  2,  3, 10],</div><div class="line">       [11, 12, 13, 20, 21],</div><div class="line">       [22, 23, 30, 31, 32],</div><div class="line">       [33, 40, 41, 42, 43]])</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[numpy数组初探]]></title>
      <url>http://lizonghang.github.io/2016/07/20/numpy%E6%95%B0%E7%BB%84%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<h1 id="NumPy数组"><a href="#NumPy数组" class="headerlink" title="NumPy数组"></a>NumPy数组</h1><p>Numpy 数组是一个多维数组对象，称为 ndarray，由实际的数据和描述这些数据的元数据组成。大部分操作仅针对元数据，而不改变底层实际的数据。</p>
<p>关于 NumPy 数组需要知道：NumPy 数组的下标从 0 开始；同一个 NumPy 数组中的所有元素的类型必须是相同的。</p>
<h1 id="NumPy-数组属性"><a href="#NumPy-数组属性" class="headerlink" title="NumPy 数组属性"></a>NumPy 数组属性</h1><p>NumPy 数组的维数称为秩（rank），每一个线性的数组称为一个轴（axes），秩其实是描述轴的数量。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中的每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴，第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。</p>
<p>NumPy 的数组中比较重要的 ndarray 对象属性有：</p>
<ul>
<li><code>ndarray.ndim</code> - 数组的维数/秩。最常见为二维数组。</li>
<li><code>ndarray.shape</code> - 数组的维度。为一个表示数组在每个维度上大小的整数元组。例如二维数组中，表示数组的“行数”和“列数”。<code>ndarray.shape</code> 返回一个元组，这个元组的长度就是维度的数目，即 <code>ndim</code> 属性。</li>
<li><code>ndarray.size</code> - 数组元素的总个数，等于 <code>shape</code> 属性中元组元素的乘积。</li>
<li><code>ndarray.dtype</code> - 表示数组中元素类型的对象，可使用标准的 Python 类型创建或指定 <code>dtype</code>。</li>
<li><code>ndarray.itemsize</code> - 数组中每个元素的字节大小。例如一个元素类型为 float64 的数组 <code>itemsize</code> 属性值为 8，一个元素类型为 complex32 的数组 <code>itemsize</code> 属性为 4。</li>
<li><code>ndarray.data</code> - 包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</li>
</ul>
<h1 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h1><h2 id="numpy-array"><a href="#numpy-array" class="headerlink" title="numpy.array()"></a>numpy.array()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import numpy</div><div class="line">&gt;&gt;&gt; a = numpy.array([2,3,4])</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([2, 3, 4])</div><div class="line">&gt;&gt;&gt; a.dtype</div><div class="line">dtype(&apos;int64&apos;)</div><div class="line">&gt;&gt;&gt; b = numpy.array([1.2, 3.5, 5.1])</div><div class="line">&gt;&gt;&gt; b.dtype</div><div class="line">dtype(&apos;float64&apos;)</div></pre></td></tr></table></figure>
<p>使用 <code>numpy.array()</code> 函数创建时，参数必须是由方括号括起的列表，而不能使用多个数值作为参数调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.array(1,2,3,4)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: only 2 non-keyword arguments accepted</div></pre></td></tr></table></figure>
<p>可使用双重序列表示二维的数组，三重序列表示三维数组，以此类推：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = numpy.array([(1.5,2,3),(4,5,6)])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 1.5,  2. ,  3. ],</div><div class="line">       [ 4. ,  5. ,  6. ]])</div></pre></td></tr></table></figure>
<p>可以在创建时显式指定数组中元素的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = numpy.array([[1,2],[3,4]], dtype=complex)</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([[ 1.+0.j,  2.+0.j],</div><div class="line">       [ 3.+0.j,  4.+0.j]])</div></pre></td></tr></table></figure>
<h2 id="numpy-zeros-、numpy-ones-、numpy-empty"><a href="#numpy-zeros-、numpy-ones-、numpy-empty" class="headerlink" title="numpy.zeros()、numpy.ones()、numpy.empty()"></a>numpy.zeros()、numpy.ones()、numpy.empty()</h2><p>通常刚开始时数组的元素未知，而数组的大小已知。因此 NumPy 提供了一些使用占位符创建数组的函数。这些函数有助于满足除了数组扩展的需要，同时降低了高昂的运算开销。</p>
<p>用函数 <code>numpy.zeros()</code> 可创建一个全是 0 的数组，用函数 <code>numpy.ones()</code> 可创建一个全为 1 的数组，函数 <code>numpy.empty()</code> 创建一个内容随机并且依赖于内存状态的数组。默认创建的数组类型（dtype）都是 float64。</p>
<p>可以用 <code>d.dtype.itemsize</code> 来查看数组中元素占用的字节数目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = numpy.zeros((3,4))</div><div class="line">&gt;&gt;&gt; d.dtype</div><div class="line">dtype(&apos;float64&apos;)</div><div class="line">&gt;&gt;&gt; d</div><div class="line">array([[ 0.,  0.,  0.,  0.],</div><div class="line">       [ 0.,  0.,  0.,  0.],</div><div class="line">       [ 0.,  0.,  0.,  0.]])</div><div class="line">&gt;&gt;&gt; d.dtype.itemsize</div><div class="line">8</div></pre></td></tr></table></figure>
<p>也可以自己制定数组中元素的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.ones((2,3,4), dtype=numpy.int8)</div><div class="line">array([[[1, 1, 1, 1],</div><div class="line">        [1, 1, 1, 1],</div><div class="line">        [1, 1, 1, 1]],</div><div class="line"></div><div class="line">       [[1, 1, 1, 1],</div><div class="line">        [1, 1, 1, 1],</div><div class="line">        [1, 1, 1, 1]]], dtype=int8)</div><div class="line">&gt;&gt;&gt; numpy.empty((2,3))</div><div class="line">array([[ 0.,  0.,  0.],</div><div class="line">       [ 0.,  0.,  0.]])</div></pre></td></tr></table></figure>
<h2 id="numpy-arange"><a href="#numpy-arange" class="headerlink" title="numpy.arange()"></a>numpy.arange()</h2><p>NumPy 提供一个类似 <code>arange()</code> 的函数返回一个数列形式的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.arange(10,30,5)</div><div class="line">array([10, 15, 20, 25])</div><div class="line">&gt;&gt;&gt; numpy.arange(0,2,0.5)</div><div class="line">array([ 0. ,  0.5,  1. ,  1.5])</div></pre></td></tr></table></figure>
<h2 id="numpy-linspace"><a href="#numpy-linspace" class="headerlink" title="numpy.linspace()"></a>numpy.linspace()</h2><p>当 <code>numpy.arange()</code> 使用浮点数参数时，由于浮点数精度有限，通常无法预测获得的元素个数。因此，最好使用函数 <code>numpy.linspace()</code> 去接收我们想要的元素个数来代替用 <code>range</code> 来指定步长：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.linspace(-1, 0, 5)</div><div class="line">array([-1.  , -0.75, -0.5 , -0.25,  0.  ])</div></pre></td></tr></table></figure>
<p>数组中的元素是通过下标来访问的，可以以切片的形式访问数组中多个元素。</p>
<h1 id="NumPy基本数据类型"><a href="#NumPy基本数据类型" class="headerlink" title="NumPy基本数据类型"></a>NumPy基本数据类型</h1><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>用一个字节存储的布尔类型</td>
<td>True / False</td>
</tr>
<tr>
<td>int8</td>
<td>整数</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>int16</td>
<td>整数</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td>int32</td>
<td>整数</td>
<td>-2^31 ~ 2^31-1</td>
</tr>
<tr>
<td>int64</td>
<td>整数</td>
<td>-2^63 ~ 2^63-1</td>
</tr>
<tr>
<td>uint8</td>
<td>无符号整数</td>
<td>0 ~ 255</td>
</tr>
<tr>
<td>uint16</td>
<td>无符号整数</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td>uint32</td>
<td>无符号整数</td>
<td>0 ~ 2^32-1</td>
</tr>
<tr>
<td>uint64</td>
<td>无符号整数</td>
<td>0 ~ 2^64-1</td>
</tr>
<tr>
<td>float16</td>
<td>半精度浮点数16位</td>
<td>正负号1位，指数5位，精度10位</td>
</tr>
<tr>
<td>float32</td>
<td>单精度浮点数32位</td>
<td>正负号1位，指数8位，精度23位</td>
</tr>
<tr>
<td>float64</td>
<td>双精度浮点数64位</td>
<td>正负号1位，指数11位，精度52位</td>
</tr>
<tr>
<td>float</td>
<td>双精度浮点数64位</td>
<td>正负号1位，指数11位，精度52位</td>
</tr>
<tr>
<td>complex64</td>
<td>复数</td>
<td>分别用两个32位浮点数表示实部和虚部</td>
</tr>
<tr>
<td>complex128</td>
<td>复数</td>
<td>分别用两个64位浮点数表示实部和虚部</td>
</tr>
<tr>
<td>complex</td>
<td>复数</td>
<td>分别用两个64位浮点数表示实部和虚部</td>
</tr>
</tbody>
</table>
</div>
<h2 id="NumPy类型转换"><a href="#NumPy类型转换" class="headerlink" title="NumPy类型转换"></a>NumPy类型转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.float64(42)</div><div class="line">42.0</div><div class="line">&gt;&gt;&gt; numpy.int8(42.0)</div><div class="line">42</div><div class="line">&gt;&gt;&gt; numpy.bool(42)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; numpy.bool(42.0)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; numpy.float(True)</div><div class="line">1.0</div></pre></td></tr></table></figure>
<p>许多函数的参数中可以指定参数的类型，这个类型参数是可选的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.arange(7, dtype=numpy.uint16)</div><div class="line">array([0, 1, 2, 3, 4, 5, 6], dtype=uint16)</div></pre></td></tr></table></figure>
<h1 id="输出数组"><a href="#输出数组" class="headerlink" title="输出数组"></a>输出数组</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = numpy.arange(6)</div><div class="line">&gt;&gt;&gt; print a</div><div class="line">[0 1 2 3 4 5]</div><div class="line"></div><div class="line">&gt;&gt;&gt; b = numpy.arange(12).reshape(4,3)</div><div class="line">&gt;&gt;&gt; print b</div><div class="line">[[ 0  1  2]</div><div class="line"> [ 3  4  5]</div><div class="line"> [ 6  7  8]</div><div class="line"> [ 9 10 11]]</div><div class="line"> </div><div class="line">&gt;&gt;&gt; c = numpy.arange(24).reshape(2,3,4)</div><div class="line">&gt;&gt;&gt; print c</div><div class="line">[[[ 0  1  2  3]</div><div class="line">  [ 4  5  6  7]</div><div class="line">  [ 8  9 10 11]]</div><div class="line"></div><div class="line"> [[12 13 14 15]</div><div class="line">  [16 17 18 19]</div><div class="line">  [20 21 22 23]]]</div></pre></td></tr></table></figure>
<p>如果一个数组太长，则 NumPy 自动省略中间部分而只打印两端的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print numpy.arange(10000)</div><div class="line">[   0    1    2 ..., 9997 9998 9999]</div><div class="line"></div><div class="line">&gt;&gt;&gt; print numpy.arange(10000).reshape(100,100)</div><div class="line">[[   0    1    2 ...,   97   98   99]</div><div class="line"> [ 100  101  102 ...,  197  198  199]</div><div class="line"> [ 200  201  202 ...,  297  298  299]</div><div class="line"> ...,</div><div class="line"> [9700 9701 9702 ..., 9797 9798 9799]</div><div class="line"> [9800 9801 9802 ..., 9897 9898 9899]</div><div class="line"> [9900 9901 9902 ..., 9997 9998 9999]]</div></pre></td></tr></table></figure>
<p>可以通过设置 <code>set_printoptions()</code> 函数来禁用 NumPy 的这种行为并强制打印整个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; numpy.set_printoptions(threshold=&apos;nan&apos;)</div><div class="line">&gt;&gt;&gt; print numpy.arange(10000).reshape(100,100)</div></pre></td></tr></table></figure>
<p>此后输出时数组的所有元素都会显示出来。</p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[socket网络通信——TCP/IP客户和服务器]]></title>
      <url>http://lizonghang.github.io/2016/07/18/socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94TCP-IP%E5%AE%A2%E6%88%B7%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="TCP-IP客户和服务器"><a href="#TCP-IP客户和服务器" class="headerlink" title="TCP/IP客户和服务器"></a>TCP/IP客户和服务器</h1><p>套接字可以配置为一个服务器，监听到来的消息，或者也可以配置为客户，连接到其他应用。TCP/IP 套接字的两端连接后，可以完成双向通信。</p>
<h2 id="回应服务器"><a href="#回应服务器" class="headerlink" title="回应服务器"></a>回应服务器</h2><p>下面的例子接收到来的消息，再回复给发送者。首先创建一个 TCP/IP 套接字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div></pre></td></tr></table></figure>
<p>然后使用 <code>bind()</code> 将这个套接字与服务器地址关联。在这里，地址是 localhost （当前服务器），端口号为 10000：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sock.bind((&apos;localhost&apos;, 10000))</div></pre></td></tr></table></figure>
<p>调用 <code>listen()</code> 将这个套接字置为服务器模式，调用 <code>accept()</code> 等待到来的连接。整数参数是在后台排队的连接数，达到这个连接数后，系统会拒绝连接新用户。该例希望一次只处理一个连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sock.listen(1)</div><div class="line">while True:</div><div class="line">    print &apos;wait for a connection&apos;</div><div class="line">    connection, client_address = sock.accept()</div></pre></td></tr></table></figure>
<p><code>accept()</code> 返回服务器和客户之间的一个打开的连接，并返回客户地址。这个连接实际上是另一个端口上的一个不同的套接字（由内核分配）。数据使用 <code>recv()</code> 从连接读取，并用 <code>sendall()</code> 传输。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">    print &apos;connection from &apos;, client_address</div><div class="line">    while True:</div><div class="line">        data = connection.revc(16)</div><div class="line">        print &apos;received &apos;, data</div><div class="line">        if data:</div><div class="line">            print &apos;sending data back to the client&apos;</div><div class="line">            connection.sendall(data)</div><div class="line">        else:</div><div class="line">            print &apos;no data from &apos;, client_address</div><div class="line">            break</div><div class="line">finally:</div><div class="line">    connection.close()</div></pre></td></tr></table></figure>
<p>与一个客户的通信完成时，需要用 <code>close()</code> 清理这个连接。例子使用 <code>finally</code> 确保 <code>close()</code> 总会被调用，即时出现了一个错误也不例外。</p>
<p>服务器端全部代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">sock.bind((&apos;localhost&apos;, 10000))</div><div class="line">sock.listen(1)</div><div class="line">while True:</div><div class="line">    print &apos;wait for a connection&apos;</div><div class="line">    connection, client_address = sock.accept()</div><div class="line">    try:</div><div class="line">        print &apos;connection from &apos;, client_address</div><div class="line">        while True:</div><div class="line">            data = connection.recv(16)</div><div class="line">            print &apos;received &apos;, data</div><div class="line">            if data:</div><div class="line">                print &apos;sending data back to the client&apos;</div><div class="line">                connection.sendall(data)</div><div class="line">            else:</div><div class="line">                print &apos;no data from &apos;, client_address</div><div class="line">                break</div><div class="line">    finally:</div><div class="line">        connection.close()</div><div class="line">        print &apos;connection closed()&apos;</div></pre></td></tr></table></figure>
<h2 id="回应客户"><a href="#回应客户" class="headerlink" title="回应客户"></a>回应客户</h2><p>与服务器不同，客户程序采用另一种方式建立 socket。它不绑定到一个端口并监听，而是使用 <code>connect()</code> 将套接字直接关联到远程地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">print &apos;connecting to server&apos;</div><div class="line">sock.connect((&apos;localhost&apos;, 10000))</div></pre></td></tr></table></figure>
<p>建立连接后，可以通过 socket 利用 <code>sendall()</code> 发送数据，并用 <code>recv()</code> 接收数据，这和服务器中是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">    message = &apos;abcdefghijklmnopqrstuvwxyz&apos;</div><div class="line">    sock.sendall(message)</div><div class="line">    amount_received = 0</div><div class="line">    amount_expected = len(message)</div><div class="line">    while amount_received &lt; amount_expected:</div><div class="line">        data = sock.recv(16)</div><div class="line">        amount_received += len(data)</div><div class="line">        print &apos;received &apos;, data</div><div class="line">finally:</div><div class="line">    print &apos;socket closed&apos;</div><div class="line">    sock.close()</div></pre></td></tr></table></figure>
<p>发送了整个消息并接收到一个副本时，套接字会关闭，以释放端口。</p>
<p>客户端全部代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">print &apos;connecting to server&apos;</div><div class="line">sock.connect((&apos;localhost&apos;, 10000))</div><div class="line">try:</div><div class="line">    message = &apos;abcdefghijklmnopqrstuvwxyz&apos;</div><div class="line">    sock.sendall(message)</div><div class="line">    amount_received = 0</div><div class="line">    amount_expected = len(message)</div><div class="line">    while amount_received &lt; amount_expected:</div><div class="line">        data = sock.recv(16)</div><div class="line">        amount_received += len(data)</div><div class="line">        print &apos;received &apos;, data</div><div class="line">finally:</div><div class="line">    print &apos;socket closed&apos;</div><div class="line">    sock.close()</div></pre></td></tr></table></figure>
<h2 id="客户与服务器"><a href="#客户与服务器" class="headerlink" title="客户与服务器"></a>客户与服务器</h2><p>要在不同的终端窗口运行客户和服务器，使它们能够相互通信。服务器输出显示了到来的连接和数据，以及发回给客户的响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">wait for a connection</div><div class="line">connection from  (&apos;127.0.0.1&apos;, 50124)</div><div class="line">received  abcdefghijklmnop</div><div class="line">sending data back to the client</div><div class="line">received  qrstuvwxyz</div><div class="line">sending data back to the client</div><div class="line">received</div><div class="line">no data from  (&apos;127.0.0.1&apos;, 50124)</div><div class="line">connection closed()</div><div class="line">wait for a connection</div></pre></td></tr></table></figure>
<p>客户端输出显示了来自服务器的响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">connecting to server</div><div class="line">received  abcdefghijklmnop</div><div class="line">received  qrstuvwxyz</div><div class="line">socket closed</div></pre></td></tr></table></figure>
<h2 id="简易客户连接"><a href="#简易客户连接" class="headerlink" title="简易客户连接"></a>简易客户连接</h2><p>如何使用便利函数 <code>create_connection()</code> 来连接服务器，TCP/IP 客户可以省去几步。这个函数只有一个参数，这是一个包含服务器地址的二值元组，函数将由这个参数推导出用于连接的最佳地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">def get_constants(prefix):</div><div class="line">    return dict((getattr(socket, n), n) for n in dir(socket) if n.startswith(prefix))</div><div class="line"></div><div class="line">families = get_constants(&apos;AF_&apos;)</div><div class="line">types = get_constants(&apos;SOCK_&apos;)</div><div class="line">protocols = get_constants(&apos;IPPROTO_&apos;)</div><div class="line"></div><div class="line">sock = socket.create_connection((&apos;localhost&apos;, 10000))</div><div class="line">print &apos;Family: &apos;, families[sock.family]</div><div class="line">print &apos;Type: &apos;, types[sock.type]</div><div class="line">print &apos;Protocol: &apos;, protocols[sock.proto]</div><div class="line">print</div><div class="line"></div><div class="line">try:</div><div class="line">    message = &apos;This is the message, It will be repeated.&apos;</div><div class="line">    print &apos;sending &quot;%s&quot;&apos; % message</div><div class="line">    sock.sendall(message)</div><div class="line">    amount_received = 0</div><div class="line">    amount_expected = len(message)</div><div class="line">    while amount_received &lt; amount_expected:</div><div class="line">        data = sock.recv(16)</div><div class="line">        amount_received += len(data)</div><div class="line">        print &apos;received &quot;%s&quot;&apos; % data</div><div class="line">finally:</div><div class="line">    sock.close()</div><div class="line">    print &apos;socket closed&apos;</div></pre></td></tr></table></figure>
<p><code>create_connection()</code> 使用 <code>getaddrinfo()</code> 来查找候选连接参数，并返回一个打开的 socket，它的第一个配置可以成功创建一个连接。可以检查 family、type 和 proto 属性确定返回的 socket 类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Family:  AF_INET</div><div class="line">Type:  SOCK_STREAM</div><div class="line">Protocol:  IPPROTO_TCP</div><div class="line"></div><div class="line">sending &quot;This is the message, It will be repeated.&quot;</div><div class="line">received &quot;This is the mess&quot;</div><div class="line">received &quot;age, It will be &quot;</div><div class="line">received &quot;repeated.&quot;</div><div class="line">socket closed</div></pre></td></tr></table></figure>
<h2 id="选择监听地址"><a href="#选择监听地址" class="headerlink" title="选择监听地址"></a>选择监听地址</h2><p>将服务器绑定到正确的地址很重要，这样客户才能与之通信。前面的例子都使用 <code>‘localhost’</code> 作为 IP 地址，这会限制为只能连接在同一服务器上运行的客户。可以使用服务器的一个公共地址，如 <code>gethostname()</code> 返回的值，从而允许其他主机连接。下面的例子修改了回应服务器，让它监听一个指定的地址，例如服务器地址 114.215.121.63 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">server_address = (&apos;114.215.121.63&apos;, 10000)</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">sock.bind(server_address)</div><div class="line">sock.listen(1)</div><div class="line">while True:</div><div class="line">    print &apos;wait for a connection&apos;</div><div class="line">    connection, client_address = sock.accept()</div><div class="line">    try:</div><div class="line">        print &apos;client connected: &apos;, client_address</div><div class="line">        while True:</div><div class="line">            data = connection.recv(16)</div><div class="line">            print &apos;received &apos;, data</div><div class="line">            if data:</div><div class="line">                connection.sendall(data)</div><div class="line">            else:</div><div class="line">                break</div><div class="line">    finally:</div><div class="line">        connection.close()</div></pre></td></tr></table></figure>
<p>测试之前，需要对客户程序做类似的修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">server_address = (&apos;114.215.121.63&apos;, 10000)</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">print &apos;connecting to server&apos;</div><div class="line">sock.connect(server_address)</div><div class="line">try:</div><div class="line">    message = &apos;This is the message, it will be repeat later.&apos;</div><div class="line">    print &apos;sending &quot;%s&quot;&apos; % message</div><div class="line">    sock.sendall(message)</div><div class="line">    amount_received = 0</div><div class="line">    amount_expected = len(message)</div><div class="line">    while amount_received &lt; amount_expected:</div><div class="line">        data = sock.recv(16)</div><div class="line">        amount_received += len(data)</div><div class="line">        print &apos;received &apos;, data</div><div class="line">finally:</div><div class="line">    print &apos;socket closed&apos;</div><div class="line">    sock.close()</div></pre></td></tr></table></figure>
<p>在服务器 114.215.121.63 上启动服务器程序，监听端口 10000。在另一个主机上运行客户端程序，会产生以下结果：</p>
<p>服务器端输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wait for a connection</div><div class="line">client connected:  (&apos;171.212.168.187&apos;, 50688)</div><div class="line">received  This is the mess</div><div class="line">received  age, it will be</div><div class="line">received  repeat later.</div><div class="line">received</div><div class="line">wait for a connection</div></pre></td></tr></table></figure>
<p>客户端输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">connecting to server</div><div class="line">sending &quot;This is the message, it will be repeat later.&quot;</div><div class="line">received  This is the mess</div><div class="line">received  age, it will be</div><div class="line">received  repeat later.</div><div class="line">socket closed</div></pre></td></tr></table></figure>
<p>很多服务器有不止一个网络接口，相应的会有不止一个 IP 地址。并不需要运行服务的不同副本分别绑定到各个 IP 地址，可以使用一个特殊的地址 <code>INADDR_ANY</code> 同时监听所有地址。socket 为 <code>INADDR_ANY</code> 定义了一个常量，这是一个整数值，但在传递到 <code>bind()</code> 之前必须将它转换为采用点记法的地址字符串。作为一种快捷方式，可以使用 ‘0.0.0.0’ 或者空串，而不是完成转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server_address = (&apos;&apos;, 10000)</div></pre></td></tr></table></figure>
<p>要看一个套接字使用的具体地址，可以调用其 <code>getsockname()</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">server_address = (&apos;&apos;, 10000)</div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">sock.bind(server_address)</div><div class="line">print &apos;starting up on %s, port %s&apos; % sock.getsockname()</div></pre></td></tr></table></figure>
<p>输出的套接字使用的具体地址如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">starting up on 0.0.0.0, port 10000</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 网络通信 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[图像载入、显示、复制、新建和保存]]></title>
      <url>http://lizonghang.github.io/2016/07/17/OpenCV-Python%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>OpenCV的全称是Open Source Computer Vision Library，是一个跨平台的计算机视觉库。OpenCV可用于开发实时的图像处理、计算机视觉以及模式识别程序。OpenCV可用于解决如下领域的问题：</p>
<ul>
<li>人机交互</li>
<li>物体识别</li>
<li>图像分区</li>
<li>人脸识别</li>
<li>动作识别</li>
<li>运动跟踪</li>
<li>机器人</li>
</ul>
<p>OpenCV可以在Windows, Android, Maemo, FreeBSD, OpenBSD, iOS, Linux和Mac OS等平台上运行。</p>
<p>OpenCV1.0时代的基于 C 语言接口而建的图像存储格式IplImage*，如果在退出前忘记release掉的话，就会照成内存泄露。这导致debug时越来越多的纠缠于内存管理，而不是着力解决开发目标。但自从OpenCV踏入2.0时代用Mat类数据结构作为主打之后，OpenCV变得越发像Matlab那样，上手非常快。甚至有些函数名称都和matlab一样，比如大家所熟知的imread，imwrite，imshow等函数。</p>
<p><code>cv::Mat</code>类是用于保存图像以及其他矩阵数据的数据结构。默认情况下，其尺寸为0，我们也可以指定初始尺寸,比如定义一个Mat类对象，就要写<code>cv::Mat pic(320,640,cv::Scalar(100));</code>。它是对应于OpenCV1.0时代的IplImage的主要用来存放图像的数据结构。</p>
<h1 id="读取并显示图像"><a href="#读取并显示图像" class="headerlink" title="读取并显示图像"></a>读取并显示图像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"></div><div class="line">im = cv2.imread(&apos;lena.jpg&apos;) # 读取文件</div><div class="line">cv2.namedWindow(&apos;lena&apos;) # 创建窗口</div><div class="line">cv2.imshow(&apos;lena&apos;, im) # 在窗口显示图像</div><div class="line"># cv2.waitKey(10000) # 等待10s</div><div class="line">cv2.waitKey(0) # 保持等待直到按下任意键</div><div class="line">cv2.destroyAllWindows() # 释放窗口</div></pre></td></tr></table></figure>
<h1 id="创建-复制图像"><a href="#创建-复制图像" class="headerlink" title="创建/复制图像"></a>创建/复制图像</h1><p>新的OpenCV的接口中没有CreateImage接口，如果要创建图像，需要使用numpy的函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">emptyImage = numpy.zeros(im.shape, numpy.uint8)</div></pre></td></tr></table></figure>
<p>图像使用NumPy数组的属性来表示图像的尺寸和通道信息。如果输出im.shape，将得到(750, 500, 3)，最后的3表示这是一个RGB图像。</p>
<p>也可以复制原图像得到新图像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tempImage = im.copy()</div></pre></td></tr></table></figure>
<p>还可以用cvtColor获得原图像的副本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tempImage = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)  </div><div class="line">tempImage[...] = 0 # 转成空白的黑色图像</div></pre></td></tr></table></figure>
<h1 id="保存图像"><a href="#保存图像" class="headerlink" title="保存图像"></a>保存图像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.imwrite(&apos;/Users/mac/Desktop/temp.jpg&apos;, tempImage)</div></pre></td></tr></table></figure>
<p>imwrite()有第三个可选参数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.imwrite(&apos;/Users/mac/Desktop/temp.jpg&apos;, tempImage, [int(cv2.IMWRITE_JPEG_QUALITY), 5])</div></pre></td></tr></table></figure>
<p>第三个参数针对特定的格式：</p>
<ul>
<li>对于JPEG，第三个参数表示的是图像的质量，用0-100的整数表示，默认为95。<code>cv2.IMWRITE_JPEG_QUALITY</code>类型为Long，必须转换成int。下面是以不同质量存储的两幅图：</li>
</ul>
<p>图像质量保存为5时：</p>
<p><img src="/images/temp_5.jpg" alt=""></p>
<p>图像质量保存为100时：</p>
<p><img src="/images/temp_100.jpg" alt=""></p>
<ul>
<li>对于PNG，第三个参数表示的是压缩级别。cv2.IMWRITE_PNG_COMPRESSION，从0到9,压缩级别越高，图像尺寸越小。默认级别为3：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cv2.imwrite(&quot;temp0.png&quot;, tempImage, [int(cv2.IMWRITE_PNG_COMPRESSION), 0])   </div><div class="line">cv2.imwrite(&quot;temp9.png&quot;, tempImage, [int(cv2.IMWRITE_PNG_COMPRESSION), 9])</div></pre></td></tr></table></figure>
<p>得到的图片存储大小分别为929KB和317KB</p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac上安装python-opencv]]></title>
      <url>http://lizonghang.github.io/2016/07/16/Mac%E4%B8%8A%E5%AE%89%E8%A3%85python-opencv/</url>
      <content type="html"><![CDATA[<p>如何正确安装OpenCV历来是一个堪称玄学的问题，在成功安装OpenCV的道路上经历了种种艰辛，这真的是我最恶心的一次安装经历。下载源码并编译的方法就不说了，下面介绍较简易的使用Homebrew安装的方法。</p>
<p>第一步：安装OpenCV</p>
<p>直接使用命令<code>brew install opencv</code>是不行的，因为homebrew找不到它，会产生如下报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">➜  ~ brew install opencv</div><div class="line">Error: No available formula with the name &quot;opencv&quot;</div><div class="line">==&gt; Searching for similarly named formulae...</div><div class="line">Error: No similarly named formulae found.</div><div class="line">==&gt; Searching taps...</div><div class="line">These formulae were found in taps:</div><div class="line">homebrew/science/opencv                  homebrew/science/opencv3</div><div class="line">To install one of them, run (for example):</div><div class="line">  brew install homebrew/science/opencv</div><div class="line">==&gt; You haven&apos;t updated Homebrew in a while.</div><div class="line">A formula for opencv might have been added recently.</div><div class="line">Run `brew update` to get the latest Homebrew updates!</div></pre></td></tr></table></figure>
<p>你需要先将opencv所在的science分类加入homebrew的搜索列表中再尝试下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ brew tap homebrew/science</div><div class="line">$ brew install opencv</div></pre></td></tr></table></figure>
<p>请留意安装过程中的输出信息，最好保存一下，之后可能有用，确保opencv正确安装后就可以删掉了。</p>
<p>安装过程中自动为你安装好了以下库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">==&gt; Installing dependencies for homebrew/science/opencv: eigen, ilmbase,</div><div class="line">==&gt; Installing homebrew/science/opencv dependency: eigen</div><div class="line">🍺  /usr/local/Cellar/eigen/3.2.8: 368 files, 3.5M</div><div class="line">==&gt; Installing homebrew/science/opencv dependency: ilmbase</div><div class="line">🍺  /usr/local/Cellar/ilmbase/2.2.0: 362 files, 5.6M</div><div class="line">==&gt; Installing homebrew/science/opencv dependency: openexr</div><div class="line">🍺  /usr/local/Cellar/openexr/2.2.0: 131 files, 11.4M</div><div class="line">==&gt; Installing homebrew/science/opencv dependency: homebrew/python/numpy</div><div class="line">🍺  /usr/local/Cellar/numpy/1.11.1: 430 files, 9M</div><div class="line">==&gt; Installing homebrew/science/opencv</div><div class="line">🍺  /usr/local/Cellar/opencv/2.4.13: 276 files, 35.8M</div></pre></td></tr></table></figure>
<p>其中已为你安装好numpy，其版本为1.11.1，如果你此前已经通过pip安装过numpy了，那需要很多额外步骤。</p>
<p>进入python环境，测试opencv是否正确安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import cv2</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ImportError: No module named cv2</div></pre></td></tr></table></figure>
<p>python找不到opencv，这就蛋疼了。翻看opencv的安装记录，有如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Python modules have been installed and Homebrew&apos;s site-packages is not</div><div class="line">in your Python sys.path, so you will not be able to import the modules</div><div class="line">this formula installed. If you plan to develop with these modules,</div><div class="line">please run:</div><div class="line">  mkdir -p /Users/mac/Library/Python/2.7/lib/python/site-packages</div><div class="line">  echo &apos;import site; site.addsitedir(&quot;/usr/local/lib/python2.7/site-packages&quot;)&apos; &gt;&gt; /Users/mac/Library/Python/2.7/lib/python/site-packages/homebrew.pth</div></pre></td></tr></table></figure>
<p>Homebrew的site-packages不在python的sys.path路径中，所以python无法导入安装好的opencv模块，如果想要python能够找到，执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir -p /Users/mac/Library/Python/2.7/lib/python/site-packages</div><div class="line">$ echo &apos;import site; site.addsitedir(&quot;/usr/local/lib/python2.7/site-packages&quot;)&apos; &gt;&gt; /Users/mac/Library/Python/2.7/lib/python/site-packages/homebrew.pth</div></pre></td></tr></table></figure>
<p>再尝试<code>import cv2</code>，可能会有如下报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RuntimeError: module compiled against API version 0xa but this version of numpy is 0x9</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ImportError: numpy.core.multiarray failed to import</div></pre></td></tr></table></figure>
<p>这是由于numpy版本过低导致的，可能是你系统中已经安装的numpy版本不能满足opencv的需求。并且没有提示找不到模块，所以python能正确找到opencv了。尝试<code>sudo pip uninstall numpy</code>，可能会有下面的报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Exception:</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/basecommand.py&quot;, line 215, in main</div><div class="line">    status = self.run(options, args)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/commands/uninstall.py&quot;, line 76, in run</div><div class="line">    requirement_set.uninstall(auto_confirm=options.yes)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/req/req_set.py&quot;, line 336, in uninstall</div><div class="line">    req.uninstall(auto_confirm=auto_confirm)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/req/req_install.py&quot;, line 742, in uninstall</div><div class="line">    paths_to_remove.remove(auto_confirm)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/req/req_uninstall.py&quot;, line 115, in remove</div><div class="line">    renames(path, new_path)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pip/utils/__init__.py&quot;, line 267, in renames</div><div class="line">    shutil.move(old, new)</div><div class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 302, in move</div><div class="line">    copy2(src, real_dst)</div><div class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 131, in copy2</div><div class="line">    copystat(src, dst)</div><div class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 103, in copystat</div><div class="line">    os.chflags(dst, st.st_flags)</div><div class="line">OSError: [Errno 1] Operation not permitted: &apos;/tmp/pip-8Z9Jmh-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy-1.8.0rc1-py2.7.egg-info&apos;</div><div class="line">The directory &apos;/Users/mac/Library/Caches/pip/http&apos; or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo&apos;s -H flag.</div></pre></td></tr></table></figure>
<p>并且，在使用<code>sudo pip install matplotlib</code>时也有类似的报错。可以改成<code>sudo pip install --ignore-installed matplotlib</code>试试。</p>
<p>这是由于System Integrity Protection导致的，需要关闭保护SIP，否则即时加了sudo也没用，尝试卸载和升级都需要关闭保护SIP。后面会介绍一种更简单的方法，这一段可略过。具体操作如下：</p>
<ol>
<li>重启电脑，电脑启动的时候按住command+R</li>
<li>等画面上显示苹果logo后会看到[OS X 工具程式]窗口，选择终端，要把键盘按下去，不要轻按</li>
<li>终端打开后输入<code>csrutil disable</code>，之后重启</li>
</ol>
<p>重启之后再升级或重装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install --upgrade numpy</div></pre></td></tr></table></figure>
<p>另一种更简单的方式和安装opencv时一样隐藏在安装信息中，就在opencv路径信息的上一段里，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &apos;import sys; sys.path.insert(1, &quot;/usr/local/lib/python2.7/site-packages&quot;)&apos; &gt;&gt; /Users/mac/Library/Python/2.7/lib/python/site-packages/homebrew.pth</div></pre></td></tr></table></figure>
<p>由于<code>mkdir -p /Users/mac/Library/Python/2.7/lib/python/site-packages</code>之前已经创建过了，可以不再创建。执行完命令后，重启一下终端，再进入python环境测试是否能正确导入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import cv2</div><div class="line">&gt;&gt;&gt; import numpy</div><div class="line">&gt;&gt;&gt; from matplotlib import pyplot</div></pre></td></tr></table></figure>
<p>本机异常已消除，若还有其他异常，请另行寻找解决方法。以下是本机安装的版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print cv2.__version__</div><div class="line">2.4.13</div><div class="line">&gt;&gt;&gt; print numpy.__version__</div><div class="line">1.11.1</div><div class="line">&gt;&gt;&gt; print matplotlib.__version__</div><div class="line">1.3.1</div></pre></td></tr></table></figure>
<p>希望这篇文章能帮助你脱离玄学的道路。</p>
]]></content>
      
        <categories>
            
            <category> Python-OpenCV </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[儿童锁屏幕监测报警]]></title>
      <url>http://lizonghang.github.io/2016/07/15/%E5%84%BF%E7%AB%A5%E9%94%81%E5%B1%8F%E5%B9%95%E7%9B%91%E6%B5%8B%E6%8A%A5%E8%AD%A6/</url>
      <content type="html"><![CDATA[<p>这是一个丧尽天良的程序，用于家长对孩子使用电脑时的监控，当程序发现屏幕上出现了疑似色情的图片/视频时，将屏幕进行截图保存并邮件通知家长，也能判断出程序是否正常退出。可以设置采样间隔与监控时间，可以设置截图保存路径与图片尺寸。</p>
<p>假设文件名为ScreenScrape.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># encoding: utf-8</div><div class="line">from PIL import Image, ImageGrab</div><div class="line">import time</div><div class="line">import argparse</div><div class="line">import smtplib</div><div class="line">from email import encoders</div><div class="line">from email.header import Header</div><div class="line">from email.mime.text import MIMEText</div><div class="line">from email.utils import parseaddr, formataddr</div><div class="line"></div><div class="line">parser = argparse.ArgumentParser()</div><div class="line">parser.add_argument(&apos;p&apos;, help=&apos;Path to Save the Images.&apos;)</div><div class="line">parser.add_argument(&apos;-W&apos;, help=&apos;Width of the Scraped Images&apos;, default=1000)</div><div class="line">parser.add_argument(&apos;-H&apos;, help=&apos;Height of the Scraped Images.&apos;, default=600)</div><div class="line">parser.add_argument(&apos;-d&apos;, help=&apos;Scrape Duration(Minute).&apos;, default=1)</div><div class="line">parser.add_argument(&apos;-t&apos;, help=&apos;Total Scrape Time(Minute)&apos;, default=30)</div><div class="line">args = parser.parse_args()</div><div class="line"># 图片存放路径、图片尺寸、检测间隔、检测时长</div><div class="line">path, width, height, duration, totalTime = args.p, int(args.W), int(args.H), float(args.d), float(args.t)</div><div class="line"></div><div class="line">message = u&apos;屏幕检测到异常截图，请及时查看您的电脑&apos;</div><div class="line">fromUser = &apos;user_to_send_email&apos;</div><div class="line">password = &apos;vaelgxgnybtlbafd&apos; # 开启SMTP/POP3等，获得的校验码为密码，不是登陆密码</div><div class="line">toUser = &apos;user_to_receive_email&apos;</div><div class="line">smtp_server = &apos;smtp.qq.com&apos; # 可以是其他邮件代理服务器</div><div class="line"></div><div class="line">send_once = False # 只发送一次邮件</div><div class="line"></div><div class="line">start_time = int(time.time())</div><div class="line">def inTotalTime():</div><div class="line">    &apos;&apos;&apos;判断检测时间是否到时，上限时间totalTime&apos;&apos;&apos;</div><div class="line">    now_time = int(time.time())</div><div class="line">    elapseTimeByMinutes = (now_time - start_time) / 60.0</div><div class="line">    if elapseTimeByMinutes &lt; totalTime:</div><div class="line">        return True</div><div class="line">    else:</div><div class="line">        return False</div><div class="line"></div><div class="line">def _format_addr(s):</div><div class="line">    &apos;&apos;&apos;调整邮件信息格式&apos;&apos;&apos;</div><div class="line">    name, addr = parseaddr(s)</div><div class="line">    return formataddr((Header(name, &apos;utf-8&apos;).encode(), addr.encode(&apos;utf-8&apos;) if isinstance(addr, unicode) else addr))</div><div class="line"></div><div class="line">def sendMessage(message, fromUser, password, toUser, smtp_server):</div><div class="line">    &apos;&apos;&apos;发送邮件&apos;&apos;&apos;</div><div class="line">    msg = MIMEText(message, &apos;plain&apos;, &apos;utf-8&apos;)</div><div class="line">    # 下面三项不标明可能被当作垃圾邮件，导致接收方收不到邮件</div><div class="line">    msg[&apos;From&apos;] = _format_addr(u&apos;Mac管理员-%s&apos; % fromUser) # 邮件中标明发件人</div><div class="line">    msg[&apos;To&apos;] = _format_addr(u&apos;家长-%s&apos; % toUser) # 邮件中标明收件人</div><div class="line">    msg[&apos;Subject&apos;] = Header(u&apos;屏幕监测报告&apos;, &apos;utf-8&apos;).encode() # 邮件标题</div><div class="line">    server = smtplib.SMTP_SSL(smtp_server, 465)</div><div class="line">    # server.set_debuglevel(1) # 发送邮件过程中的详细信息</div><div class="line">    server.login(fromUser, password)</div><div class="line">    server.sendmail(fromUser, toUser, msg.as_string())</div><div class="line">    server.quit()</div><div class="line"></div><div class="line">def handleRudeImage(im):</div><div class="line">    &apos;&apos;&apos;保存截图并发送邮件通知&apos;&apos;&apos;</div><div class="line">    filename = str(int(time.time())) + &apos;.jpg&apos;</div><div class="line">    im.save(path+filename, &apos;JPEG&apos;)</div><div class="line">    global send_once</div><div class="line">    if not send_once:</div><div class="line">        sendMessage(message, fromUser, password, toUser, smtp_server)</div><div class="line">        send_once = True</div><div class="line"></div><div class="line">def screenScrape():</div><div class="line">    &apos;&apos;&apos;屏幕截取、鉴黄与处置&apos;&apos;&apos;</div><div class="line">    im = ImageGrab.grab().resize((width, height)).convert(&apos;YCbCr&apos;)</div><div class="line">    w, h = im.size</div><div class="line">    sx = im.getdata()</div><div class="line">    count = 0</div><div class="line">    for i, ycbcr in enumerate(sx):</div><div class="line">        y, cb, cr = ycbcr</div><div class="line">        if 86 &lt;= cb &lt;= 117 and 140 &lt;= cr &lt;= 168:</div><div class="line">            count += 1</div><div class="line">    if count &gt; w * h * 0.3:</div><div class="line">        handleRudeImage(im)</div><div class="line">#        print &apos;Sexy Playing&apos;</div><div class="line">#    else:</div><div class="line">#        print &apos;Normal&apos;</div><div class="line">    im.close()</div><div class="line"></div><div class="line">while inTotalTime():</div><div class="line">    time.sleep(duration*60) # 间隔duration分钟对屏幕采样</div><div class="line">    screenScrape()</div><div class="line"></div><div class="line"># 程序正常退出提醒</div><div class="line">sendMessage(u&apos;监控程序正常退出&apos;, fromUser, password, toUser, smtp_server)</div></pre></td></tr></table></figure>
<p>运行程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python ScreenScrape.py path [-W Width] [-H Height] [-d duration] [-t totalTime]</div></pre></td></tr></table></figure>
<ul>
<li>path - 存放截图的文件夹，必选</li>
<li>Width - 存储截图时的截图宽度，可选</li>
<li>Height - 存储截图时的截图高度，可选</li>
<li>duration - 采样周期，单位min，可选</li>
<li>totalTime - 监控时长，单位min，可选</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[多张图片合成GIF图]]></title>
      <url>http://lizonghang.github.io/2016/07/14/%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90GIF%E5%9B%BE/</url>
      <content type="html"><![CDATA[<h1 id="需要的库"><a href="#需要的库" class="headerlink" title="需要的库"></a>需要的库</h1><h2 id="PIL"><a href="#PIL" class="headerlink" title="PIL"></a>PIL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install Pillow</div></pre></td></tr></table></figure>
<h2 id="images2gif"><a href="#images2gif" class="headerlink" title="images2gif"></a>images2gif</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install images2gif</div></pre></td></tr></table></figure>
<h1 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h1><p>将以下gif图分割为多张静态PNG格式图，并以这些PNG图为例：</p>
<p><img src="/images/niko.gif" alt=""></p>
<h1 id="帧分割"><a href="#帧分割" class="headerlink" title="帧分割"></a>帧分割</h1><p>由于需要将图片按顺序进行合成，需要将图片在文件夹中顺序排列。假设文件名为split.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line"></div><div class="line">im = Image.open(&apos;niko.gif&apos;)</div><div class="line">im.seek(0)</div><div class="line"></div><div class="line">try:</div><div class="line">    while True:</div><div class="line">        im.save(&apos;./nikos/&apos; + chr(im.tell() + ord(&apos;a&apos;))  + &apos;.png&apos;, &apos;PNG&apos;)</div><div class="line">        im.seek(im.tell()+1)</div><div class="line">except EOFError, msg:</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>执行分割GIF图程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python split.py</div></pre></td></tr></table></figure>
<p>将得到的图片放置于nikos/文件夹中</p>
<h1 id="帧合成"><a href="#帧合成" class="headerlink" title="帧合成"></a>帧合成</h1><p>假设文件名为GetGifAnimation.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">#encoding: utf-8</div><div class="line">from PIL import Image</div><div class="line">import os</div><div class="line">import images2gif</div><div class="line">import argparse</div><div class="line"></div><div class="line">parser = argparse.ArgumentParser()</div><div class="line">parser.add_argument(&apos;image_path&apos;, help=&apos;The Path to Source Images, to Create the Gif Animation.&apos;)</div><div class="line">parser.add_argument(&apos;-T&apos;, help=&apos;Target to Save the Gif&apos;, default=&apos;./generate.gif&apos;)</div><div class="line">parser.add_argument(&apos;-W&apos;, help=&apos;Width of the Gif&apos;, default=300)</div><div class="line">parser.add_argument(&apos;-H&apos;, help=&apos;Height of the Gif&apos;, default=281)</div><div class="line">args = parser.parse_args()</div><div class="line">srcImageFilePath = args.image_path</div><div class="line">if srcImageFilePath.split(&apos;/&apos;)[-1]:</div><div class="line">    srcImageFilePath += &apos;/&apos;</div><div class="line">targetGIFPath = args.T</div><div class="line">targetGIFWidth = args.W</div><div class="line">targetGIFHeight = args.H</div><div class="line">targetSize = (targetGIFWidth, targetGIFHeight)</div><div class="line"></div><div class="line">def GetGifAnimationFromImages(srcImageFilePath):</div><div class="line">    images = []</div><div class="line">    for item in os.listdir(srcImageFilePath):</div><div class="line">        suffix = item.split(&apos;.&apos;)[-1]</div><div class="line">        if suffix == &apos;png&apos;:</div><div class="line">            images.append(Image.open(srcImageFilePath + item).resize(targetSize))</div><div class="line">    images2gif.writeGif(targetGIFPath, images, duration=0.1, nq=0.1)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    GetGifAnimationFromImages(srcImageFilePath)</div></pre></td></tr></table></figure>
<h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python GetGifAnimation.py &lt;path-to-images&gt; [-T targetGIFPath] [-W targetGIFWidth] [-H targetGIFHeight]</div></pre></td></tr></table></figure>
<p>合成的gif图为generate.gif</p>
<h1 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h1><h2 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;images2gif.py&quot;, line 436, in writeGifToFile</div><div class="line">  fp.write(globalPalette)</div><div class="line">TypeError: must be string or buffer, not None</div></pre></td></tr></table></figure>
<p>将images2gif.py文件中的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for im in images:</div><div class="line">    palettes.append( getheader(im)[1] )</div></pre></td></tr></table></figure>
<p>更改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for im in images:</div><div class="line">    palettes.append(im.palette.getdata()[1])</div></pre></td></tr></table></figure>
<h2 id="ValueError"><a href="#ValueError" class="headerlink" title="ValueError"></a>ValueError</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;./GetGifAnimation.py&quot;, line 31, in &lt;module&gt;</div><div class="line">    GetGifAnimationFromImages(srcImageFilePath)</div><div class="line">  File &quot;./GetGifAnimation.py&quot;, line 28, in GetGifAnimationFromImages</div><div class="line">    images2gif.writeGif(targetGIFPath, images, duration=0.1, nq=0.1)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/images2gif/images2gif.py&quot;, line 572, in writeGif</div><div class="line">    images, xy, images_info = gifWriter.handleSubRectangles(images, subRectangles)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/images2gif/images2gif.py&quot;, line 295, in handleSubRectangles</div><div class="line">    images, xy = self.getSubRectangles(images)</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/images2gif/images2gif.py&quot;, line 332, in getSubRectangles</div><div class="line">    diff = np.abs(im-prev)</div><div class="line">ValueError: operands could not be broadcast together with shapes (281,300,4) (281,300,3)</div></pre></td></tr></table></figure>
<p>错误的原因是存在png图片（a.png）不含有alpha通道，可能是分割GIF图时PIL库中代码导致透明通道丢失。可以手动将图片导出为带alpha通道的PNG图片，ValueError即解除。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[socket网络通信——寻址、协议簇和套接字类型]]></title>
      <url>http://lizonghang.github.io/2016/07/14/socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94%E5%AF%BB%E5%9D%80%E3%80%81%E5%8D%8F%E8%AE%AE%E7%B0%87%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;socket模块提供了一个底层C API，可以使用BSD套接字接口实现网络通信。它包括socket类，用于处理具体的数据通道，还包括用于完成网络相关任务的函数，如将一个服务器名称转换为一个地址，以及格式化数据以便在网络上发送。</p>
<h1 id="寻址、协议簇和套接字类型"><a href="#寻址、协议簇和套接字类型" class="headerlink" title="寻址、协议簇和套接字类型"></a>寻址、协议簇和套接字类型</h1><p>&emsp;&emsp;套接字（socket）是程序在本地或者通过互联网来回传递数据时所用通信通道的一个端点。套接字有两个主要属性来控制如何发送数据：地址簇（address family）控制所用的OSI网络层协议，套接字类型（socket type）控制传输层协议。</p>
<p>&emsp;&emsp;Python支持3个地址簇。最常用的是AF_INET，用于IPv4 Internet寻址。IPv4地址长度为4个字节，通常表示为4个数的序列，每个字节对应一个数，用点号分隔（如10.1.1.5和127.0.0.1）。这些值通常被称为“IP地址”。目前几乎所有互联网网络应用都使用IPv4.</p>
<p>&emsp;&emsp;AF_INET6用于IPv6 Internet寻址。IPv6是下一代Internet协议。它支持128位地址和通信流调整，还支持IPv4所不支持的一些路由特性。目前采用IPv6的应用还很有限，不过在不断增长。</p>
<p>&emsp;&emsp;AF_UNIX是UNIX域套接字（UNIX Domain Sockets， UDS）的地址簇，这是一种POSIX兼容系统上的进程间通信协议。UDS的实现通常允许操作系统直接从进程向进程传递数据，而不用通过网络栈。这比使用AF_INET更高效，但是由于要用文件系统作为寻址的命名空间，UDS仅限于同一个系统上的进程。相比其他IPC机制（如命名管道或共享内存），使用UDS的优势在于它与IP网络应用的编程接口是一样的。这说明应用在单个主机上运行时可以利用高效的通信，在网络上发送数据时仍然可以使用同样的代码。</p>
<pre>注意：AF_UNIX常量仅在支持UDS的系统上定义。</pre>

<p>&emsp;&emsp;套接字类型往往是SOCK_DGRAM或SOCK_STREAM，SOCK_DGRAM对应用户数据报协议（user datagram protocol，UDP），SOCK_STREAM对应传输控制协议（transmission control protocol，TCP）。UDP不需要传输握手过程或其他设置过程（setup），但是提供的传输可靠性较低。UDP消息可能乱序传送，也可能传送多次，或者根本不传送。TCP则相反，可以确保每个消息只传送一次，而且按正确的顺序传送。不过，由于增加了可靠性，可能会引入额外的延迟，因为数据报可能需要重新传输。大多数传送大量数据的应用协议（如HTTP）都建立在TCP基础上。UDP通常用于顺序不太重要的协议（因为消息可以放在一个数据包中，例如DNS），或者用于广播（向多个主机发送相同的数据）。</p>
<h2 id="在网络上查找主机"><a href="#在网络上查找主机" class="headerlink" title="在网络上查找主机"></a>在网络上查找主机</h2><p>&emsp;&emsp;socket包含一些函数与网络上的域名服务交互，使得程序可以将服务器的主机名转换为其数字网络地址。应用使用地址来连接一个服务器之前不需要显式转换地址，不过报告错误时除了报告所用的名字之外，还包含这个数字地址会很有用。</p>
<h3 id="socket-gethostname"><a href="#socket-gethostname" class="headerlink" title="socket.gethostname()"></a>socket.gethostname()</h3><p>&emsp;&emsp;要查找当前主机的名字，可以使用<code>gethostname()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import socket</div><div class="line">&gt;&gt;&gt; print socket.gethostname()</div><div class="line">macdeMacBook-Pro.local</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回的名字取决于当前系统的网络设置，在不同的网络上返回的名字可能有变化（如一个连接到WLAN的笔记本电脑）。</p>
<h3 id="socket-gethostbyname"><a href="#socket-gethostbyname" class="headerlink" title="socket.gethostbyname()"></a>socket.gethostbyname()</h3><p>&emsp;&emsp;下面使用<code>gethostbyname()</code>访问操作系统主机名解析API，将服务器名字转换为其数字地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import socket</div><div class="line">&gt;&gt;&gt; for host in [&apos;homer&apos;, &apos;www&apos;, &apos;www.python.org&apos;, socket.gethostname()]:</div><div class="line">...     try:</div><div class="line">...             print &apos;%s : %s&apos; % (host, socket.gethostbyname(host))</div><div class="line">...     except socket.error, msg:</div><div class="line">...             print &apos;%s : %s&apos; % (host, msg)</div><div class="line">... </div><div class="line">homer : [Errno 8] nodename nor servname provided, or not known</div><div class="line">www : [Errno 8] nodename nor servname provided, or not known</div><div class="line">www.python.org : 151.101.36.223</div><div class="line">macdeMacBook-Pro.local : 192.168.0.101</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果当前系统的DNS配置在搜索中包括一个或多个域，名字（name）参数不要求是完全限定名（不需要包含域名和基名）。如果一个名字无法找到，会产生一个socket.error类型的异常。</p>
<h3 id="socket-gethostbyname-ex"><a href="#socket-gethostbyname-ex" class="headerlink" title="socket.gethostbyname_ex()"></a>socket.gethostbyname_ex()</h3><p>&emsp;&emsp;要访问有关服务器的更多命名信息，可以使用函数<code>gethostbyname_ex()</code>，它会返回服务器的标准主机名、所有别名，以及可以用来到达这个主机的所有可用IP地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import socket</div><div class="line">&gt;&gt;&gt; for host in [&apos;baidu.com&apos;, &apos;www.python.org&apos;, socket.gethostname(), &apos;nosuchname&apos;]:</div><div class="line">...     print host</div><div class="line">...     try:</div><div class="line">...             hostname, aliases, addresses = socket.gethostbyname_ex(host)</div><div class="line">...             print &apos; Hostname:&apos;, hostname</div><div class="line">...             print &apos; Aliases:&apos;, aliases</div><div class="line">...             print &apos; Addresses:&apos;, addresses</div><div class="line">...     except socket.error as msg:</div><div class="line">...             print &apos;ERROR:&apos;, msg</div><div class="line">...     print</div><div class="line">...</div><div class="line">baidu.com</div><div class="line"> Hostname: baidu.com</div><div class="line"> Aliases: []</div><div class="line"> Addresses: [&apos;111.13.101.208&apos;, &apos;123.125.114.144&apos;, &apos;180.149.132.47&apos;, &apos;220.181.57.217&apos;]</div><div class="line"></div><div class="line">www.python.org</div><div class="line"> Hostname: prod.python.map.fastlylb.net</div><div class="line"> Aliases: [&apos;www.python.org&apos;, &apos;python.map.fastly.net&apos;]</div><div class="line"> Addresses: [&apos;151.101.16.223&apos;]</div><div class="line"></div><div class="line">macdeMacBook-Pro.local</div><div class="line"> Hostname: macdemacbook-pro.local</div><div class="line"> Aliases: []</div><div class="line"> Addresses: [&apos;10.200.55.2&apos;, &apos;10.57.129.2&apos;, &apos;192.168.0.103&apos;]</div><div class="line"></div><div class="line">nosuchname</div><div class="line">ERROR: [Errno 8] nodename nor servname provided, or not known</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果能得到一个服务器的所有已知IP地址，客户端就可以实现其自己的负载平衡或故障恢复算法。</p>
<h3 id="socket-gethostbyaddr"><a href="#socket-gethostbyaddr" class="headerlink" title="socket.gethostbyaddr()"></a>socket.gethostbyaddr()</h3><p>&emsp;&emsp;如果得到一个服务器的地址，可以使用<code>gethostbyaddr()</code>完成一个逆向查找来得到主机名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import socket</div><div class="line">&gt;&gt;&gt; hostname, aliases, addresses = socket.gethostbyaddr(&apos;127.0.0.1&apos;)</div><div class="line">&gt;&gt;&gt; print &apos;Hostname: %s\nAliases: %s\nAddresses: %s&apos; % (hostname, aliases, addresses)</div><div class="line">Hostname: localhost</div><div class="line">Aliases: [&apos;1.0.0.127.in-addr.arpa&apos;]</div><div class="line">Addresses: [&apos;127.0.0.1&apos;]</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回值是一个元组，其中包含完全主机名、所有别名、以及与这个名字关联的所有IP地址。</p>
<h2 id="查找服务信息"><a href="#查找服务信息" class="headerlink" title="查找服务信息"></a>查找服务信息</h2><p>&emsp;&emsp;除了IP地址之外，每个套接字地址还包括一个整数端口号（port number）。很多应用可以在用一个端口上运行并监听一个IP地址，不过一次只有一个套接字可以使用该地址端口。通过结合IP地址、协议和端口号，可以唯一的标识一个通信通道，确保通过一个套接字发送的消息可以到达正确的目标。</p>
<h3 id="socket-getservbyname"><a href="#socket-getservbyname" class="headerlink" title="socket.getservbyname()"></a>socket.getservbyname()</h3><p>&emsp;&emsp;有些端口号已经预先分配给某个特定的协议。例如，使用SMTP的 email 服务器使用 TCP 在端口25相互通信，Web 客户和服务器使用 80 作为 HTTP 的端口号。网络服务的端口号和标准名可以使用 <code>getservbyname()</code> 查找：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print socket.getservbyname(&apos;ftp&apos;)</div><div class="line">21</div><div class="line">&gt;&gt;&gt; print socket.getservbyname(&apos;https&apos;)</div><div class="line">443</div><div class="line">&gt;&gt;&gt; print socket.getservbyname(&apos;http&apos;)</div><div class="line">80</div><div class="line">&gt;&gt;&gt; print socket.getservbyname(&apos;smtp&apos;)</div><div class="line">25</div></pre></td></tr></table></figure>
<h3 id="socket-getservbyport"><a href="#socket-getservbyport" class="headerlink" title="socket.getservbyport()"></a>socket.getservbyport()</h3><p>要逆向完成服务端口查找，可以使用 <code>getservbyport</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print socket.getservbyport(80)</div><div class="line">http</div></pre></td></tr></table></figure>
<h3 id="socket-getprotobyname"><a href="#socket-getprotobyname" class="headerlink" title="socket.getprotobyname()"></a>socket.getprotobyname()</h3><p>可以使用 <code>getprotobyname()</code> 获取分配给一个传输协议的端口号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print socket.getprotobyname(&apos;tcp&apos;)</div><div class="line">6</div><div class="line">&gt;&gt;&gt; print socket.getprotobyname(&apos;udp&apos;)</div><div class="line">17</div><div class="line">&gt;&gt;&gt; print socket.getprotobyname(&apos;icmp&apos;)</div><div class="line">1</div></pre></td></tr></table></figure>
<p>协议码值是标准化的，作为常量在 socket 中定义，这些协议码都有前缀 <code>IPPROTO_</code>：</p>
<ul>
<li>TCP - <code>socket.IPPROTO_TCP = 6</code></li>
<li>UDP - <code>socket.IPPROTO_UDP = 17</code></li>
<li>ICMP - <code>socket.IPPROTO_ICMP = 1</code> </li>
</ul>
<h2 id="查找服务器地址"><a href="#查找服务器地址" class="headerlink" title="查找服务器地址"></a>查找服务器地址</h2><h3 id="socket-getaddrinfo"><a href="#socket-getaddrinfo" class="headerlink" title="socket.getaddrinfo()"></a>socket.getaddrinfo()</h3><p><code>getaddrinfo()</code> 将一个服务的基本地址转换为一个元组列表，其中包含建立一个连接所需的全部信息。每个元组的内容会有变化，包含不同的网络簇或协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print socket.getaddrinfo(&apos;www.python.org&apos;, &apos;http&apos;)</div><div class="line">[(2, 2, 17, &apos;&apos;, (&apos;151.101.36.223&apos;, 80)), (2, 1, 6, &apos;&apos;, (&apos;151.101.36.223&apos;, 80))]</div></pre></td></tr></table></figure>
<p>下面的程序将解释上述元素的含义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"></div><div class="line">def get_constants(prefix):</div><div class="line">	return dict((getattr(socket, n), n) for n in dir(socket) if n.startswith(prefix))</div><div class="line"></div><div class="line">families = get_constants(&apos;AF_&apos;)</div><div class="line">types = get_constants(&apos;SOCK_&apos;)</div><div class="line">protocols = get_constants(&apos;IPPROTO_&apos;)</div><div class="line">response = socket.getaddrinfo(&apos;www.python.org&apos;, &apos;http&apos;)</div><div class="line">for family, socktype, proto, canonname, sockaddr in response:</div><div class="line">	print &apos;Family		:&apos;, families[family]</div><div class="line">	print &apos;Type		:&apos;, types[socktype]</div><div class="line">	print &apos;Protocol	:&apos;, protocols[proto]</div><div class="line">	print &apos;Canonical Name	:&apos;, canonname</div><div class="line">	print &apos;Socket Address	:&apos;, sockaddr</div><div class="line">	print</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Family		: AF_INET</div><div class="line">Type		: SOCK_DGRAM</div><div class="line">Protocol	: IPPROTO_UDP</div><div class="line">Canonical Name	:</div><div class="line">Socket Address	: (&apos;151.101.16.223&apos;, 80)</div><div class="line"></div><div class="line">Family		: AF_INET</div><div class="line">Type		: SOCK_STREAM</div><div class="line">Protocol	: IPPROTO_TCP</div><div class="line">Canonical Name	:</div><div class="line">Socket Address	: (&apos;151.101.16.223&apos;, 80)</div></pre></td></tr></table></figure>
<p><code>getaddrinfo()</code> 有多个参数来过滤结果列表。例子中给出的主机和端口值是必要参数。可选参数包括 family、socktype、proto 和 flags。这些可选值可以取 0 或 socket 定义的某个常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response = socket.getaddrinfo(&apos;www.python.org&apos;, &apos;http&apos;, socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP, socket.AI_CANONNAME)</div></pre></td></tr></table></figure>
<p>这一次由于标志（flags）包括 <code>AI_CONONNAME</code>，如果这个主机有别名，结果中会包含服务器的标准名（可能与查找所用的值不同）。如果没有这个标志，标准名值则为空。</p>
<h2 id="IP地址表示"><a href="#IP地址表示" class="headerlink" title="IP地址表示"></a>IP地址表示</h2><h3 id="socket-inet-aton-和socket-inet-ntoa"><a href="#socket-inet-aton-和socket-inet-ntoa" class="headerlink" title="socket.inet_aton()和socket.inet_ntoa()"></a>socket.inet_aton()和socket.inet_ntoa()</h3><p>用 C 编写的网络程序使用数据类型 struct sockaddr 将 IP 地址表示为二进制值（而不是Python程序中常见的地址）。要在 Python 表示和 C 表示之间转换 IPv4 地址，可以使用 <code>inet_aton()</code> 和 <code>inet_ntoa()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import binascii</div><div class="line">import socket</div><div class="line">import struct</div><div class="line">import sys</div><div class="line"></div><div class="line">for string_address in [&apos;192.168.1.1&apos;, &apos;127.0.0.1&apos;]:</div><div class="line">    packed = socket.inet_aton(string_address)</div><div class="line">    print &apos;Original: &apos;, string_address</div><div class="line">    print &apos;Packed: &apos;, binascii.hexlify(packed)</div><div class="line">    print &apos;Unpacked: &apos;, socket.inet_ntoa(packed)</div><div class="line">    print</div></pre></td></tr></table></figure>
<p>数据包格式中的4个字节可以传递到C库、通过网络安全地传输，或者紧凑地保存在一个数据库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Original:  192.168.1.1</div><div class="line">Packed:  c0a80101</div><div class="line">Unpacked:  192.168.1.1</div><div class="line"></div><div class="line">Original:  127.0.0.1</div><div class="line">Packed:  7f000001</div><div class="line">Unpacked:  127.0.0.1</div></pre></td></tr></table></figure>
<h3 id="socket-inet-pton-和socket-inet-ntop"><a href="#socket-inet-pton-和socket-inet-ntop" class="headerlink" title="socket.inet_pton()和socket.inet_ntop()"></a>socket.inet_pton()和socket.inet_ntop()</h3><p>相关函数 <code>inet_pton()</code> 和 <code>inet_ntop()</code> 都能处理 IPv4 和 IPv6 地址，根据传入的地址簇参数生成适当的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import binascii</div><div class="line">import socket</div><div class="line">import struct</div><div class="line">import sys</div><div class="line"></div><div class="line">string_address = &apos;2002:ac10:10a:1234:21e:52ff:fe74:40e&apos;</div><div class="line">packed = socket.inet_pton(socket.AF_INET6, string_address)</div><div class="line">print &apos;Original: &apos;, string_address</div><div class="line">print &apos;Packed: &apos;, binascii.hexlify(packed)</div><div class="line">print &apos;Unpacked: &apos;, socket.inet_ntop(socket.AF_INET6, packed)</div></pre></td></tr></table></figure>
<p>IPv6 地址已经是十六进制值，所以将打包版本转换为一个十六进制数系列时会生成一个与原值类似的串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Original:  2002:ac10:10a:1234:21e:52ff:fe74:40e</div><div class="line">Packed:  2002ac10010a1234021e52fffe74040e</div><div class="line">Unpacked:  2002:ac10:10a:1234:21e:52ff:fe74:40e</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 网络通信 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Python制作长图]]></title>
      <url>http://lizonghang.github.io/2016/07/14/Python%E5%88%B6%E4%BD%9C%E9%95%BF%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p>代码功能将多张图片合并为一张长图，保持各子图比例相同。需要第三方库PIL和numpy。numpy是一个开源数字扩展库，可以用来处理大型矩阵。</p>
<h1 id="安装第三方库"><a href="#安装第三方库" class="headerlink" title="安装第三方库"></a>安装第三方库</h1><h2 id="安装PIL"><a href="#安装PIL" class="headerlink" title="安装PIL"></a>安装PIL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install pillow</div></pre></td></tr></table></figure>
<h2 id="安装numpy"><a href="#安装numpy" class="headerlink" title="安装numpy"></a>安装numpy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install numpy</div></pre></td></tr></table></figure>
<h1 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h1><p>我们需要的图片素材有：</p>
<p><img src="/images/menbi1.jpg" alt=""><br><img src="/images/menbi2.jpg" alt=""><br><img src="/images/menbi3.jpg" alt=""><br><img src="/images/menbi4.jpg" alt=""><br><img src="/images/menbi5.jpg" alt=""><br><img src="/images/menbi6.jpg" alt=""><br><img src="/images/menbi7.jpg" alt=""></p>
<p>合成效果为：</p>
<p><img src="/images/MergeImage.jpg" alt=""></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>假设文件名为merge.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># encoding: utf-8</div><div class="line">from PIL import Image</div><div class="line">import numpy</div><div class="line">import os</div><div class="line">import sys</div><div class="line">import random</div><div class="line">import argparse</div><div class="line"></div><div class="line">parser = argparse.ArgumentParser()</div><div class="line">parser.add_argument(&apos;image_dir&apos;, help=&apos;Path to Image Direction&apos;)</div><div class="line">parser.add_argument(&apos;-w&apos;, help=&apos;Image Width&apos;, type=int, default=300)</div><div class="line">args = parser.parse_args()</div><div class="line">root = args.image_dir # 图片文件夹目录</div><div class="line">if root.split(&apos;/&apos;)[-1]:</div><div class="line">    root += &apos;/&apos;</div><div class="line">pxsize = args.w # 单张照片宽度</div><div class="line">images = [] # 存放所有照片路径</div><div class="line"></div><div class="line">def getPhotos():</div><div class="line">    &apos;&apos;&apos;获取所有照片的索引&apos;&apos;&apos;</div><div class="line">    image_num = 0</div><div class="line">    for im in os.listdir(root):</div><div class="line">        suffix = im.split(&apos;.&apos;)[-1]</div><div class="line">        if suffix == &apos;jpg&apos; or suffix == &apos;JPG&apos; or suffix == &apos;jpeg&apos; or suffix == &apos;png&apos;:</div><div class="line">            images.append(root + im)</div><div class="line">            image_num += 1</div><div class="line">    return image_num</div><div class="line"></div><div class="line">xnum = 1 # 行照片数目</div><div class="line">ynum = getPhotos() # 列照片数目</div><div class="line">if ynum &gt; 70:</div><div class="line">    print &apos;图片数目过多，最高70&apos;</div><div class="line">    sys.exit()</div><div class="line"></div><div class="line">def getTotalHeight():</div><div class="line">    &apos;&apos;&apos;获取合并图片总长&apos;&apos;&apos;</div><div class="line">    totalHeight = 0</div><div class="line">    for i in range(xnum):</div><div class="line">        for j in range(ynum): </div><div class="line">            totalHeight += len(transfer(images[j])) + 1</div><div class="line">    return totalHeight</div><div class="line"></div><div class="line">def transfer(img_path):</div><div class="line">    &apos;&apos;&apos;将图片尺寸等比例转换&apos;&apos;&apos;</div><div class="line">    im = Image.open(img_path)</div><div class="line">    rate = float(im.size[0]) / im.size[1]</div><div class="line">    target_width = pxsize</div><div class="line">    target_height = int(pxsize / rate)</div><div class="line">    im = im.resize((target_width, target_height))</div><div class="line">    return numpy.array(im)[:target_height, :target_width]</div><div class="line"></div><div class="line">def mergeImage():</div><div class="line">    &apos;&apos;&apos;合并图片&apos;&apos;&apos;</div><div class="line">    point = 0</div><div class="line">    I = numpy.array(Image.new(&apos;RGB&apos;, (pxsize, getTotalHeight()), (255,255,255)))</div><div class="line">    for i in range(xnum):</div><div class="line">        for j in range(ynum):</div><div class="line">            DA = transfer(images[j]) </div><div class="line">            I[point:point+len(DA), (i*pxsize):((i+1)*pxsize)] = DA</div><div class="line">            point += len(DA) + 1</div><div class="line">    Image.fromarray(I.astype(numpy.uint8)).save(&apos;MergeImage.jpg&apos;, &apos;JPEG&apos;)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    getPhotos()</div><div class="line">    mergeImage()</div></pre></td></tr></table></figure>
<h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python merge.py &lt;path-to-image-file&gt; [-w width]</div></pre></td></tr></table></figure>
<ul>
<li>path-to-image-file - 必选，指向存放要合并的图片的文件夹</li>
<li>-w width - 可选，指定生成图片的宽度，默认为300px</li>
<li>默认生成图片存放路径为文件merge.py同级目录</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Python中执行JS命令]]></title>
      <url>http://lizonghang.github.io/2016/07/10/Python%E4%B8%AD%E6%89%A7%E8%A1%8CJS%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<ul>
<li>自动将Javascipt代码翻译成Python代码 - 支持全部ECMA Scipt 5.1</li>
<li>可使用<code>pyimport</code>语法从Javascript代码中导入Python库</li>
<li>解释速度快，可作为独立的JS解释器</li>
<li>友好的JS执行方式，<code>js2py.eval_js</code></li>
</ul>
<h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install js2py</div></pre></td></tr></table></figure>
<h1 id="Simple-Example"><a href="#Simple-Example" class="headerlink" title="Simple Example"></a>Simple Example</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import js2py</div><div class="line">&gt;&gt;&gt; js2py.eval_js(&apos;console.log(&quot;Hello World!&quot;)&apos;)</div><div class="line">&apos;Hello World!&apos;</div><div class="line">&gt;&gt;&gt; add = js2py.eval_js(&apos;function add(a,b)&#123;return a+b&#125;&apos;)</div><div class="line">&gt;&gt;&gt; add</div><div class="line">&apos;function add(a, b) &#123; [python code] &#125;&apos;</div><div class="line">&gt;&gt;&gt; add(1,2) + 3</div><div class="line">6</div><div class="line">&gt;&gt;&gt; add.constructor</div><div class="line">&apos;function Function() &#123; [python code] &#125;&apos;</div><div class="line">&gt;&gt;&gt; js2py.eval_js(&quot;Object.prototype.toString.call(Function(&apos;s&apos;, &apos;return s+arguments[1]&apos;)(new Date(), 7).__proto__)&quot;)</div><div class="line">&apos;[object String]&apos;</div></pre></td></tr></table></figure>
<h1 id="More-advanced-usage-example"><a href="#More-advanced-usage-example" class="headerlink" title="More advanced usage example"></a>More advanced usage example</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># Adding Python built-in sum to the JS context:</div><div class="line">&gt;&gt;&gt; context = js2py.EvalJs(&#123;&apos;python_sum&apos;: sum&#125;)  </div><div class="line">&gt;&gt;&gt; js_code = &apos;&apos;&apos;</div><div class="line">var a = 10</div><div class="line">function f(x) &#123;return x*x&#125;</div><div class="line">&apos;&apos;&apos;</div><div class="line">&gt;&gt;&gt; context.execute(js_code)</div><div class="line"># Get value of variable a:</div><div class="line">&gt;&gt;&gt; context.a</div><div class="line">10</div><div class="line"># context.f behaves just like js function so you can supply more than 1 argument. &apos;9&apos;*&apos;9&apos; in javascript is 81.</div><div class="line">&gt;&gt;&gt; context.f(&apos;9&apos;, 0)  </div><div class="line">81    </div><div class="line"># context.f has all attributes of normal JavaScript object</div><div class="line">&gt;&gt;&gt; context.f.toString()</div><div class="line">u&apos;function f(x) &#123; [python code] &#125;&apos;</div><div class="line">&gt;&gt;&gt; context.f.bind</div><div class="line">function bind(thisArg) &#123; [python code] &#125;</div><div class="line"># You can also add variables to the context:</div><div class="line">&gt;&gt;&gt; context.foo = [1,2,3]  # context.foo is now Js Array object and behaves just like javascript array!</div><div class="line">&gt;&gt;&gt; context.foo.push(4)  </div><div class="line">4</div><div class="line">&gt;&gt;&gt; context.foo.to_list() # convert to python list</div><div class="line">[1, 2, 3, 4]</div><div class="line"># You can use Python objects that you put inside the context!</div><div class="line">&gt;&gt;&gt; context.eval(&apos;python_sum(new Array(1, 2, 3))&apos;)</div><div class="line">6</div></pre></td></tr></table></figure>
<h1 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h1><ul>
<li>忽视了”strict mode”</li>
<li>不支持<code>with</code>语法</li>
<li><code>eval</code>的非直接调用会被当做直接调用</li>
</ul>
<h1 id="Other-Examples"><a href="#Other-Examples" class="headerlink" title="Other Examples"></a>Other Examples</h1><p>In Js2Py all JavaScript objects are a subclass of PyJs object. For example JS Number is represented by PyJsNumber class. js2py.eval_js and js2py.EvalJs automatically tries to convert PyJs type to builtin python type. So for example if you execute:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; js2py.eval_js(&apos;var a = &quot;hello&quot;; a&apos;)</div></pre></td></tr></table></figure>
<p>eval_js will return unicode type (u”hello”). However for complex types such conversion is impossible and JsObjectWrapper is returned. See the conversion table JsType -&gt; PyType:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Boolean -&gt; bool</div><div class="line">String -&gt; unicode (str in Python 3)</div><div class="line">Number -&gt; float (or int/long if whole number)</div><div class="line">undefined -&gt; None</div><div class="line">null -&gt; None</div><div class="line">OTHER -&gt; JsObjectWrapper</div></pre></td></tr></table></figure>
<p>JsObjectWrapper supports: getitem, getattr, setitem, setattr, repr and call. Moreover it has to_list and to_dict methods if you want to convert it to builtin python type.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; js = js2py.eval_js(&apos;d = &#123;a:1, b:2&#125;&apos;)</div><div class="line">&gt;&gt;&gt; js</div><div class="line">&#123;a: 1, b: 2&#125;  </div><div class="line">&gt;&gt;&gt; type(js)</div><div class="line">&lt;class &apos;js2py.base.JsObjectWrapper&apos;&gt;</div><div class="line">&gt;&gt;&gt; js.a</div><div class="line">1</div><div class="line">&gt;&gt;&gt; js[&apos;a&apos;]</div><div class="line">1</div><div class="line">&gt;&gt;&gt; js.b = 20</div><div class="line">&gt;&gt;&gt; js</div><div class="line">&#123;a: 1, b: 20&#125;  </div><div class="line">&gt;&gt;&gt; js[&apos;c&apos;] = 30</div><div class="line">&gt;&gt;&gt; js.to_dict()</div><div class="line">&#123;u&apos;a&apos;: 1, &apos;c&apos;: 30, u&apos;b&apos;: 20&#125;</div></pre></td></tr></table></figure>
<p>Also, of course you can use Js2Py to parse (tree is the same as in esprima.js) and translate JavaScript</p>
<h1 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; js2py.parse_js(&apos;var $ = 5&apos;)   </div><div class="line">&#123;&apos;body&apos;: [&#123;&apos;kind&apos;: &apos;var&apos;, &apos;declarations&apos;: [&#123;&apos;init&apos;: &#123;&apos;raw&apos;: None, &apos;type&apos;: u&apos;Literal&apos;, &apos;value&apos;: 5.0&#125;, &apos;type&apos;: u&apos;VariableDeclarator&apos;, &apos;id&apos;: &#123;&apos;type&apos;: u&apos;Identifier&apos;, &apos;name&apos;: u&apos;$&apos;&#125;&#125;], &apos;type&apos;: u&apos;VariableDeclaration&apos;&#125;], &apos;type&apos;: u&apos;Program&apos;&#125;</div></pre></td></tr></table></figure>
<h1 id="Translating"><a href="#Translating" class="headerlink" title="Translating"></a>Translating</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print js2py.translate_js(&apos;var $ = 5&apos;)</div><div class="line">import js2py.pyjs, sys</div><div class="line">for m in sys.modules.keys():</div><div class="line">    if m.startswith(&apos;js2py&apos;):</div><div class="line">        del sys.modules[m]</div><div class="line">del js2py.pyjs</div><div class="line">del js2py</div><div class="line">from js2py.pyjs import *</div><div class="line"># setting scope</div><div class="line">var = Scope( JS_BUILTINS )</div><div class="line">set_global_object(var)</div><div class="line"># Code follows:</div><div class="line">var.registers([u&apos;$&apos;])</div><div class="line">var.put(u&apos;$&apos;, Js(5.0))</div></pre></td></tr></table></figure>
<h1 id="pyimport-statement"><a href="#pyimport-statement" class="headerlink" title="pyimport statement"></a>pyimport statement</h1><p>Finally, Js2Py also supports importing any Python code from JavaScript using ‘pyimport’ statement:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x = &quot;&quot;&quot;pyimport urllib;</div><div class="line">           var result = urllib.urlopen(&apos;https://www.google.com/&apos;).read();</div><div class="line">           console.log(result.length)</div><div class="line">        &quot;&quot;&quot;</div><div class="line">&gt;&gt;&gt; js2py.eval_js(x)</div><div class="line">18211</div><div class="line">undefined</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[使用pytesser破解简单验证码]]></title>
      <url>http://lizonghang.github.io/2016/07/10/%E4%BD%BF%E7%94%A8pytesser%E7%A0%B4%E8%A7%A3%E7%AE%80%E5%8D%95%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>Tesseract是一款开源 OCR（Optical Character Recognition，光学字符识别）软件。所谓OCR是图像识别领域中一个子领域，该领域专注于对图片中的文字信息进行识别并转换成能被常规文本编辑器编辑的文本。</p>
<p>Tesseract 已经有30年历史，开始它是惠普实验室的一款专利软件，然后在 2005 年开源，自 2006 年后由 Google 赞助进行后续的开发和维护。在 1995 年 Tesseract 曾是世界前三的 OCR 引擎，而且在现在的免费 OCR 引擎中，其识别精度也仍然是出类拔萃的。因为其免费与较好的效果，许多的个人开发者以及一些较小的团队在使用着 Tesseract ，诸如验证码识别、车牌号识别等应用中，不难见到 Tesseract 的身影。</p>
<p>测试图片如下，文件名为test.png :<br><img src="/images/20140811163359656.png" alt=""></p>
<h1 id="安装与错误信息"><a href="#安装与错误信息" class="headerlink" title="安装与错误信息"></a>安装与错误信息</h1><h2 id="安装PIL"><a href="#安装PIL" class="headerlink" title="安装PIL"></a>安装PIL</h2><p>详见<a href="/2016/07/05/快速入门PIL/">快速入门PIL</a></p>
<h2 id="安装pytesseract"><a href="#安装pytesseract" class="headerlink" title="安装pytesseract"></a>安装pytesseract</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install pytesseract</div></pre></td></tr></table></figure>
<p>此时直接使用会出现错误，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; import pytesseract</div><div class="line">&gt;&gt;&gt; im = Image.open(&apos;test.png&apos;)</div><div class="line">&gt;&gt;&gt; print pytesseract.image_to_string(im)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;/usr/lib/python2.7/dist-packages/spyderlib/widgets/externalshell/sitecustomize.py&quot;, line 540, in runfile</div><div class="line">    execfile(filename, namespace)</div><div class="line">  File &quot;/home/chaitanya/pythonapp/localcopy.py&quot;, line 4, in &lt;module&gt;</div><div class="line">    print pytesseract.image_to_string(im)</div><div class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/pytesseract/pytesseract.py&quot;, line 142, in image_to_string</div><div class="line">    config=config)</div><div class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/pytesseract/pytesseract.py&quot;, line 75, in run_tesseract</div><div class="line">    stderr=subprocess.PIPE)</div><div class="line">  File &quot;/usr/lib/python2.7/subprocess.py&quot;, line 710, in __init__</div><div class="line">    errread, errwrite)</div><div class="line">  File &quot;/usr/lib/python2.7/subprocess.py&quot;, line 1327, in _execute_child</div><div class="line">    raise child_exception</div><div class="line">OSError: [Errno 2] No such file or directory</div></pre></td></tr></table></figure>
<p>原因是还没有安装tesseract-ocr</p>
<h2 id="安装tesseract-ocr"><a href="#安装tesseract-ocr" class="headerlink" title="安装tesseract-ocr"></a>安装tesseract-ocr</h2><p>Linux可使用<code>apt-get</code>直接安装:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install tesseract-ocr</div></pre></td></tr></table></figure>
<p>如果想用 Tesseract 对图像进行识别，还需要对应的语言文件。所谓的语言文件是 Tesseract 识别某种语言的文字图像时需要的一些资源，这些东西也可以通过包管理器获取。比如我们需要识别英语和简体中文，那么使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install tesseract-ocr-eng tesseract-ocr-chi-sim</div></pre></td></tr></table></figure>
<p>如果没有<code>apt-get</code>，需要的话可以使用编译安装的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://tesseract-ocr.googlecode.com/files/tesseract-ocr-3.02.02.tar.gz</div><div class="line">tar -xzvf tesseract-ocr-3.02.02.tar.gz</div></pre></td></tr></table></figure>
<p>编译需要<code>automake</code>、<code>autoconf</code>、<code>libtool</code>支持，如果有的话可以跳过该步骤，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install autoconf automake libtool</div></pre></td></tr></table></figure>
<p>然后进入文件夹 tesseract-ocr-3.02.02 编译安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure>
<p>Tesseract还依赖一些图像库，你可以选择性安装，也可不安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install ligjpeg62-dev libtiff4-dev libpng12-dev libleptonica-dev</div></pre></td></tr></table></figure>
<p>再运行测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; import pytesseract</div><div class="line">&gt;&gt;&gt; im = Image.open(&apos;test.png&apos;)</div><div class="line">&gt;&gt;&gt; print pytesseract.image_to_string(im)</div></pre></td></tr></table></figure>
<p>可能会出现’Leptonica not found’错误。如果出现该错误，下载安装Leptonica包即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://leptonica.googlecode.com/files/leptonica-1.69.tar.bz2</div></pre></td></tr></table></figure>
<h2 id="安装语言训练集"><a href="#安装语言训练集" class="headerlink" title="安装语言训练集"></a>安装语言训练集</h2><p>解压后进入目录执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure>
<p>如果没有出现上述错误，应该会出现<code>TesseractError</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print pytesseract.image_to_string(im)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;/Library/Python/2.7/site-packages/pytesseract/pytesseract.py&quot;, line 164, in image_to_string</div><div class="line">    raise TesseractError(status, errors)</div><div class="line">pytesseract.pytesseract.TesseractError: (1, &apos;Error opening data file /usr/local/share/tessdata/eng.traineddata&apos;)</div></pre></td></tr></table></figure>
<p>这是由于没有下载语音训练集造成，你可以使用命令查看目前的语言训练集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tesseract --list-langs</div></pre></td></tr></table></figure>
<p>训练集放置于/usr/local/share/目录中的tessdata文件夹中，你需要手动下载训练集并添加到这个文件夹，添加后可以使用上述命令查看。你可以从<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="external">Github</a>获取到训练集。</p>
<p>再次尝试运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; import pytesseract</div><div class="line">&gt;&gt;&gt; im = Image.open(&apos;test.png&apos;)</div><div class="line">&gt;&gt;&gt; print pytesseract.image_to_string(im)</div><div class="line">hoke</div></pre></td></tr></table></figure>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>经测试，pytesser适用于比较规范的英文/数字，对于中文的识别能力较差，对于有干扰素的验证码图片性能较差，可以用来提取简单的英文/数字。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[随机数字图片验证码的原理、生成和破解]]></title>
      <url>http://lizonghang.github.io/2016/07/10/%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%AD%97%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E7%94%9F%E6%88%90%E5%92%8C%E7%A0%B4%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>验证码的功能一般是防止使用程序恶意注册、暴力破解或批量发帖而设置的。所谓验证码，就是将一串随机产生的数字或符号，生成一幅图片，图片里加上一些干扰象素（防止OCR），由用户肉眼识别其中的验证码信息，输入表单提交网站验证，验证成功后才能使用某项功能。学习验证码的破解/识别技术，不仅可以知道验证码的原理，而且可以让你知道怎样才能防止验证码被破解。</p>
<h1 id="常见验证码类型"><a href="#常见验证码类型" class="headerlink" title="常见验证码类型"></a>常见验证码类型</h1><p><img src="/images/authtype.png" alt=""></p>
<ol>
<li>图片背景和数字都使用相同的颜色，字符规整，字符位置统一</li>
<li>验证字符规整，颜色相同，排除干扰素容易，只要是非字符色素全部排除即可</li>
<li>处理背景色和干扰色一直变换，验证字符的颜色也在变化，各个字符的颜色也各不相同</li>
<li>在第三个基础上，在文字上加了两条直线干扰率，容易去掉</li>
</ol>
<h1 id="验证码识别步骤"><a href="#验证码识别步骤" class="headerlink" title="验证码识别步骤"></a>验证码识别步骤</h1><h2 id="取出干扰素"><a href="#取出干扰素" class="headerlink" title="取出干扰素"></a>取出干扰素</h2><p>干扰素的一个重要特征是不能影响验证码的显示效果，所以制作干扰素时它的RGB可能低于或高于某个特定值。比如例子中的图片，干扰素的RGB各项值小于125，依此很容易去掉干扰素。</p>
<h2 id="取出字模"><a href="#取出字模" class="headerlink" title="取出字模"></a>取出字模</h2><p>由于各个网站的验证码各不相同，最常见的方法是建立验证码的特征码库。取字模时，需要多收集几张图片，使这些图片中包括所有的字符。一般来说有0~9、a~z</p>
<h2 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h2><p>把图片上的验证字符上每个像素用一种数字表示1，其他部分用0表示。这样就可以计算每个数字字模，记录下这些字模当作key</p>
<h2 id="计算特征"><a href="#计算特征" class="headerlink" title="计算特征"></a>计算特征</h2><p>把要识别的图片进行二值化，得到图片特征</p>
<h2 id="对照样本"><a href="#对照样本" class="headerlink" title="对照样本"></a>对照样本</h2><p>把上一步图片特征码和验证码的字模进行对比，得到验证图片上的数字</p>
<h1 id="复杂验证码"><a href="#复杂验证码" class="headerlink" title="复杂验证码"></a>复杂验证码</h1><p>识别的目标验证码由字符和数字组成，验证码存在旋转，位置不固定，存在字符与字符之间的粘连，且验证码有更强的干扰素。以下图为例：</p>
<p><img src="/images/authexam.jpg" alt=""></p>
<h2 id="二值化-1"><a href="#二值化-1" class="headerlink" title="二值化"></a>二值化</h2><p>把验证码的部分用1表示，背景部分用0表示。识别方法为：打印出验证码图片的RGB，分辨出图片的R值大于120，G和B小于80的像素，依据这个规则把图片二值化。</p>
<p>常见验证码第三张图片中，验证码的图片每次背景色都不相同，且不是单色，各个验证码数字的颜色每次也各不相同。打印出其 RGB 值很容易就发现。无论验证数字颜色如何变化，该数字的 RGB 值总有一个值小于 125 ，所以通过判断<code> rgbarray[‘red’] &lt; 125 || rgbarray[‘green’] &lt; 125 || rgbarray[‘blue’] &lt; 125 </code>就很容易分辨出数字和背景。</p>
<p>这些规律的原因是，在制作验证码的干扰素时，为了使干扰素不影响数字的显示效果，必须使干扰素的 RGB 和数字的 RGB 相互独立，互不干扰。依照这个规律就容易实现二值化。</p>
<p>我们找到的 120 ， 80 ， 125 等阈值，可能和实际的 RGB 有出入，所以，有时二值化后，会有部分地方出现 1 ，对于验证码上固定位置显示数字，这种干扰没有太大意义。但是对于验证码位置不确定的图片来说，在我们切割字符时，很可能造成干扰。所以，在二值化后要进行去噪处理。</p>
<h2 id="去噪处理"><a href="#去噪处理" class="headerlink" title="去噪处理"></a>去噪处理</h2><p>去噪就是把孤立的有效值去掉。如果一个点为1，则判断这个点的周围一圈上的数字是否为1，若没有则认为是一个噪点，直接设置为0即可。</p>
<p><img src="/images/noise.jpg" alt=""></p>
<p>如图所示，红色方框部分的 1 为噪点，直接设置为 0 即可。有时候噪点可能是两个连续的 1 ，可以计算这个点 8 个方向上的值之和，判断和是否小于特定的阈值。</p>
<h2 id="切割字符"><a href="#切割字符" class="headerlink" title="切割字符"></a>切割字符</h2><p>切割方法有很多种，最简单的一种为竖直切割。先沿垂直方向切割为字符，然后再水平方向去掉多余的 0 。如下图所示</p>
<p><img src="/images/1336829447_7784.jpg" alt=""></p>
<p>第一步切割红线部分，第二步切割蓝线部分，就可以得到独立的字符了。但是像下面的情况：</p>
<p><img src="/images/1336829468_5425.jpg" alt=""></p>
<p>按上面的方法会把 dw 字符切割成一个字符，这是错误的切割，这里涉及到粘连字符的切割。</p>
<h2 id="粘连字符切割"><a href="#粘连字符切割" class="headerlink" title="粘连字符切割"></a>粘连字符切割</h2><p>制作验证码时，规则字符的粘连很容易分割开，如果字符本身有缩放，变形就很难处理。上述字符粘连是规则字符的粘连，完成分割操作后，不能马上确定分割的部分为一个字符，要进行验证。验证的关键是切割下来的字符的宽是否大于阈值。阈值的取舍标准是一个字符无论怎么旋转变形都不会大于这个阈值。若切割的块大于这个阈值，可以认为是一个粘连字符；如果大于两个阈值之和，认为是三个字符粘连，以此类推。如果发现粘连字符块，直接平分为两个或多个小块即可。为了更好的还原字符，一般采用平分±1对字符块部分进行适当的补充。</p>
<h2 id="匹配字符"><a href="#匹配字符" class="headerlink" title="匹配字符"></a>匹配字符</h2><p>最简单的方式是为所有的字符所有情况建立匹配库，目的是现有人工识别图片的验证码，处理后写入特征码库以便匹配。特征码库的图片数据越多，验证识别的准确性就越高。</p>
<h1 id="制作验证码的建议"><a href="#制作验证码的建议" class="headerlink" title="制作验证码的建议"></a>制作验证码的建议</h1><p>对于识别验证码的程序来说最难的部分是验证码字符的切割和特征码的建立。很多验证码加了很多干扰素和干扰线，不仅影响用户体验还达不到防止破解的很好的效果。若要使验证码难于被程序识别，需要注意：</p>
<ul>
<li>字符粘连，最后所有字符都有粘连的部分</li>
<li>不使用规则字符，验证码的各个部分使用不同比例的缩放或者旋转</li>
</ul>
<p>一般实现以上两点或这两点的变性，破解程序就很难识别。</p>
]]></content>
      
        <categories>
            
            <category> 算法/理论 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Python破解验证码]]></title>
      <url>http://lizonghang.github.io/2016/07/09/Python%E7%A0%B4%E8%A7%A3%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>本项目使用<strong>PIL库</strong>及<strong>向量空间搜索引擎理论</strong>实现验证码破解。先下载实验用文件便于解释图片解析的原理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ wget http://labfile.oss.aliyuncs.com/courses/364/python_captcha.zip</div><div class="line">$ unzip python_captcha.zip</div></pre></td></tr></table></figure></p>
<p>或直接访问 <a href="http://labfile.oss.aliyuncs.com/courses/364/python_captcha.zip" target="_blank" rel="external">http://labfile.oss.aliyuncs.com/courses/364/python_captcha.zip</a> 并解压。python_captcha目录下的内容有:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">python_captcha</div><div class="line">├── captcha.gif</div><div class="line">├── crack.py</div><div class="line">├── examples</div><div class="line">└── iconset</div><div class="line">    ├── 0~9</div><div class="line">    ├── a~z</div></pre></td></tr></table></figure></p>
<ul>
<li>captcha.gif - 试验用验证码图片</li>
<li>crack.py - 即将编写的实现验证码破解的程序</li>
<li>examples/ - 存放了其他可用于测试的验证码图片</li>
<li>iconset/ - 存放了训练集，即用于对比的单符号图片</li>
</ul>
<p>下图为试验用验证码图片:</p>
<p><img src="/images/captcha.gif" alt=""></p>
<h1 id="从文件中提取图片"><a href="#从文件中提取图片" class="headerlink" title="从文件中提取图片"></a>从文件中提取图片</h1><p>将图片转为8位P模式图片，输出其颜色直方图:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line">im = Image.open(&apos;captcha.gif&apos;).convert(&apos;P&apos;)</div><div class="line">print im.histogram()</div></pre></td></tr></table></figure>
<p>输出:</p>
<pre>
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 1, 2, 0, 1, 0, 0, 1, 0, 2, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 3, 1, 3, 3, 0, 0, 0, 0, 0, 0, 1, 0, 3, 2, 132, 1, 1, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 15, 0, 1, 0, 1, 0, 0, 8, 1, 0, 0, 0, 0, 1, 6, 0, 2, 0, 0, 0, 0, 18, 1, 1, 1, 1, 1, 2, 365, 115, 0, 1, 0, 0, 0, 135, 186, 0, 0, 1, 0, 0, 0, 116, 3, 0, 0, 0, 0, 0, 21, 1, 1, 0, 0, 0, 2, 10, 2, 0, 0, 0, 0, 2, 10, 0, 0, 0, 0, 1, 0, 625]
</pre>

<p>颜色直方图的每一位数字都代表了在图片中含有对应位颜色像素的数量。每个像素点可表现256种颜色。从输出中可发现白点最多，白色像素序号为255，即最后一位，有625个像素。红像素在序号200左右，通过排序可以得到有用的颜色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">his = im.histogram()</div><div class="line">values = &#123;&#125;</div><div class="line">for i in range(256):</div><div class="line">    values[i] = his[i] </div><div class="line">for index,count in sorted(values.items(), key=lambda d:d[1], reverse=True)[:10]:</div><div class="line">    print index,count</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">255 625</div><div class="line">212 365</div><div class="line">220 186</div><div class="line">219 135</div><div class="line">169 132</div><div class="line">227 116</div><div class="line">213 115</div><div class="line">234 21</div><div class="line">205 18</div><div class="line">184 15</div></pre></td></tr></table></figure>
<p>得到了图片中最多的10种颜色，其中index为220与227是需要的红色和灰色，通过这一信息构造黑白二值图片:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line">im = Image.open(&apos;captcha.gif&apos;).convert(&apos;P&apos;)</div><div class="line">im2 = Image.new(&apos;P&apos;, im.size, 255)</div><div class="line">for row in range(im.size[1]):</div><div class="line">    for col in range(im.size[0]):</div><div class="line">        pix = im.getpixel((col,row))</div><div class="line">        if pix == 220 or pix == 227:</div><div class="line">            im2.putpixel((col,row), 0)</div><div class="line">im2.show()</div></pre></td></tr></table></figure>
<p>得到黑白二值图片:</p>
<p><img src="/images/im2.gif" alt=""></p>
<h1 id="提取单个字符图片"><a href="#提取单个字符图片" class="headerlink" title="提取单个字符图片"></a>提取单个字符图片</h1><p>为了判断各个字符，需要将图片切割为单个字符的像素集合，对黑白二值图片进行纵向切割：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">inLetter = False</div><div class="line">foundLetter = False</div><div class="line">letterStart = 0</div><div class="line">letterEnd = 0</div><div class="line">letter_split = []</div><div class="line"></div><div class="line">for col in range(im2.size[0]):</div><div class="line">    for row in range(im2.size[1]):</div><div class="line">        pix = im2.getpixel((col,row))</div><div class="line">        if pix != 255:</div><div class="line">            inLetter = True</div><div class="line">    if foundLetter == False and inLetter == True:</div><div class="line">        foundLetter = True</div><div class="line">        letterStart = col</div><div class="line">    if foundLetter == True and inLetter == False:</div><div class="line">        foundLetter = False</div><div class="line">        letterEnd = col</div><div class="line">        letter_split.append((letterStart,letterEnd))</div><div class="line">    inLetter = False</div></pre></td></tr></table></figure>
<p>letter_split中记录了每个字符开始和结束的列序号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[(6, 14), (15, 25), (27, 35), (37, 46), (48, 56), (57, 67)]</div></pre></td></tr></table></figure>
<p>分割图片:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for letter in letter_split:</div><div class="line">    im_Letter = im2.crop((letter[0], 0, letter[1], im2.size[1]))</div><div class="line">    im_Letter.show()</div></pre></td></tr></table></figure>
<p>得到每个字符的图片。将这些图片与本地图片进行比较分析，匹配到相似度最高的字符。</p>
<h1 id="向量空间图形识别"><a href="#向量空间图形识别" class="headerlink" title="向量空间图形识别"></a>向量空间图形识别</h1><p>这里使用向量空间搜索引擎来做字符识别，它具有很多优点：</p>
<ul>
<li>不需要大量的训练迭代</li>
<li>不会训练过度</li>
<li>可以随时加入/移除错误的数据查看效果</li>
<li>很容易理解和编写成代码</li>
<li>提供分级结果，可以查看最接近的多个匹配</li>
<li>对于无法识别的东西只要加入到搜索引擎中就能识别</li>
</ul>
<p>但它分类的速度比神经网络慢很多，不能找到自己的方法解决问题。</p>
<p>原理可以参考<a href="/2016/07/07/向量空间搜索引擎基本理论/">向量空间搜索引擎</a></p>
<p>类VectorCompare实现向量空间:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import math</div><div class="line">class VectorCompare:</div><div class="line">    def magnitude(self, concordance):</div><div class="line">        total = 0</div><div class="line">        for word, count in concordance.iteritems():</div><div class="line">            total += count ** 2</div><div class="line">        return math.sqrt(total)</div><div class="line"></div><div class="line">    def relation(self, concordance1, concordance2):</div><div class="line">        relevance = 0</div><div class="line">        topvalue = 0</div><div class="line">        for word, count in concordance1.iteritems():</div><div class="line">            if concordance2.has_key(word):</div><div class="line">                topvalue += count * concordance2[word]</div><div class="line">        return topvalue / (self.magnitude(concordance1) * self.magnitude(concordance2))</div></pre></td></tr></table></figure>
<p>该类会比较两个字典并输出它们的相似度(0~1)</p>
<h1 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h1><p>还需要取大量的验证码提取出单个字符图片作为训练集合的工作，上文已经介绍。iconset目录下放的是训练集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">def buildvector(im):</div><div class="line">    d1 = &#123;&#125;</div><div class="line">    count = 0</div><div class="line">    for i in im.getdata():</div><div class="line">        d1[count] = i</div><div class="line">        count += 1</div><div class="line">    return d1</div><div class="line"></div><div class="line">v = VectorCompare()</div><div class="line">iconset = [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;]</div><div class="line"></div><div class="line"># 加载训练集</div><div class="line">imageset = []</div><div class="line">for letter in iconset:</div><div class="line">    for img in os.listdir(&apos;./iconset/%s/&apos; % letter):</div><div class="line">        temp = []</div><div class="line">        if img != &apos;Thumbs.db&apos; and img != &apos;.DS_Store&apos;:</div><div class="line">            temp.append(buildvector(Image.open(&apos;./iconset/%s/%s&apos; % (letter, img))))</div><div class="line">        imageset.append(&#123;letter: temp&#125;)</div><div class="line"></div><div class="line">count = 0</div><div class="line"># 切割验证码</div><div class="line">for letter in letter_split:</div><div class="line">    im_Letter = im2.crop((letter[0], 0, letter[1], im2.size[1]))</div><div class="line">    guess = []</div><div class="line">    # 将切割得到的验证码小片段与每个训练片段进行比较</div><div class="line">    for image in imageset:</div><div class="line">        for x,y in image.iteritems():</div><div class="line">            if len(y) != 0:</div><div class="line">                guess.append((v.relation(y[0], buildvector(im_Letter)), x))</div><div class="line">    guess.sort(reverse=True)</div><div class="line">    print guess[0]</div><div class="line">    count += 1</div></pre></td></tr></table></figure>
<h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># encoding: utf-8</div><div class="line">from PIL import Image</div><div class="line">import os</div><div class="line">import math</div><div class="line"></div><div class="line">class VectorCompare:</div><div class="line">    def magnitude(self, concordance):</div><div class="line">        total = 0</div><div class="line">        for word, count in concordance.iteritems():</div><div class="line">            total += count ** 2</div><div class="line">        return math.sqrt(total)</div><div class="line"></div><div class="line">    def relation(self, concordance1, concordance2):</div><div class="line">        relevance = 0</div><div class="line">        topvalue = 0</div><div class="line">        for word, count in concordance1.iteritems():</div><div class="line">            if concordance2.has_key(word):</div><div class="line">                topvalue += count * concordance2[word]</div><div class="line">        return topvalue / (self.magnitude(concordance1) * self.magnitude(concordance2))</div><div class="line"></div><div class="line"></div><div class="line">def buildvector(im):</div><div class="line">    d1 = &#123;&#125;</div><div class="line">    count = 0</div><div class="line">    for i in im.getdata():</div><div class="line">        d1[count] = i</div><div class="line">        count += 1</div><div class="line">    return d1</div><div class="line"></div><div class="line">v = VectorCompare()</div><div class="line">iconset = [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;]</div><div class="line">image_set = []</div><div class="line"></div><div class="line">for letter in iconset:</div><div class="line">    for img in os.listdir(&apos;./iconset/%s/&apos; % letter):</div><div class="line">        temp = []</div><div class="line">        if img != &quot;Thumbs.db&quot; and img != &apos;.DS_Store&apos;:</div><div class="line">            temp.append(buildvector(Image.open(&apos;./iconset/%s/%s&apos; % (letter, img))))</div><div class="line">        image_set.append(&#123;letter: temp&#125;)</div><div class="line"></div><div class="line">im = Image.open(&apos;captcha.gif&apos;).convert(&apos;P&apos;)</div><div class="line">im2 = Image.new(&apos;P&apos;, im.size, 255)</div><div class="line">temp = &#123;&#125;</div><div class="line"></div><div class="line">for row in range(im.size[1]):</div><div class="line">    for col in range(im.size[0]):</div><div class="line">        pix = im.getpixel((col,row))</div><div class="line">        temp[pix] = pix</div><div class="line">        if pix == 220 or pix == 227:</div><div class="line">            im2.putpixel((col,row), 0)</div><div class="line"></div><div class="line">inLetter = False</div><div class="line">foundLetter = False</div><div class="line">letterStart = 0</div><div class="line">letterEnd = 0</div><div class="line">letter_split = []</div><div class="line"></div><div class="line">for col in range(im2.size[0]):</div><div class="line">    for row in range(im2.size[1]):</div><div class="line">        pix = im2.getpixel((col,row))</div><div class="line">        if pix != 255:</div><div class="line">            inLetter = True</div><div class="line">    if foundLetter == False and inLetter == True:</div><div class="line">        foundLetter = True</div><div class="line">        letterStart = col</div><div class="line">    if foundLetter == True and inLetter == False:</div><div class="line">        foundLetter = False</div><div class="line">        letterEnd = col</div><div class="line">        letter_split.append((letterStart,letterEnd))</div><div class="line">    inLetter = False</div><div class="line"></div><div class="line">count = 0</div><div class="line">for letter in letter_split:</div><div class="line">    im_Letter = im2.crop((letter[0], 0, letter[1], im2.size[1]))</div><div class="line">    guess = []</div><div class="line">    for image in image_set:</div><div class="line">        for x,y in image.iteritems():</div><div class="line">            if len(y) != 0:</div><div class="line">                guess.append((v.relation(y[0], buildvector(im_Letter)), x))</div><div class="line">    guess.sort(reverse=True)</div><div class="line">    print guess[0]</div><div class="line">    count += 1</div></pre></td></tr></table></figure>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>运行程序查看是否正常工作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./crack.py</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(0.9637681159420289, &apos;7&apos;)</div><div class="line">(0.96234028545977, &apos;s&apos;)</div><div class="line">(0.9286884286888929, &apos;9&apos;)</div><div class="line">(0.9835037060984447, &apos;t&apos;)</div><div class="line">(0.9675116507250627, &apos;9&apos;)</div><div class="line">(0.9698971168877263, &apos;j&apos;)</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[向量空间搜索引擎基本理论]]></title>
      <url>http://lizonghang.github.io/2016/07/07/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/</url>
      <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>&emsp;&emsp;向量空间搜索引擎所运用的技术源自矩阵代数，它基于字符在文件中出现的频率来比较文件。<br>&emsp;&emsp;向量空间搜索引擎中第一个重要的元素是<code>项空间</code>的概念。简而言之，一个项空间由文件中出现的每个独立的词组成。<br>&emsp;&emsp;向量空间搜索引擎中第二个重要的元素是<code>项数</code>。项数就是文件中每个字符出现的次数。通常可由表的形式列出。<br>&emsp;&emsp;通过将项空间作为坐标空间，项数作为项空间中的坐标，我们可以为每个文件生成一个向量。以笛卡尔坐标系为例，点的刻画沿X,Y,Z轴。类似的，在我们的例子中一个项空间由三个独立项组成，我们把它们分别称作项1轴，项2轴，项3轴。（在向量空间搜索引擎理论中这些轴通常被称作<code>维数</code>。）通过计算文件中各项出现的次数，并沿各项轴画出坐标，就可确定出与文件所对应的项空间中的点。由这些点可生成该文件的向量。<br>&emsp;&emsp;一旦在项空间中画出该文件的向量，就可以计算向量的<code>大小</code>。把大小看做是原点（坐标（0，0，0）点）到当前文件点之间连线的距离。这样就可运用向量的长度通过计算夹角的余弦来比较不同的文件。例如，相同的文件夹角余弦为1，文件中含有类似项的夹角余弦会是正小数，文件中含有截然不同项的夹角余弦是0。</p>
<h1 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h1><p>&emsp;&emsp;假设我们有三个文件。每个文件分别是三个词：猫、狗和老鼠。这三个词就是项空间，那么我们可以说每个文件分别沿猫维、狗维和老鼠维上有坐标。这些坐标取决于每一项在文件中出现的次数。例如，以下表中的文件1就含有“猫-狗-老鼠”向量的坐标为（3，1，4）<br><img src="/images/table.png" alt="table"><br>&emsp;&emsp;用勾股定理来计算每个文件向量的大小，在该情况下向量维数高于二维，所以有以下公式<br><img src="/images/formula_1.png" alt="formula"><br>无论是多少维的向量，都可以用勾股定理来计算文件向量的大小。<br>&emsp;&emsp;即时对于不同的文件可能会有相同大小的文件向量。例如，对于两个文件向量分别为（1，2，3）和（3，2，1）的文件来说，它们的文件向量大小均为3.74165。这并不矛盾，文件的关联值（relevancy score）是基于要查询的询问项的维数，因此，即便是对于具有相同大小的文件向量的文件，它们的询问项不同。即是说项空间中的两条直线具有相同的长度，但可能不指向同一方向。</p>
<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><p>&emsp;&emsp;为查询文件的索引，我们把查询向量投影到向量空间上，并计算查询向量与文件集中向量之间的余弦夹角。例如，查询项为“老鼠”，那么“猫-狗-老鼠”向量就是（0，0，1）。查询向量大小为<br><img src="/images/formula_2.png" alt=""><br>注：一个简单方法是查看询问项是否属于项空间，如果是，那么||Q||总为1。但这只对单项询问有效。对于多个查询项，计算它们在项空间出现的次数，然后对次数取方根。由于查询项的值总大于1，||Q||将会是某个整数的方根。但前提是每项在询问项中只出现一次。由于本文将要讨论的次干问题，该假设未必是个好假设。<br>&emsp;&emsp;计算查询向量与一文件向量的余弦夹角公式为<br><img src="/images/formula_3.png" alt=""><br>依次计算三个文件向量与查询项向量夹角的余弦值，并将文件按余弦值递减排序<br><img src="/images/formula_4.png" alt=""><br>可以看出文件2是和查询项“老鼠”最相关，该结论可从上面的列表中快速验证。与文件1有些相关，文件3因不含“老鼠”这一项，与查询项完全无关。<br>&emsp;&emsp;一个简单的考虑方法是余弦值越接近1，文件与查询项越相关。如果余弦值为0，文件向量与查询向量正交且完全无关。</p>
<h1 id="文件集索引处理"><a href="#文件集索引处理" class="headerlink" title="文件集索引处理"></a>文件集索引处理</h1><p>&emsp;&emsp;文件集的索引处理对于被索引的文件是很特殊的。向量空间搜索技术可用于任何有一定结构的信息中，因此它对文字、图像、密码钥匙，甚至DNA同样有效。但是，用户必须对所处理的信息做适当的构建，并可将其优化以提高索引处理效率。以检索一个小网站为例。<br>&emsp;&emsp;首先每个HTML文件必须先做预处理，然后索引为文件集合的一部分。（集合只能整体索引。在索引后添加额外的文件会改变项文件的维数并且否定已存文件向量的大小。）<br>&emsp;&emsp;先拆解所有HTML文件的内容，诸如空格、回车键，直到只留有单个词组成的项为止。<br>&emsp;&emsp;然后把间歇字（stop word）从正文中移出。间歇字是那些在英文中常用但总体上不对正文产生任何语义的词，比如’the’,’and’,’of’,’or’。这些词和实际的语义无关，如不去掉会增加项空间的维数，从而加长处理时间。另外，像’quickly’这样的副词因和实际语义无关也可以去掉。<br>&emsp;&emsp;下一步词干化（stem）文件中剩余的项。词干化是将每项简化成词根的形式。例如，词’runner’，’running’,’runs’都将被简化成’run’。<em>Porter Stemming Algorithm</em>的目的就是词干化。这进一步简化了项空间并保持了语义。<br>&emsp;&emsp;完成这三步后我们期望留下保持原文件语义的最少项。现在可以开始通过建立项空间和计算每个文件向量的大小来索引文件集。<br><img src="/images/step.png" alt=""><br>注：要注意的是解析器如何分解信息将直接影响查询结果。例如，如果索引的是一本书，那么索引时间和查询结果将取决于如何对书进行分割，是按章、页还是段落。需要对数据进行一定的试验以找到最优的分割。</p>
<h1 id="向量空间搜索引擎的局限"><a href="#向量空间搜索引擎的局限" class="headerlink" title="向量空间搜索引擎的局限"></a>向量空间搜索引擎的局限</h1><p>&emsp;&emsp;首先，它需要海量计算，因此计算速度极慢。由于是浮点运算，因此需要很长的处理时间，从而导致表现失常。高性能的表现需要在内存中执行优化过的代码。期望随着处理器速度的提高使之不再成为障碍。<br>&emsp;&emsp;其次，动态的文集对每一次文件的添加都需要再索引。这是由于当每次在项空间中引进一个新项时，对应的新矩阵会增加一维，从而所有的文件都要进行再索引，使得文件向量与新维数相对应。这样做使得实时查询几乎不可能，这可能是使该技术没有被广泛使用的主要原因。<br>&emsp;&emsp;第三，为了能发觉有潜在语义索引（Latent Semantic Indexing）的文件之间的额外联系，我们需对文件集做额外的数学变换。LSI可使文件之间在语义层上找到彼此之间的额外联系。它超出了本文的讨论范围，但对向量空间的搜索技术的下一步研究具有重要意义，同时也为实时查询增加了新的障碍。</p>
]]></content>
      
        <categories>
            
            <category> 算法/理论 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[PIL中的概念]]></title>
      <url>http://lizonghang.github.io/2016/07/07/PIL%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h1 id="Bands-频段"><a href="#Bands-频段" class="headerlink" title="Bands(频段)"></a>Bands(频段)</h1><p>一张图片可以由一个或多个数据频段组成，PIL库支持在一张图片中存储多个频段，它们具有相同的尺寸和深度。要获取图像中频段的数量和名称，可使用<code>getbands()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; im = Image.open(&apos;lena.jpg&apos;)</div><div class="line">&gt;&gt;&gt; im.getbands()</div><div class="line">(&apos;R&apos;, &apos;G&apos;, &apos;B&apos;)</div></pre></td></tr></table></figure>
<h1 id="Mode-模式"><a href="#Mode-模式" class="headerlink" title="Mode(模式)"></a>Mode(模式)</h1><p>图像的模式定义了图片中像素的类型和深度。最新发行版支持下列标准模式：</p>
<ul>
<li>1        - 1bit像素，黑白，每个字节存储一个像素</li>
<li>L        - 8bit像素，灰度</li>
<li>P        - 8bit像素，用调色盘索引到其他模式</li>
<li>RGB    - 3x8bit像素，真彩</li>
<li>RGBA    - 4x8bit像素，真彩，带透明遮罩</li>
<li>CMYK    - 4x8bit像素，分色</li>
<li>YCbCr    - 3x8bit像素，彩色视频格式</li>
<li>I        - 32bit有符号整数像素</li>
<li>F        - 32bit浮点像素</li>
</ul>
<p>PIL同时对一些特殊的模式提供有限的支持，包括LA，RGBX，RGBa，但PIL不支持用户自定义的模式。如果要处理其他模式，可使用图像对象序列。</p>
<h1 id="Size-大小"><a href="#Size-大小" class="headerlink" title="Size(大小)"></a>Size(大小)</h1><p>可以通过<code>size</code>属性获取图像大小。这是一个二元元组，含有水平像素尺寸和竖直像素尺寸。</p>
<h1 id="Coordinate-System-坐标系统"><a href="#Coordinate-System-坐标系统" class="headerlink" title="Coordinate System(坐标系统)"></a>Coordinate System(坐标系统)</h1><p>PIL使用了笛卡尔的像素坐标系统，左上角为坐标原点。坐标通常以二元元组的形式传递给库使用。矩形需要表示为四元元组，左上角的坐标优先给出。比如，一个包含有800x600像素的图片可写作(0,0,800,600)。</p>
<h1 id="Palette-调色盘"><a href="#Palette-调色盘" class="headerlink" title="Palette(调色盘)"></a>Palette(调色盘)</h1><p>调色盘模式P使用调色盘来定义每个像素实际的颜色。</p>
<h1 id="Info-信息"><a href="#Info-信息" class="headerlink" title="Info(信息)"></a>Info(信息)</h1><p>你可以使用<code>info</code>属性给图片添加辅助信息。这是一个字典对象。当加载或保存图像文件时能够处理多少信息决定于文件格式处理器。大多数处理器加载图像时给<code>info</code>添加属性，但在存储图片时会忽略掉。</p>
<h1 id="Filters-过滤器"><a href="#Filters-过滤器" class="headerlink" title="Filters(过滤器)"></a>Filters(过滤器)</h1><p>对于输入多个像素输出单个像素的几何操作，PIL库提供了四种不同的重取样过滤器。</p>
<p><code>NEAREST</code> - 取出与输入图像最相近的像素，忽略其他输入像素</p>
<p><code>BILINEAR</code> - 在输入图像中2x2环境下使用线性内插。在当前PIL版本，过滤器采样时使用一个固定的输入环境</p>
<p><code>BICUBIC</code> - 在输入图像中的4x4环境使用三次内插。在当前PIL版本，过滤器采样时使用一个固定的输入环境</p>
<p><code>ANTIALIAS</code> - 使用一个高质量的重采样过滤器计算所有可能对输出有影响的像素来得到输出像素。在当前PIL版本，过滤器只能被用在<code>resize()</code>和<code>thumbnail()</code>方法。</p>
]]></content>
      
        <categories>
            
            <category> PIL </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[快速入门PIL]]></title>
      <url>http://lizonghang.github.io/2016/07/05/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8PIL/</url>
      <content type="html"><![CDATA[<h1 id="使用Image类"><a href="#使用Image类" class="headerlink" title="使用Image类"></a>使用Image类</h1><p>PIL中最重要的类是<code>Image</code>类，可以通过多种方法创建这个类的实例。可以从文件加载图像，或者处理其他图像，或者从scratch创建。</p>
<p>要从文件加载图像，可使用<code>Image</code>模块的<code>open()</code>函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; im = Image.open(&apos;lena.jpg&apos;)</div></pre></td></tr></table></figure>
<p>示例用的图片如下:</p>
<p><img src="/images/lena.jpg" alt="lena"></p>
<p>加载成功将返回一个<code>Image</code>对象。可以使用如下命令检查文件内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print im</div><div class="line">&lt;PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=500x750 at 0x10B9E3890&gt;</div><div class="line">&gt;&gt;&gt; print(im.format, im.size, im.mode)</div><div class="line">(&apos;JPEG&apos;, (500, 750), &apos;RGB&apos;)</div></pre></td></tr></table></figure>
<p><code>format</code>这个属性标识了图像来源。如果图像不是从文件读取那它的值为None。<code>size</code>属性是一个二元tuple，包含width和height(单位px)。<code>mode</code>属性定义了图像bands的数量和名称，以及像素类型和深度。常见的modes有“L”(luminance)表示灰度图像，“RGB”表示真彩色图像，“CMYK”表示出版图像。</p>
<p>如果文件打开错误，则返回<code>IOError</code>错误。</p>
<p>只要有了<code>Image</code>类的实例，就可以通过类的方法处理图像。比如下面的方法可以用来显示图像:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; im.show()</div></pre></td></tr></table></figure>
<pre>
注解：标准的<code>show()</code>效率不高，它需要保存图像到临时文件然后通过xv显示图像。
</pre>

<h1 id="读写图像"><a href="#读写图像" class="headerlink" title="读写图像"></a>读写图像</h1><p>PIL模块支持大量图片格式。使用在<code>Image</code>模块的<code>open()</code>函数从磁盘读取文件。不需要知道文件格式就能打开它，这个库能够根据文件内容自动确定文件格式。</p>
<p>要保存文件，使用<code>Image</code>类的<code>save()</code>方法。保存文件时文件名变得重要了。除非指定格式，否则这个库将会以文件名的扩展名作为格式保存。</p>
<h2 id="创建略缩图"><a href="#创建略缩图" class="headerlink" title="创建略缩图"></a>创建略缩图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; im = Image.open(&apos;lena.jpg&apos;)</div><div class="line">&gt;&gt;&gt; print im.size</div><div class="line">(500, 750)</div><div class="line">&gt;&gt;&gt; size = (250, 375)</div><div class="line">&gt;&gt;&gt; im.thumbnail(size)</div><div class="line">&gt;&gt;&gt; print im.size</div><div class="line">(250, 375)</div></pre></td></tr></table></figure>
<p>使用<code>thumbnail()</code>方法需要注意的是，指定的<code>size</code>应当比原尺寸小，且转换后的图片比例与原图片比例相同。</p>
<h2 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h2><p>继续执行下述步骤,将转换后的图片保存:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; im.save(&apos;lena_thumbnail.jpg&apos;, &apos;JPEG&apos;)</div></pre></td></tr></table></figure>
<h1 id="剪切、粘贴、合并图像"><a href="#剪切、粘贴、合并图像" class="headerlink" title="剪切、粘贴、合并图像"></a>剪切、粘贴、合并图像</h1><p><code>Image</code>类包含的方法允许操作图像部分选区，使用<code>Image.crop()</code>方法获取图像的一个子矩形选区。</p>
<h2 id="从图像中复制出一个矩形选区"><a href="#从图像中复制出一个矩形选区" class="headerlink" title="从图像中复制出一个矩形选区"></a>从图像中复制出一个矩形选区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print im.size</div><div class="line">(500, 750)</div><div class="line">&gt;&gt;&gt; box = (100, 100, 400, 400)</div><div class="line">&gt;&gt;&gt; region = im.crop(box)</div><div class="line">&gt;&gt;&gt; region.show()</div></pre></td></tr></table></figure>
<p>矩形选区有一个四元元组定义，分别表示左上、右下的坐标。这个库以左上角为坐标原点，单位是px，所以上述代码复制了一个 300x300 pixels 的矩形选区。这个选区现在可以被处理并且粘贴到原图。</p>
<p>剪下来的 300x300px 图片如下所示:</p>
<p><img src="/images/lena_cut.jpg" alt="lena_cut"></p>
<h2 id="处理复制的矩形选区并粘贴到原图"><a href="#处理复制的矩形选区并粘贴到原图" class="headerlink" title="处理复制的矩形选区并粘贴到原图"></a>处理复制的矩形选区并粘贴到原图</h2><p>继续上面的步骤:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; region = region.transpose(Image.ROTATE_180)</div><div class="line">&gt;&gt;&gt; im.paste(region, box)</div><div class="line">&gt;&gt;&gt; im.show()</div></pre></td></tr></table></figure>
<p>当粘贴矩形选区的时候必须保证尺寸一致。此外，矩形选区不能在图像外。然而不必保证矩形选区和原图的颜色模式一致，因为矩形选区会被自动转换颜色。</p>
<p>效果图如下:</p>
<p><img src="/images/lena_paste.jpg" alt="lena_paste"></p>
<h2 id="分离和合并颜色通道"><a href="#分离和合并颜色通道" class="headerlink" title="分离和合并颜色通道"></a>分离和合并颜色通道</h2><p>由于上面例子已经对im进行了改变，我们重新将im指向原图片:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; im = Image.open(&apos;lena.jpg&apos;)</div><div class="line">&gt;&gt;&gt; r, g, b = im.split()</div></pre></td></tr></table></figure>
<p>如果是单色通道的图片，使用<code>split()</code>之后会返回图片本身。你可以使用<code>r.show()</code>来查看分离颜色通道后的图片。</p>
<p><img src="/images/lena_split.jpg" alt="lena_split"></p>
<p>将分离的颜色合并为RGB可用<code>merge()</code>方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; img = Image.merge(&apos;RGB&apos;, (b, g, r))</div><div class="line">&gt;&gt;&gt; img.show()</div></pre></td></tr></table></figure>
<p>以b,g,r顺序合并成的图片如图所示:</p>
<p><img src="/images/lena_merge.jpg" alt="lena_merge"></p>
<h1 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h1><p><code>PIL.Image.Image</code>类包含了设置图像大小<code>resize()</code>和旋转图像<code>rotate()</code>的方法。<code>resize()</code>接收一个元组来指定新大小。<code>rotate()</code>接收一个逆时针的角度值。</p>
<h2 id="简单的几何变换"><a href="#简单的几何变换" class="headerlink" title="简单的几何变换"></a>简单的几何变换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; print im.size</div><div class="line">(500, 750)</div><div class="line">&gt;&gt;&gt; im_resize = im.resize((250, 250))</div><div class="line">&gt;&gt;&gt; im_resize.show()</div><div class="line">&gt;&gt;&gt; im_rotate = im.rotate(45)</div><div class="line">&gt;&gt;&gt; im_rotate.show()</div></pre></td></tr></table></figure>
<p><code>im_resize.show()</code>效果图如下:</p>
<p><img src="/images/lena_resize.jpg" alt="lena_resize"></p>
<p><code>im_rotate.show()</code>效果图如下:</p>
<p><img src="/images/lena_rotate.jpg" alt="lena_rotate"></p>
<h2 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h2><p>如果要将图片旋转90°的整数倍，可以使用<code>rotate()</code>方法或者<code>transpose()</code>方法。<code>transpose()</code>还可以将图片按照其竖直或水平边缘翻转，由于图片过多不一一展示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">out = im.transpose(Image.FLIP_LEFT_RIGHT)</div><div class="line">out = im.transpose(Image.FLIP_TOP_BOTTOM)</div><div class="line">out = im.transpose(Image.ROTATE_90)</div><div class="line">out = im.transpose(Image.ROTATE_180)</div><div class="line">out = im.transpose(Image.ROTATE_270)</div></pre></td></tr></table></figure>
<p>使用<code>transpose(ROTATE)</code>和<code>rotate()</code>是没有区别的。更普遍的方法是使用<code>transform()</code>方法。</p>
<h1 id="颜色变换"><a href="#颜色变换" class="headerlink" title="颜色变换"></a>颜色变换</h1><p>Python Imaging Library可以使用<code>convert()</code>方法来实现像素的变换。</p>
<h2 id="颜色模式转换"><a href="#颜色模式转换" class="headerlink" title="颜色模式转换"></a>颜色模式转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; im.convert(&apos;L&apos;).show()</div></pre></td></tr></table></figure>
<p>PIL库支持各种不同模式之间的转换，比如“L”和“RGB”模式。为了转成其他的模式，需要用一张中间模式图像，典型的为RGB图片。</p>
<h1 id="颜色增强"><a href="#颜色增强" class="headerlink" title="颜色增强"></a>颜色增强</h1><p>PIL库提供了许多方法和模块可以用来增强图像</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p><code>ImageFilter</code>模块包含了许多预定义的增强过滤器，通过<code>filter</code>方法调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import ImageFilter</div><div class="line">&gt;&gt;&gt; out = im.filter(ImageFilter.DETAIL)</div></pre></td></tr></table></figure>
<h2 id="点操作"><a href="#点操作" class="headerlink" title="点操作"></a>点操作</h2><p><code>point()</code>方法能够用来实现图片像素值的转换(比如图像对比度处理)。在大多数情况下，<code>point()</code>方法接收一个函数体作为参数，每一个像素都根据此函数处理:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; out = im.point(lambda i: i * 1.2)</div></pre></td></tr></table></figure>
<p>效果图如下，相比原图有增强:</p>
<p><img src="/images/lena_point.jpg" alt="lena_point"></p>
<p>处理个别bands:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># split the image into individual bands</div><div class="line">source = im.split()</div><div class="line"></div><div class="line">R, G, B = 0, 1, 2</div><div class="line"></div><div class="line"># select regions where red is less than 100</div><div class="line">mask = source[R].point(lambda i: i &lt; 100 and 255)</div><div class="line"></div><div class="line"># process the green band</div><div class="line">out = source[G].point(lambda i: i * 0.7)</div><div class="line"></div><div class="line"># paste the processed band back, but only where red was &lt; 100</div><div class="line">source[G].paste(out, None, mask)</div><div class="line"></div><div class="line"># build a new multiband image</div><div class="line">im = Image.merge(im.mode, source)</div></pre></td></tr></table></figure>
<p>效果和原图差异不大，就不上图了。需要注意的是这个语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">imout = im.point(lambda i: expression and 255)</div></pre></td></tr></table></figure>
<p>如果expression的值为false/0，则and之后的不再检查，直接返回0。如果expression的值为true/非0，判断and之后的表达式，并返回最后一个检查的值，语句返回255。</p>
<h2 id="增强"><a href="#增强" class="headerlink" title="增强"></a>增强</h2><p>要使用更多先进的图片增强功能，可以使用模块<code>ImageEnhance</code>中的类。你可以通过它调整对比度、亮度、颜色平衡度和尖锐度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from PIL import ImageEnhance</div><div class="line"></div><div class="line">enh = ImageEnhance.Contrast(im)</div><div class="line">enh.enhance(0.5).show(&quot;50% less contrast&quot;)</div></pre></td></tr></table></figure>
<p>对比度降低50%后效果如下:</p>
<p><img src="/images/lena_contrast.jpg" alt="lena_contrast"></p>
<h1 id="多帧图像序列"><a href="#多帧图像序列" class="headerlink" title="多帧图像序列"></a>多帧图像序列</h1><p>PIL支持图像序列(动画格式)。支持的序列格式包括FLI/FLC,GIF等。TIFF文件也能包含许多帧。打开一个序列文件时，PIL自动装载序列的第一帧。你可以使用函数来移动帧。参考图片如下:</p>
<p><img src="/images/niko.gif" alt="niko"></p>
<h2 id="读取序列"><a href="#读取序列" class="headerlink" title="读取序列"></a>读取序列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line"></div><div class="line">im = Image.open(&quot;niko.gif&quot;)</div><div class="line">im.seek(0) # 跳到第一帧</div><div class="line"></div><div class="line">try:</div><div class="line">    while 1:</div><div class="line">        im.seek(im.tell()+1) # 跳到下一帧，tell()方法返回目前的帧序号</div><div class="line">        im.show()</div><div class="line">except EOFError:</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>以前的PIL库只允许seek到下一帧，如果要倒回去需要重新打开。而现在的PIL库你可以seek到任意帧。</p>
<h2 id="序列迭代类"><a href="#序列迭代类" class="headerlink" title="序列迭代类"></a>序列迭代类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div><div class="line"></div><div class="line">class ImageSequence:</div><div class="line">    def __init__(self, im):</div><div class="line">        self.im = im</div><div class="line">    def __getitem__(self, ix):</div><div class="line">        try:</div><div class="line">            if ix:</div><div class="line">                self.im.seek(ix)</div><div class="line">            return self.im</div><div class="line">        except EOFError:</div><div class="line">            raise IndexError</div><div class="line"></div><div class="line">im = Image.open(&apos;niko.gif&apos;)</div><div class="line">for frame in ImageSequence(im):</div><div class="line">    frame.show()</div></pre></td></tr></table></figure>
<h1 id="更多关于读取图像"><a href="#更多关于读取图像" class="headerlink" title="更多关于读取图像"></a>更多关于读取图像</h1><p><code>Image.open()</code>方法是用来打开一个图片文件的。大多数情况下可以简单的将图像文件名作参数传入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">im = Image.open(&apos;lena.jpg&apos;)</div></pre></td></tr></table></figure>
<p>正常返回结果是一个<code>PIL.Image.Image</code>实例。否则会抛出<code>IOError</code>错误。</p>
<p>你可以传入一个类文件代替文件名。这个类文件必须实现<code>read()</code>，<code>seek()</code>，<code>tell()</code>方法，并且以二进制模式打开。</p>
<h2 id="从文件读取"><a href="#从文件读取" class="headerlink" title="从文件读取"></a>从文件读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; fp = open(&apos;lena.jpg&apos;, &apos;rb&apos;)</div><div class="line">&gt;&gt;&gt; im = Image.open(fp)</div></pre></td></tr></table></figure>
<h2 id="从string读取"><a href="#从string读取" class="headerlink" title="从string读取"></a>从string读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import urllib2</div><div class="line">&gt;&gt;&gt; import StringIO</div><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; headers = &#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36&apos;&#125;</div><div class="line">&gt;&gt;&gt; req = urllib2.Request(&apos;http://tupian.enterdesk.com/2014/mxy/06/19/1/8.jpg&apos;, headers=headers)</div><div class="line">&gt;&gt;&gt; buffer = urllib2.urlopen(req).read()</div><div class="line">&gt;&gt;&gt; im = Image.open(StringIO.StringIO(buffer))</div><div class="line">&gt;&gt;&gt; im.show()</div></pre></td></tr></table></figure>
<p>使用的示例图片如下:</p>
<p><img src="/images/string_pic.jpg" alt=""></p>
<h2 id="从压缩包读取"><a href="#从压缩包读取" class="headerlink" title="从压缩包读取"></a>从压缩包读取</h2><p>为示范，先将一些文件例如”lena.jpg”和”niko.gif”打包，压缩包名假设为”Imaging.tar”。从压缩包中读取”lena.jpg”可使用<code>TarIO.TarIO()</code>方法获取图片，并交由<code>Image.open()</code>处理。(Linux/Unix系统下可以简单使用<code>tar -cvf Imaging.tar lena.jpg niko.gif </code>打包为tar压缩格式)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image, TarIO</div><div class="line">&gt;&gt;&gt; fp = TarIO.TarIO(&apos;Imaging.tar&apos;, &apos;lena.jpg&apos;)</div><div class="line">&gt;&gt;&gt; im = Image.open(fp)</div></pre></td></tr></table></figure>
<p>注意：对zip压缩包进行操作时可能会出现解码错误。</p>
<h1 id="控制解码器"><a href="#控制解码器" class="headerlink" title="控制解码器"></a>控制解码器</h1><p>部分解码器支持在读取图片文件的时候对图像进行处理，常用于创建略缩图时加速解码速度(当速度比质量重要时)和传输给单色激光打印机时()。<code>draft()</code>方法可以在图像尚未加载完时对其进行处理，所以给定的模式和大小尽可能的匹配。这是通过重新配置图像解码器完成的。</p>
<h2 id="在草稿模式读取"><a href="#在草稿模式读取" class="headerlink" title="在草稿模式读取"></a>在草稿模式读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; im = Image.open(file)</div><div class="line">&gt;&gt;&gt; print(&quot;original =&quot;, im.mode, im.size)</div><div class="line">&gt;&gt;&gt; im.draft(&quot;L&quot;, (100, 100))</div><div class="line">&gt;&gt;&gt; print(&quot;draft =&quot;, im.mode, im.size)</div></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">original= RGB (500, 750)</div><div class="line">draft= L (125, 188)</div></pre></td></tr></table></figure>
<p>注意得到的图片可能不会完全的匹配给定的模式和大小。为了保证图像不比给定的大小大，使用<code>im.thumbnail()</code>方法来代替。</p>
]]></content>
      
        <categories>
            
            <category> PIL </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Scrapy采集天气数据]]></title>
      <url>http://lizonghang.github.io/2016/07/05/Scrapy%E9%87%87%E9%9B%86%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>很多网站都提供了浏览者本地的天气信息，这些信息大多是利用某些网站提供的天气API获取的，也有利用爬虫采集的。本文介绍如何用Scrapy来采集天气信息。天气信息来源为<a href="http://weather.sina.com.cn/" target="_blank" rel="external">新浪天气频道</a>。本文提取“国内”栏目的天气信息。</p>
<p>Scrapy是Python开发的一个快速,高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。用途广泛，可以用于数据挖掘、监测和自动化测试。</p>
<p>如果你还没有安装Scrapy，请参考官方的<a href="http://doc.scrapy.org/en/latest/intro/install.html" target="_blank" rel="external">安装向导</a>或在网上查找安装方法。</p>
<h1 id="创建Scrapy项目"><a href="#创建Scrapy项目" class="headerlink" title="创建Scrapy项目"></a>创建Scrapy项目</h1><p>在开始爬取之前，需要创建一个scrapy项目。进入需要存储代码的目录，执行命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ scrapy startproject weather</div></pre></td></tr></table></figure>
<p>正常初始化的文件内容应该是这样的:</p>
<p><img src="/images/weather_tree.png" alt="weather-dir"></p>
<h1 id="定义Item"><a href="#定义Item" class="headerlink" title="定义Item"></a>定义Item</h1><p>Item是保存爬取到的数据的容器，使用方法和Python字典相似，并且提供了额外的保护机制来避免拼写错误导致的未定义字段错误。</p>
<p>首先需要根据从<code><a href="http://weather.sina.com.cn/china/" target="_blank" rel="external">http://weather.sina.com.cn/china/</a></code>中获取到的数据对item进行建模。需要的内容如图:</p>
<p><img src="/images/item.png" alt="item"></p>
<p>编辑weather/items.py文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*-</div><div class="line">import scrapy</div><div class="line"></div><div class="line">class WeatherItem(scrapy.Item):</div><div class="line">    county = scrapy.Field() # 县/区</div><div class="line">    weather_day = scrapy.Field() # 白天天气</div><div class="line">    wind_day = scrapy.Field() # 白天风向</div><div class="line">    temperate_max = scrapy.Field() # 最高温度</div><div class="line">    weather_night = scrapy.Field() # 夜间天气</div><div class="line">    wind_night = scrapy.Field() # 夜间风向</div><div class="line">    temperate_min = scrapy.Field() # 最低温度</div></pre></td></tr></table></figure>
<h1 id="编写Spider"><a href="#编写Spider" class="headerlink" title="编写Spider"></a>编写Spider</h1><p>Spider是用户编写的用于从单个或多个网页中爬取数据的类。为了创建一个Spider，必须继承scrapy.Spider类，且定义以下三个属性:</p>
<ul>
<li>name - 用于区别Spider。该名字必须是唯一的，不可以给不同的Spider使用相同的名字。</li>
<li>start_urls - 包含了Spider在启动时爬取的url列表。是Spider第一轮爬取的链接。后续的URL则从初始URL获取到的数据中提取。</li>
<li>parse(self, response) - 被调用时，每个初始URL完成下载后生成的Response对象将会作为唯一的参数传递给该函数。该方法负责解析返回的数据，提取数据以及生成需要进一步处理的URL的Request对象。</li>
</ul>
<p>首先分析一下需要爬取的数据的位置和网页源代码:</p>
<p><img src="/images/province.png" alt="province"></p>
<p><img src="/images/province_code.png" alt="code"></p>
<p>我们可以看到，全国城市都位于一个<code>class=”wd_piC”</code>的<code>div</code>中的<code>a</code>标签中，于是我们可以使用如下代码来提取各省份的链接。保存于weather/spiders目录下的localweather.py文件中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def parse(self, response):</div><div class="line">    selector = scrapy.Selector(response)</div><div class="line">    for num in selector.xpath(&apos;//div[@class=&quot;wd_piC&quot;]&apos;):</div><div class="line">        for province in num.xpath(&apos;a&apos;):</div><div class="line">            self.provinces.append(province.xpath(&apos;@href&apos;).extract()[0])</div><div class="line">    yield Request(self.provinces.pop(), callback=self.getCountyWeather)</div></pre></td></tr></table></figure>
<p>上述操作将所有省份的链接提取出来，存储到一个叫<code>provinces</code>的列表中，然后从中取出一个链接，进行下一次爬取。在编写回调函数getCountyWeather之前，先查看数据的位置和网页源代码:</p>
<p><img src="/images/county.png" alt="county"></p>
<p><img src="/images/county_code.png" alt="code"></p>
<p>我们需要的信息在多个<code>class=”wd_cm_table”</code>的<code>table</code>标签中，每条信息又在其中的多个<code>tr</code>标签中，最后标签<code>td</code>中含有我们需要的信息。</p>
<p>用于获取这些信息的方法getCountyWeather()代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">def getCountyWeather(self, response):</div><div class="line">    item = WeatherItem()</div><div class="line">    selector = scrapy.Selector(response)</div><div class="line">    for table in selector.xpath(&apos;//table[@class=&quot;wd_cm_table&quot;]&apos;):</div><div class="line">        for each_row in table.xpath(&apos;tr&apos;):</div><div class="line">            tds = each_row.xpath(&apos;td&apos;)</div><div class="line">            item[&apos;county&apos;] = tds[0].xpath(&apos;a/text()&apos;).extract()[0]</div><div class="line">            item[&apos;weather_day&apos;] = tds[1].xpath(&apos;p/text()&apos;).extract()[0]</div><div class="line">            item[&apos;wind_day&apos;] = tds[2].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">            item[&apos;temperate_max&apos;] = tds[3].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">            item[&apos;weather_night&apos;] = tds[4].xpath(&apos;p/text()&apos;).extract()[0]</div><div class="line">            item[&apos;wind_night&apos;] = tds[5].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">            item[&apos;temperate_min&apos;] = tds[6].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">            yield item</div><div class="line">    if len(self.provinces) &gt; 0:</div><div class="line">        yield Request(self.provinces.pop(), callback=self.getCountyWeather)</div><div class="line">    else:</div><div class="line">        print &apos;The Spider Has Finished Its Work! Wish To Meet U Later!&apos;</div></pre></td></tr></table></figure>
<h1 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h1><p>localweather.py中的全部代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># encoding: utf-8</div><div class="line">import scrapy</div><div class="line">from scrapy.http import Request</div><div class="line">from weather.items import WeatherItem</div><div class="line"></div><div class="line"></div><div class="line">class WeatherSpider(scrapy.Spider):</div><div class="line">    name = &apos;WeatherSpider&apos;</div><div class="line">    allowed_domains = [&apos;sina.com.cn&apos;]</div><div class="line">    start_urls = [&apos;http://weather.sina.com.cn/china/&apos;]</div><div class="line">    provinces = []</div><div class="line"></div><div class="line">    def parse(self, response):</div><div class="line">        selector = scrapy.Selector(response)</div><div class="line">        for num in selector.xpath(&apos;//div[@class=&quot;wd_piC&quot;]&apos;):</div><div class="line">            for province in num.xpath(&apos;a&apos;):</div><div class="line">                self.provinces.append(province.xpath(&apos;@href&apos;).extract()[0])</div><div class="line">        yield Request(self.provinces.pop(), callback=self.getCountyWeather)</div><div class="line"></div><div class="line">    def getCountyWeather(self, response):</div><div class="line">        item = WeatherItem()</div><div class="line">        selector = scrapy.Selector(response)</div><div class="line">        for table in selector.xpath(&apos;//table[@class=&quot;wd_cm_table&quot;]&apos;):</div><div class="line">            for each_row in table.xpath(&apos;tr&apos;):</div><div class="line">                tds = each_row.xpath(&apos;td&apos;)</div><div class="line">                item[&apos;county&apos;] = tds[0].xpath(&apos;a/text()&apos;).extract()[0]</div><div class="line">                item[&apos;weather_day&apos;] = tds[1].xpath(&apos;p/text()&apos;).extract()[0]</div><div class="line">                item[&apos;wind_day&apos;] = tds[2].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">                item[&apos;temperate_max&apos;] = tds[3].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">                item[&apos;weather_night&apos;] = tds[4].xpath(&apos;p/text()&apos;).extract()[0]</div><div class="line">                item[&apos;wind_night&apos;] = tds[5].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">                item[&apos;temperate_min&apos;] = tds[6].xpath(&apos;text()&apos;).extract()[0]</div><div class="line">                yield item</div><div class="line">        if len(self.provinces) &gt; 0:</div><div class="line">            yield Request(self.provinces.pop(), callback=self.getCountyWeather)</div><div class="line">        else:</div><div class="line">            print &apos;The Spider Has Finished Its Work! Wish To Meet U Later!&apos;</div></pre></td></tr></table></figure>
<h1 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h1><p>存储到Item中的数据可以导出为JSON/JSON lines/CSV/XML格式的文件。以导出为CSV文件为例，其他的请参考<a href="http://doc.scrapy.org/en/1.1/topics/feed-exports.html" target="_blank" rel="external">官方说明</a>。需要修改weather/settings.py中的配置，在配置最后添加代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FEED_URI = u&apos;~/Desktop/Weather.csv&apos; # 存储csv文件的目录，可任意修改</div><div class="line">FEED_FORMAT = &apos;CSV&apos; # 存储格式为csv，可修改为json等其他格式</div></pre></td></tr></table></figure>
<p>随后，在项目的scrapt.cfg文件同级目录下使用命令，运行爬虫:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ scrapy crawl WeatherSpider</div></pre></td></tr></table></figure>
<p>等待运行结束，得到一个csv文件如下所示，显示为乱码，这是由于编码问题造成的:</p>
<p><img src="/images/csverr.png" alt="csv"></p>
<p>将csv文件用Sublime Text打开，点击File-&gt;Save with Encoding-&gt;UTF-8 with BOM，再用Excel打开，即可恢复正常。该文件中包含了全国所有城市的天气情况。</p>
<p><img src="/images/csv1.png" alt="csv"></p>
<p>然而，csv文件中的顺序并不是按照Items.py中指定的顺序来的，可作如下修改:</p>
<p>第一步:在scrapy的spider同层目录下，新建CsvItemExporter.py文件夹，内容如下(文件名可修改):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from scrapy.conf import settings</div><div class="line">from scrapy.contrib.exporter import CsvItemExporter</div><div class="line"></div><div class="line">class ProjectCsvItemExporter(CsvItemExporter):</div><div class="line">    def __init__(self, *args, **kwargs):</div><div class="line">        kwargs[&apos;delimiter&apos;] = settings.get(&apos;CSV_DELIMITER&apos;, &apos;,&apos;)</div><div class="line">        if settings.get(&apos;FIELDS_TO_EXPORT&apos;, []):</div><div class="line">            kwargs[&apos;fields_to_export&apos;] = settings.get(&apos;FIELDS_TO_EXPORT&apos;, [])</div><div class="line"></div><div class="line">        super(ProjectCsvItemExporter, self).__init__(*args, **kwargs)</div></pre></td></tr></table></figure>
<p>第二步:在settings.py文件末新增如下内容，指定item的field顺序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">FEED_EXPORTERS = &#123;</div><div class="line">    # 项目名.文件名.类名</div><div class="line">    &apos;csv&apos;: &apos;weather.CsvItemExporter.ProjectCsvItemExporter&apos;, </div><div class="line">&#125;</div><div class="line"></div><div class="line"># 导出字段顺序</div><div class="line">FIELDS_TO_EXPORT = [</div><div class="line">    &apos;county&apos;,</div><div class="line">    &apos;weather_day&apos;,</div><div class="line">    &apos;wind_day&apos;,</div><div class="line">    &apos;temperate_max&apos;,</div><div class="line">    &apos;weather_night&apos;,</div><div class="line">    &apos;wind_night&apos;,</div><div class="line">    &apos;temperate_min&apos;,</div><div class="line">]</div></pre></td></tr></table></figure>
<p>第三步:再次运行爬虫，获取的csv文件内容如下所示:</p>
<p><img src="/images/csv2.png" alt="csv"></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>关于为Item指定中文名的问题作者暂时还未找到类似django model中verbose_name参数的解决方法，若有需要可在程序末对csv文件进行文件IO处理，替换第一行。或者取代scrapy的文件导出，自行将数据导出到csv文件。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[添加Google统计]]></title>
      <url>http://lizonghang.github.io/2016/07/03/%E6%B7%BB%E5%8A%A0Google%E7%BB%9F%E8%AE%A1/</url>
      <content type="html"><![CDATA[<p>步骤一:</p>
<p>注册Google账户，登陆后访问<a href="https://analytics.google.com" target="_blank" rel="external">Google Analytics</a>，按照提示填写网站信息开通GA服务，获取统计ID。</p>
<p>步骤二:</p>
<p>编辑主题配置文件，找到字段google_analytics，删除注释并填写统计ID:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">google_analytics: your-analytics-id</div></pre></td></tr></table></figure>
<p>步骤三:</p>
<p>进入GA数据查看页查看会话数、用户数、浏览量、平均会话时长、跳出率等信息</p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[设置侧边栏社交链接]]></title>
      <url>http://lizonghang.github.io/2016/07/03/%E8%AE%BE%E7%BD%AE%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%A4%BE%E4%BA%A4%E9%93%BE%E6%8E%A5/</url>
      <content type="html"><![CDATA[<p>编辑主题配置文件_config.yml，找到字段social，删除注释并添加社交站点名称与地址，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Social links</div><div class="line">social:</div><div class="line">  github: https://github.com/your-user-name</div><div class="line">  twitter: https://twitter.com/your-user-name</div><div class="line">  weibo: http://weibo.com/your-user-name</div><div class="line">  douban: http://douban.com/people/your-user-name</div><div class="line">  zhihu: http://www.zhihu.com/people/your-user-name</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[创建about页面]]></title>
      <url>http://lizonghang.github.io/2016/07/03/%E5%88%9B%E5%BB%BAabout%E9%A1%B5%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>创建“关于我”页面</p>
<p>新建一个about页面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new page &apos;about&apos;</div></pre></td></tr></table></figure>
<p>修改主题配置文件，将menu下的about:/about/注释取消即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /</div><div class="line">  archives: /archives</div><div class="line">  tags: /tags</div><div class="line">  about: /about</div></pre></td></tr></table></figure>
<p>更改menu中项目的顺序可更改在菜单中显示的顺序。</p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[创建分类页面]]></title>
      <url>http://lizonghang.github.io/2016/07/03/%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>为Hexo添加分类页面的index.html，并在其菜单中显示各分类的链接</p>
<p>第一步:新建一个页面，命名为categories:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new page categories</div></pre></td></tr></table></figure>
<p>第二步:编辑新建的md文件，将页面类型设置为”categories”，主题将自动为这个页面显示所有的分类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">title: 分类</div><div class="line">date: 2014-12-22 12:39:04</div><div class="line">type: &quot;categories&quot;</div><div class="line">---</div></pre></td></tr></table></figure>
<p>注意: 如果有启动多说或Disqus评论，默认的页面也会带有评论。如果需要关闭可以将字段comments设置为false:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">title: 分类</div><div class="line">date: 2014-12-22 12:39:04</div><div class="line">type: &quot;categories&quot;</div><div class="line">comments: false</div><div class="line">---</div></pre></td></tr></table></figure>
<p>第三步:编辑主题配置文件_config.yml，将menu中的categories:/categories注释去掉:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /</div><div class="line">  categories: /categories</div><div class="line">  archives: /archives</div><div class="line">  tags: /tags</div></pre></td></tr></table></figure>
<p>第四步:清空缓存、生成静态文件、发布/预览:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div><div class="line">$ hexo generate</div><div class="line">$ hexo deploy	# 发布</div><div class="line">$ hexo server	# 打开本地服务器在页面上预览</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Hexo搭建Github Page]]></title>
      <url>http://lizonghang.github.io/2016/06/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAGithub-Page/</url>
      <content type="html"><![CDATA[<h1 id="创建Github-io"><a href="#创建Github-io" class="headerlink" title="创建Github.io"></a>创建Github.io</h1><p>本文默认的前提为你会使用Git，如不会使用Git或没有Github账号，请参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的Git教程</a></p>
<p>要在github上搭建github pages，需要在你的github下新建一个名为[username].github.io的仓库，其中username是你的用户名(或组织名称)。注意: 如果username与你的用户名不同将无法成功。</p>
<p>在电脑自定义的位置新建一个文件夹如github.io，然后进入github.io文件夹执行git初始化命令并克隆github.io仓库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git init</div><div class="line">$ git clone https://github.com/username/username.github.io</div></pre></td></tr></table></figure>
<p>进入项目文件夹并增加一个index.html文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd username.github.io</div><div class="line">$ echo &quot;Hello World&quot; &gt; index.html</div></pre></td></tr></table></figure>
<p>将你的github.com/username/username.github.io设置一个名称，假设为blog:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote add blog git@github.com:username/username.github.io.git</div></pre></td></tr></table></figure>
<p>执行add,commit操作并push到你的blog仓库，注意，请确认你是否push到了正确的仓库:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git add -A</div><div class="line">$ git commit -m &quot;Initial Commit&quot;</div><div class="line">$ git push blog master</div></pre></td></tr></table></figure>
<p>如果出现错误，不能push，请尝试先进行pull，再进行push操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull blog master</div></pre></td></tr></table></figure>
<p>当你的username.github.io仓库中存在index.html时，访问你的博客页面，如username.github.io，可以看到页面上出现“Hello World”，你就拥有了一个自己的github博客。</p>
<h1 id="使用Hexo作博客模板"><a href="#使用Hexo作博客模板" class="headerlink" title="使用Hexo作博客模板"></a>使用Hexo作博客模板</h1><p>当然不是每个人都有时间去写博客页面或管理自己的博客，此时即可借助Hexo来帮你管理和生成你的博客。</p>
<p>在安装Hexo之前，请确保你的电脑中安装有node.js，否则可能出现错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">init env: node: No such file or directory</div></pre></td></tr></table></figure>
<p>若电脑中没有node.js，前往<a href="https://nodejs.org/en/" target="_blank" rel="external">nodejs的官方网站</a>下载，本人使用的是<a href="https://nodejs.org/dist/v4.4.7/node-v4.4.7.pkg" target="_blank" rel="external">v4.4.7 LTS版本</a>。下载完成后，运行安装程序即可完成安装，安装node.js后也安装好了npm。</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo npm install -g hexo</div></pre></td></tr></table></figure>
<h2 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init</div></pre></td></tr></table></figure>
<p>这个命令会初始化博客目录，执行命令时在你想要创建的目录下执行，此时该目录下会生成以下文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">   ├── .deploy</div><div class="line">   ├── public</div><div class="line">   ├── scaffolds</div><div class="line">   ├── scripts</div><div class="line">   ├── source</div><div class="line">   |   ├── _drafts</div><div class="line">   |   └── _posts</div><div class="line">   ├── themes</div><div class="line">   ├── _config.yml</div><div class="line">   └── package.json</div></pre></td></tr></table></figure>
<p>文件说明:</p>
<ul>
<li>.deploy：执行hexo deploy命令部署到GitHub上的内容目录</li>
<li>public：执行hexo generate命令，输出的静态网页内容目录</li>
<li>scaffolds：layout模板文件目录，其中的md文件可以添加编辑</li>
<li>scripts：扩展脚本目录，这里可以自定义一些javascript脚本</li>
<li>source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。</li>
<li>_drafts：草稿文章</li>
<li>_posts：发布文章</li>
<li>themes：主题文件目录</li>
<li>_config.yml：全局配置文件，大多数的设置都在这里</li>
<li>package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮</li>
</ul>
<p>你可以尝试使用运行hexo服务器并<a href="127.0.0.1:4000" target="_blank" rel="external">在浏览器中打开</a>来检查Hexo是否正常工作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<h2 id="将Hexo的模板应用到github-io"><a href="#将Hexo的模板应用到github-io" class="headerlink" title="将Hexo的模板应用到github.io"></a>将Hexo的模板应用到github.io</h2><p>在hexo中有两个_config.yml文件，一个位于hexo的根目录下，我们称之为全局配置文件，另一个位于/themes/landscape/_config.yml，称之为主题配置文件。</p>
<p>打开全局配置文件_config.yml，你需要注意的配置有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">title: title    #博客名</div><div class="line">subtitle: subtitle  #博客副标题</div><div class="line">description:          #网站描述, 用于爬虫抓取的关键词</div><div class="line">author: author    #作者名称</div><div class="line">email: email  #作者邮箱</div><div class="line">language: zh-CN       #网页编码,中文</div><div class="line">root: /			# 一定要从/开始，否则与github.io不能同步路径</div><div class="line">deploy:</div><div class="line">  type: github    #部署类型Github</div><div class="line">  repository: git@github.com:username/username.github.io.git </div><div class="line">  branch: master   #部署分支,一般使用master主分支</div></pre></td></tr></table></figure>
<p>保存设置后执行命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<p>随后将hexo下的模板文件同步到github:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo deploy</div></pre></td></tr></table></figure>
<p>稍等片刻，打开你的username.github.io，应当可以看到hexo的模板页面。</p>
<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h2><p>使用如下命令后在hexo根目录中/source/_posts/目录下新增一个new-article.md文本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new &apos;new-article&apos;</div></pre></td></tr></table></figure>
<p>编辑该文件，以markdown格式书写自己的博文。关于markdown的使用方法请参考<a href="http://www.appinn.com/markdown/" target="_blank" rel="external">Markdown语法说明(简体中文版)</a>。编辑时，可启动hexo本地服务器实时查看<a href="127.0.0.1:4000" target="_blank" rel="external">页面效果</a>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>编辑完成后，使用如下命令发布到github上:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo clean		# 清理原有文件，以防与新文件冲突</div><div class="line">$ hexo generate		# 生成静态站点文件</div><div class="line">$ hexo deploy		# 发布到github pages上</div></pre></td></tr></table></figure>
<p>完成操作后，稍等十秒(github pages更新有延迟)，刷新github pages页面查看页面效果</p>
<h2 id="删除文章"><a href="#删除文章" class="headerlink" title="删除文章"></a>删除文章</h2><p>直接删除本地hexo目录下/source/_posts/中的md文件，再执行清理、生成静态站点文件、发布操作即可。命令参考”新增文章”。</p>
<h1 id="更换模板"><a href="#更换模板" class="headerlink" title="更换模板"></a>更换模板</h1><p>官方默认的主题为landscape主题，主题存放于themes文件夹中，可以更改全局配置文件来更换为需要的主题。</p>
<h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h2><p>官方提供了许多<a href="https://hexo.io/themes/" target="_blank" rel="external">主题</a>，可自行选择喜欢的主题并下载。以我使用的是<a href="https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="external">next</a>主题为例。首先需要将主题文件下载下来(在Downloads分类下)，解压后存放于themes目录下，并将文件夹名称简化为next。</p>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>打开全局配置文件，找到theme字段，将其更改为next，<a href="127.0.0.1:4000" target="_blank" rel="external">验证主题</a>是否启动:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo s --debug</div></pre></td></tr></table></figure>
<h3 id="选择-Scheme"><a href="#选择-Scheme" class="headerlink" title="选择 Scheme"></a>选择 Scheme</h3><p>NexT通过Scheme提供主题中的主题。Mist是NexT的第一款Scheme。启用Mist仅需在主题配置文件中将 #scheme: Mist 前面的#注释去掉即可。</p>
<h3 id="语言设置"><a href="#语言设置" class="headerlink" title="语言设置"></a>语言设置</h3><p>编辑全局配置文件，将 language 设置成需要的语言。例如选用正体中文，则配置为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">language: zh-Hans</div></pre></td></tr></table></figure>
<p>可用的语言如以下表格所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>语言</th>
<th>代码</th>
<th>设定值</th>
</tr>
</thead>
<tbody>
<tr>
<td>English</td>
<td>en</td>
<td>language: en</td>
</tr>
<tr>
<td>简体中文</td>
<td>zh-Hans</td>
<td>language: zh-Hans</td>
</tr>
<tr>
<td>French</td>
<td>fr-FR</td>
<td>language: fr-FR</td>
</tr>
<tr>
<td>正体中文</td>
<td>zh-hk/zh-tw</td>
<td>language: zh-hk</td>
</tr>
<tr>
<td>Russian</td>
<td>ru</td>
<td>language: ru</td>
</tr>
<tr>
<td>German</td>
<td>de</td>
<td>language: de</td>
</tr>
</tbody>
</table>
</div>
<h3 id="菜单配置"><a href="#菜单配置" class="headerlink" title="菜单配置"></a>菜单配置</h3><p>菜单配置在主题配置文件的menu。若站点运行在子目录中，请将链接前缀的/去掉。默认支持的菜单项有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>键值</th>
<th>设定值</th>
<th>comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>home</td>
<td>home:/</td>
<td>主页</td>
</tr>
<tr>
<td>archives</td>
<td>archives: /archives</td>
<td>归档页</td>
</tr>
<tr>
<td>categories</td>
<td>categories: /categories</td>
<td>分类页（需手动创建）</td>
</tr>
<tr>
<td>tags</td>
<td>tags: /tags</td>
<td>标签页（需手动创建）</td>
</tr>
<tr>
<td>about</td>
<td>about: /about</td>
<td>关于页面 （需手动创建）</td>
</tr>
<tr>
<td>commonweal</td>
<td>commonweal: /404.html</td>
<td>公益 404 （需手动创建）</td>
</tr>
</tbody>
</table>
</div>
<p>菜单配置示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /</div><div class="line">  archives: /archives</div><div class="line">  #about: /about</div><div class="line">  #categories: /categories</div><div class="line">  tags: /tags</div><div class="line">  #commonweal: /404.html</div></pre></td></tr></table></figure>
<h3 id="侧栏设置"><a href="#侧栏设置" class="headerlink" title="侧栏设置"></a>侧栏设置</h3><p>默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示。可以通过修改主题配置文件中的 sidebar 字段来控制侧栏的行为。</p>
<p>支持的选项有：</p>
<p>post - 默认行为，在文章页面（拥有目录列表）时显示<br>always - 在所有页面中都显示<br>hide - 在所有页面中都隐藏（可以手动展开）</p>
<p>侧栏示例配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sidebar: post</div></pre></td></tr></table></figure>
<h3 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h3><p>编辑主题配置文件，新增字段 avatar，值设置成头像的链接地址。</p>
<p>其中，头像的链接地址可以是完整网络图片url，或站内文件。其中站内文件的url与图片放置位置如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/uploads/avatar.jpg - 需要将头像图片放置在站点的source/uploads/（可能需要新建uploads目录）</div><div class="line">/images/avatar.jpg - 需要将头像图片放置在主题的source/images/目录下|</div></pre></td></tr></table></figure>
<p>头像配置示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">avatar: https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460</div></pre></td></tr></table></figure>
<h3 id="作者名称"><a href="#作者名称" class="headerlink" title="作者名称"></a>作者名称</h3><p>编辑全局配置文件，设置 author 为作者的昵称。</p>
<h3 id="站点描述设置"><a href="#站点描述设置" class="headerlink" title="站点描述设置"></a>站点描述设置</h3><p>编辑全局配置文件，设置 description 字段为你的站点描述。</p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
